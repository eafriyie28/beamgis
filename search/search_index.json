{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to BeamGIS","text":"<p>A python package for geospatial analysis and mapping</p> <ul> <li>GitHub: https://github.com/eafriyie28/beamgis</li> <li>Documentation: https://eafriyie28.github.io/beamgis</li> <li>Pypi: https://pypi.org/project/beamgis</li> <li>Tutorials: https://youtu.be/elXFhu888DI</li> <li>Free software: MIT License</li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<p>BeamGIS is a friendly, beginner-oriented Python package that brings interactive mapping and geospatial analysis to your Jupyter notebooks with minimal coding. Designed especially for high school students and non-specialists, it offers a gentle introduction to powerful GIS concepts inspired by Leafmap Geospatial Python Package. Under the hood, BeamGIS leverages open-source gems; Folium and ipyleaflet for crisp, interactive maps; WhiteboxTools and WhiteboxGUI for robust spatial analyses; and ipywidgets to craft intuitive, responsive interfaces. Whether you are exploring your first dataset or building simple web maps, BeamGIS makes the journey both approachable and enjoyable.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Create an interactive map with a simple one line code.</li> <li>Changing basemaps interactively.</li> <li>Changing basemaps interactively through a basemapgui.</li> <li>Adding  XYZ, WMS and vector tile services.</li> <li>Display vector data from geodata frame, geojson, shapefiles</li> <li>Display raster data.</li> <li>Create Split Maps.</li> <li>Creating heatmaps with a csv url.</li> <li>Creating heatmaps with a csv url using heatmapgui.</li> <li>Visualize COG assets found within STAC items with a time slider.</li> </ul>"},{"location":"#usage","title":"Usage","text":"<p>Launch the interactive notebook tutorial for the beamgis Python package with Google Colab <pre><code>!pip install beamgis\nimport beamgis\n</code></pre> Check beamgis documentation website for details - https://eafriyie28.github.io/beamgis</p>"},{"location":"basemaps/","title":"basemaps module","text":"<p>Module for basemaps.</p> <p>Each basemap is defined as an item in the <code>basemaps</code> dictionary.</p> <p>For example, to access Google basemaps, users first need to get a Google Maps API key from https://bit.ly/3sw0THG.     Then, set the environment variable using geemap.set_api_key(). Then Google basemaps can be accessed using: <pre><code>* `basemaps['ROADMAP']`\n* `basemaps['SATELLITE']`\n* `basemaps['TERRAIN']`\n* `basemaps['HYBRID']`\n</code></pre> <p>More WMS basemaps can be found at the following websites:</p> <ol> <li>USGS National Map: https://viewer.nationalmap.gov/services/</li> <li>MRLC NLCD Land Cover data: https://viewer.nationalmap.gov/services/</li> <li>FWS NWI Wetlands data: https://www.fws.gov/wetlands/Data/Web-Map-Services.html</li> </ol>"},{"location":"basemaps/#beamgis.basemaps.get_xyz_dict","title":"<code>get_xyz_dict(free_only=True, france=False)</code>","text":"<p>Returns a dictionary of xyz services.</p> <p>Parameters:</p> Name Type Description Default <code>free_only</code> <code>bool</code> <p>Whether to return only free xyz tile services that do not require an access token. Defaults to True.</p> <code>True</code> <code>france</code> <code>bool</code> <p>Whether to include Geoportail France basemaps. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of xyz services.</p> Source code in <code>beamgis/basemaps.py</code> <pre><code>def get_xyz_dict(free_only=True, france=False):\n    \"\"\"Returns a dictionary of xyz services.\n\n    Args:\n        free_only (bool, optional): Whether to return only free xyz tile\n            services that do not require an access token. Defaults to True.\n        france (bool, optional): Whether to include Geoportail France basemaps.\n            Defaults to False.\n\n    Returns:\n        dict: A dictionary of xyz services.\n    \"\"\"\n    xyz_bunch = xyzservices.providers\n\n    if free_only:\n        xyz_bunch = xyz_bunch.filter(requires_token=False)\n    if not france:\n        xyz_bunch = xyz_bunch.filter(\n            function=lambda tile: \"france\" not in dict(tile)[\"name\"].lower()\n        )\n\n    xyz_dict = xyz_bunch.flatten()\n\n    for key, value in xyz_dict.items():\n        tile = xyzservices.TileProvider(value)\n        if \"type\" not in tile:\n            tile[\"type\"] = \"xyz\"\n        xyz_dict[key] = tile\n\n    xyz_dict = collections.OrderedDict(sorted(xyz_dict.items()))\n    return xyz_dict\n</code></pre>"},{"location":"basemaps/#beamgis.basemaps.qms_to_geemap","title":"<code>qms_to_geemap(service_id)</code>","text":"<p>Convert a qms service to an ipyleaflet tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>service_id</code> <code>str</code> <p>Service ID.</p> required <p>Returns:</p> Type Description <code>ipyleaflet.TileLayer</code> <p>An ipyleaflet tile layer.</p> Source code in <code>beamgis/basemaps.py</code> <pre><code>def qms_to_geemap(service_id):\n    \"\"\"Convert a qms service to an ipyleaflet tile layer.\n\n    Args:\n        service_id (str): Service ID.\n\n    Returns:\n        ipyleaflet.TileLayer: An ipyleaflet tile layer.\n    \"\"\"\n    service_details = get_qms(service_id)\n    name = service_details[\"name\"]\n    url = service_details[\"url\"]\n    attribution = service_details[\"copyright_text\"]\n\n    layer = ipyleaflet.TileLayer(url=url, name=name, attribution=attribution)\n    return layer\n</code></pre>"},{"location":"basemaps/#beamgis.basemaps.search_qms","title":"<code>search_qms(keywords, limit=10, timeout=600)</code>","text":"<p>Search qms files for keywords. Reference: https://github.com/geopandas/xyzservices/issues/65</p> <p>Parameters:</p> Name Type Description Default <code>keywords</code> <code>str</code> <p>Keywords to search for.</p> required <code>limit</code> <code>int</code> <p>Number of results to return.</p> <code>10</code> Source code in <code>beamgis/basemaps.py</code> <pre><code>def search_qms(keywords, limit=10, timeout=600):\n    \"\"\"Search qms files for keywords. Reference: https://github.com/geopandas/xyzservices/issues/65\n\n    Args:\n        keywords (str): Keywords to search for.\n        limit (int): Number of results to return.\n\n    \"\"\"\n    QMS_API = \"https://qms.nextgis.com/api/v1/geoservices\"\n\n    services = requests.get(\n        f\"{QMS_API}/?search={keywords}&amp;type=tms&amp;epsg=3857&amp;limit={str(limit)}\",\n        timeout=timeout,\n    )\n    services = services.json()\n    if services[\"count\"] == 0:\n        return None\n    elif services[\"count\"] &lt;= limit:\n        return services[\"results\"]\n    else:\n        return services[\"results\"][:limit]\n</code></pre>"},{"location":"basemaps/#beamgis.basemaps.xyz_to_bokeh","title":"<code>xyz_to_bokeh()</code>","text":"<p>Convert xyz tile services to bokeh tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of bokeh tile layers.</p> Source code in <code>beamgis/basemaps.py</code> <pre><code>def xyz_to_bokeh():\n    \"\"\"Convert xyz tile services to bokeh tile layers.\n\n    Returns:\n        dict: A dictionary of bokeh tile layers.\n    \"\"\"\n    from bokeh.models import WMTSTileSource  # type: ignore\n\n    bokeh_dict = {}\n\n    for key in XYZ_TILES:\n        url = XYZ_TILES[key][\"url\"]\n        attribution = XYZ_TILES[key][\"attribution\"]\n        tile_options = {\n            \"url\": url,\n            \"attribution\": attribution,\n        }\n        bokeh_dict[key] = WMTSTileSource(**tile_options)\n\n    xyz_dict = get_xyz_dict()\n    for item in xyz_dict:\n        url = xyz_dict[item].build_url()\n        attribution = xyz_dict[item].attribution\n        key = xyz_dict[item].name\n        tile_options = {\n            \"url\": url,\n            \"attribution\": attribution,\n        }\n        bokeh_dict[key] = WMTSTileSource(**tile_options)\n\n    return bokeh_dict\n</code></pre>"},{"location":"basemaps/#beamgis.basemaps.xyz_to_folium","title":"<code>xyz_to_folium()</code>","text":"<p>Convert xyz tile services to folium tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of folium tile layers.</p> Source code in <code>beamgis/basemaps.py</code> <pre><code>def xyz_to_folium():\n    \"\"\"Convert xyz tile services to folium tile layers.\n\n    Returns:\n        dict: A dictionary of folium tile layers.\n    \"\"\"\n    folium_dict = {}\n    # Ignore Esri basemaps if they are already in the custom XYZ_TILES.\n    ignore_list = [XYZ_TILES[tile][\"name\"] for tile in XYZ_TILES]\n\n    for key, tile in custom_tiles[\"xyz\"].items():\n        folium_dict[key] = folium.TileLayer(\n            tiles=tile[\"url\"],\n            attr=tile[\"attribution\"],\n            name=tile[\"name\"],\n            overlay=True,\n            control=True,\n            max_zoom=22,\n        )\n\n    for key, tile in custom_tiles[\"wms\"].items():\n        folium_dict[key] = folium.WmsTileLayer(\n            url=tile[\"url\"],\n            layers=tile[\"layers\"],\n            name=tile[\"name\"],\n            attr=tile[\"attribution\"],\n            fmt=tile[\"format\"],\n            transparent=tile[\"transparent\"],\n            overlay=True,\n            control=True,\n        )\n\n    for item in get_xyz_dict().values():\n        if item[\"name\"] in ignore_list:\n            continue\n        folium_dict[item.name] = folium.TileLayer(\n            tiles=item.build_url(),\n            attr=item.attribution,\n            name=item.name,\n            max_zoom=item.get(\"max_zoom\", 22),\n            overlay=True,\n            control=True,\n        )\n\n    if os.environ.get(\"PLANET_API_KEY\") is not None:\n        planet_dict = planet_tiles(tile_format=\"folium\")\n        folium_dict.update(planet_dict)\n\n    return folium_dict\n</code></pre>"},{"location":"basemaps/#beamgis.basemaps.xyz_to_leaflet","title":"<code>xyz_to_leaflet()</code>","text":"<p>Convert xyz tile services to ipyleaflet tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of ipyleaflet tile layers.</p> Source code in <code>beamgis/basemaps.py</code> <pre><code>def xyz_to_leaflet():\n    \"\"\"Convert xyz tile services to ipyleaflet tile layers.\n\n    Returns:\n        dict: A dictionary of ipyleaflet tile layers.\n    \"\"\"\n    leaflet_dict = {}\n    # Ignore Esri basemaps if they are already in the custom XYZ_TILES.\n    ignore_list = [XYZ_TILES[tile][\"name\"] for tile in XYZ_TILES]\n\n    # Add custom tiles.\n    for tile_type, tile_dict in custom_tiles.items():\n        for _, tile_info in tile_dict.items():\n            tile_info[\"type\"] = tile_type\n            leaflet_dict[tile_info[\"name\"]] = tile_info\n\n    # Add xyzservices.provider tiles.\n    for _, tile_info in get_xyz_dict().items():\n        if tile_info[\"name\"] in ignore_list:\n            continue\n        tile_info[\"url\"] = tile_info.build_url()\n        leaflet_dict[tile_info[\"name\"]] = tile_info\n\n    return leaflet_dict\n</code></pre>"},{"location":"basemaps/#beamgis.basemaps.xyz_to_plotly","title":"<code>xyz_to_plotly()</code>","text":"<p>Convert xyz tile services to plotly tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of plotly tile layers.</p> Source code in <code>beamgis/basemaps.py</code> <pre><code>def xyz_to_plotly():\n    \"\"\"Convert xyz tile services to plotly tile layers.\n\n    Returns:\n        dict: A dictionary of plotly tile layers.\n    \"\"\"\n    plotly_dict = {}\n    # Ignore Esri basemaps if they are already in the custom XYZ_TILES.\n    ignore_list = [XYZ_TILES[tile][\"name\"] for tile in XYZ_TILES]\n\n    for key, tile in custom_tiles[\"xyz\"].items():\n        plotly_dict[key] = {\n            \"below\": \"traces\",\n            \"sourcetype\": \"raster\",\n            \"sourceattribution\": tile[\"attribution\"],\n            \"source\": [tile[\"url\"]],\n            \"name\": key,\n        }\n\n    for item in get_xyz_dict().values():\n        if item[\"name\"] in ignore_list:\n            continue\n        plotly_dict[item.name] = {\n            \"below\": \"traces\",\n            \"sourcetype\": \"raster\",\n            \"sourceattribution\": item.attribution,\n            \"source\": [item.build_url()],\n            \"name\": item.name,\n        }\n\n    return plotly_dict\n</code></pre>"},{"location":"basemaps/#beamgis.basemaps.xyz_to_pydeck","title":"<code>xyz_to_pydeck()</code>","text":"<p>Convert xyz tile services to pydeck custom tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of pydeck tile layers.</p> Source code in <code>beamgis/basemaps.py</code> <pre><code>def xyz_to_pydeck():\n    \"\"\"Convert xyz tile services to pydeck custom tile layers.\n\n    Returns:\n        dict: A dictionary of pydeck tile layers.\n    \"\"\"\n\n    check_package(\"pydeck\", \"https://deckgl.readthedocs.io/en/latest/installation.html\")\n    import pydeck as pdk  # type: ignore\n\n    pydeck_dict = {}\n    # Ignore Esri basemaps if they are already in the custom XYZ_TILES.\n    ignore_list = [XYZ_TILES[tile][\"name\"] for tile in XYZ_TILES]\n\n    for key, tile in custom_tiles[\"xyz\"].items():\n        url = tile[\"url\"]\n        pydeck_dict[key] = url\n\n    for key, item in get_xyz_dict().items():\n        if item[\"name\"] in ignore_list:\n            continue\n        url = item.build_url()\n        pydeck_dict[key] = url\n\n        if os.environ.get(\"PLANET_API_KEY\") is not None:\n            planet_dict = planet_tiles(tile_format=\"ipyleaflet\")\n            for id_, tile in planet_dict.items():\n                pydeck_dict[id_] = tile.url\n\n    pdk.settings.custom_libraries = [\n        {\n            \"libraryName\": \"MyTileLayerLibrary\",\n            \"resourceUri\": \"https://cdn.jsdelivr.net/gh/giswqs/pydeck_myTileLayer@master/dist/bundle.js\",\n        }\n    ]\n\n    for key in pydeck_dict:\n        pydeck_dict[key] = pdk.Layer(\"MyTileLayer\", pydeck_dict[key], key)\n\n    return pydeck_dict\n</code></pre>"},{"location":"beamgis/","title":"beamgis module","text":"<p>Main module.</p>"},{"location":"beamgis/#beamgis.beamgis.Map","title":"<code> Map            (Map)         </code>","text":"Source code in <code>beamgis/beamgis.py</code> <pre><code>class Map(ipyleaflet.Map):\n    def __init__(self, center=[20, 0], zoom=2, height=\"600px\", **kwargs):\n\n        super().__init__(center=center, zoom=zoom, **kwargs)\n        self.layout.height = height\n        self.scroll_wheel_zoom = True\n\n    def add_basemap(self, basemap=\"OpenTopoMap\"):\n        \"\"\"Add basemap to the map.\n\n        Args:\n            basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n        \"\"\"\n\n        url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n        layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(layer)\n\n    def add_basemap_gui(self, options=None, position=\"topright\"):\n        \"\"\"\n        Adds a graphical user interface (GUI) for selecting basemaps.\n\n        Args:\n            options (list, optional): A list of basemap options to display in the dropdown.\n                Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"CartoDB.DarkMatter\"].\n            position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n\n        Behavior:\n            - A toggle button is used to show or hide the dropdown and close button.\n            - The dropdown allows users to select a basemap from the provided options.\n            - The close button removes the widget from the map.\n        \"\"\"\n        if options is None:\n            options = [\n                \"OpenStreetMap.Mapnik\",\n                \"OpenTopoMap\",\n                \"Esri.WorldImagery\",\n                \"CartoDB.DarkMatter\",\n            ]\n\n        # --- Widgets setup ---\n        toggle = widgets.ToggleButton(\n            value=True,\n            button_style=\"\",\n            tooltip=\"Click me\",\n            icon=\"map\",\n        )\n\n        toggle.layout = widgets.Layout(width=\"45px\", height=\"45px\")\n        dropdown = widgets.Dropdown(\n            options=options,\n            value=options[0],\n            description=\"Basemap:\",\n            style={\"description_width\": \"initial\"},\n        )\n\n        dropdown.layout = widgets.Layout(width=\"250px\", height=\"40px\")\n        close_btn = widgets.Button(icon=\"times\")\n        close_btn.layout = widgets.Layout(width=\"40px\", height=\"40px\")\n\n        hbox = widgets.HBox([toggle, dropdown, close_btn])\n\n        # --- Toggle visibility ---\n        def on_toggle_change(change):\n            if change[\"new\"]:\n                hbox.children = [toggle, dropdown, close_btn]\n            else:\n                hbox.children = [toggle]\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        # --- Close the control ---\n        def on_close_click(b):\n            hbox.close()\n            toggle.close()\n            dropdown.close()\n            close_btn.close()\n\n        close_btn.on_click(on_close_click)\n\n        def on_dropdown_change(change):\n            \"\"\"\n            Adds a new basemap layer to the map when a new option is selected.\n\n            Args:\n                change (dict): The change event containing the new value of the dropdown.\n            \"\"\"\n            if change[\"new\"]:\n                url = eval(f\"ipyleaflet.basemaps.{change['new']}\").build_url()\n                new_tile_layer = ipyleaflet.TileLayer(url=url, name=change[\"new\"])\n                self.add_layer(new_tile_layer)\n\n        dropdown.observe(on_dropdown_change, names=\"value\")\n\n        control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n        self.add_control(control)\n\n    def add_heatmap_gui(\n        self,\n        position=\"bottomright\",\n        latitude=None,\n        longitude=None,\n        value=None,\n        radius=25,\n    ):\n        \"\"\"\n        Adds an inline GUI to the map for generating a heatmap from a CSV URL.\n        Positioned in the bottom right with a clean, modern design.\n        Output is cleared before each operation.\n        \"\"\"\n        import pandas as pd\n\n        # --- Core UI Components ---\n        toggle = ToggleButton(\n            value=True,\n            tooltip=\"Show/hide heatmap panel\",\n            icon=\"fire\",\n            layout=Layout(width=\"45px\", height=\"45px\"),\n            button_style=\"info\",\n        )\n\n        url_text = Text(\n            placeholder=\"Paste CSV URL here...\",\n            layout=Layout(width=\"300px\", margin=\"0 5px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        lat_dd = Dropdown(\n            description=\"Latitude:\",\n            layout=Layout(width=\"150px\", margin=\"0 5px\"),\n            style={\"description_width\": \"60px\"},\n        )\n        lon_dd = Dropdown(\n            description=\"Longitude:\",\n            layout=Layout(width=\"150px\", margin=\"0 5px\"),\n            style={\"description_width\": \"70px\"},\n        )\n        val_dd = Dropdown(\n            description=\"Value:\",\n            layout=Layout(width=\"150px\", margin=\"0 5px\"),\n            style={\"description_width\": \"50px\"},\n        )\n\n        radius_slider = IntSlider(\n            value=radius,\n            min=1,\n            max=50,\n            step=1,\n            description=\"Radius:\",\n            continuous_update=False,\n            layout=Layout(width=\"180px\", margin=\"0 5px\"),\n            style={\"description_width\": \"50px\"},\n        )\n\n        load_button = Button(\n            description=\"Load CSV\",\n            icon=\"download\",\n            button_style=\"info\",\n            layout=Layout(width=\"100px\", margin=\"0 5px\"),\n        )\n        heatmap_button = Button(\n            description=\"Add Heatmap\",\n            icon=\"plus\",\n            button_style=\"success\",\n            layout=Layout(width=\"120px\", margin=\"0 5px\"),\n        )\n        close_button = Button(\n            icon=\"times\",\n            layout=Layout(width=\"40px\", margin=\"0 5px\"),\n            button_style=\"danger\",\n        )\n\n        # --- Output widget for messages ---\n        output = Output(\n            layout=Layout(\n                border=\"1px solid #e0e0e0\",\n                padding=\"10px\",\n                max_height=\"150px\",\n                overflow=\"auto\",\n                margin=\"5px 0\",\n                background_color=\"#f9f9f9\",\n            )\n        )\n\n        # Header with title and close button\n        header = HBox(\n            [\n                HTML(\"&lt;h4 style='margin: 0; padding: 0;'&gt;Heatmap Generator&lt;/h4&gt;\"),\n                close_button,\n            ],\n            layout=Layout(\n                justify_content=\"space-between\",\n                width=\"100%\",\n                padding=\"5px 10px\",\n                background_color=\"#4CAF50\",\n                border_radius=\"5px 5px 0 0\",\n            ),\n        )\n\n        # --- Layout ---\n        controls = VBox(\n            [\n                HBox([url_text, load_button]),\n                HBox([lat_dd, lon_dd, val_dd]),\n                HBox([radius_slider, heatmap_button]),\n            ],\n            layout=Layout(padding=\"10px\", align_items=\"center\", width=\"100%\"),\n        )\n\n        # Main panel with header, controls and output\n        panel = VBox(\n            [header, controls, output],\n            layout=Layout(\n                background_color=\"white\",\n                border=\"1px solid #e0e0e0\",\n                border_radius=\"5px\",\n                box_shadow=\"0 2px 5px rgba(0,0,0,0.1)\",\n                width=\"auto\",\n                max_width=\"800px\",\n            ),\n        )\n\n        # Collapsible container\n        collapsible = VBox([toggle, panel])\n\n        # --- Behavior Handlers ---\n        def on_toggle_change(change):\n            collapsible.children = [toggle, panel] if change[\"new\"] else [toggle]\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        def on_close_click(_):\n            collapsible.close()\n\n        close_button.on_click(on_close_click)\n\n        def on_load_click(_):\n            with output:\n                clear_output()\n                try:\n                    df = pd.read_csv(url_text.value)\n                    opts = df.columns.tolist()\n                    lat_dd.options = opts\n                    lon_dd.options = opts\n                    val_dd.options = opts\n                    # Preselect if defaults provided\n                    if latitude in opts:\n                        lat_dd.value = latitude\n                    if longitude in opts:\n                        lon_dd.value = longitude\n                    if value in opts:\n                        val_dd.value = value\n                    panel.df = df\n                    print(f\"\u2705 Loaded {len(df)} rows\")\n                    print(f\"\ud83d\udcca Columns: {', '.join(opts)}\")\n                except Exception as e:\n                    print(\"\u274c Error loading CSV:\", e)\n\n        load_button.on_click(on_load_click)\n\n        def on_add_click(_):\n            with output:\n                clear_output()\n                try:\n                    df = panel.df\n                    lat, lon, val = lat_dd.value, lon_dd.value, val_dd.value\n                    data = df[[lat, lon, val]].values.tolist()\n                    hm = Heatmap(\n                        locations=data, radius=radius_slider.value, name=\"Heat map\"\n                    )\n                    self.add(hm)\n                    print(\"\ud83c\udf0b Heatmap successfully added!\")\n                    print(f\"\ud83d\udccd Points: {len(data)}\")\n                    print(f\"\ud83d\udd18 Radius: {radius_slider.value}\")\n                except Exception as e:\n                    print(\"\u274c Error adding heatmap:\", e)\n\n        heatmap_button.on_click(on_add_click)\n\n        heatmap_button.on_click(on_add_click)\n\n        # Finally, add to the map\n        self.add(WidgetControl(widget=collapsible, position=position))\n\n    # def add_heatmap_gui(\n    #     self, position=\"topright\", latitude=None, longitude=None, value=None, radius=25\n    # ):\n    #     \"\"\"\n    #     Adds an inline GUI to the map for generating a heatmap from a CSV URL.\n    #     Now laid out horizontally on a light-green background,\n    #     with a dedicated Output pane that is cleared on each run.\n    #     \"\"\"\n    #     import pandas as pd\n\n    #     # --- Core UI Components ---\n    #     toggle = ToggleButton(\n    #         value=True, tooltip=\"Show/hide heatmap panel\", icon=\"fire\",\n    #         layout=Layout(width=\"45px\", height=\"45px\")\n    #     )\n\n    #     url_text = Text(\n    #         placeholder=\"Paste CSV URL\", description=\"CSV URL:\",\n    #         layout=Layout(width=\"300px\"), style={\"description_width\": \"initial\"}\n    #     )\n\n    #     lat_dd = Dropdown(description=\"Lat\", layout=Layout(width=\"120px\"))\n    #     lon_dd = Dropdown(description=\"Lon\", layout=Layout(width=\"120px\"))\n    #     val_dd = Dropdown(description=\"Value\", layout=Layout(width=\"120px\"))\n\n    #     radius_slider = IntSlider(\n    #         value=radius, min=1, max=50, step=1, description=\"Radius:\",\n    #         continuous_update=False, layout=Layout(width=\"200px\")\n    #     )\n\n    #     load_button = Button(description=\"Load CSV\", icon=\"download\", button_style=\"info\")\n    #     heatmap_button = Button(description=\"Add Heatmap\", icon=\"plus\", button_style=\"success\")\n    #     close_button = Button(icon=\"times\", layout=Layout(width=\"40px\"))\n\n    #     # --- Output widget for messages ---\n    #     output = Output(layout=Layout(border=\"1px solid #ccc\", padding=\"5px\", max_height=\"150px\", overflow=\"auto\"))\n\n    #     # --- Layout in a single horizontal box ---\n    #     controls = HBox(\n    #         [\n    #             url_text, load_button,\n    #             lat_dd, lon_dd, val_dd,\n    #             radius_slider, heatmap_button,\n    #             close_button\n    #         ],\n    #         layout=Layout(\n    #             background_color=\"lightgreen\",\n    #             padding=\"10px\",\n    #             align_items=\"center\",\n    #             flex_flow=\"row wrap\",\n    #             width=\"100%\"\n    #         )\n    #     )\n\n    #     # Stack the toggle, controls row, and output pane\n    #     panel = VBox([toggle, controls, output])\n\n    #     # --- Behavior Handlers ---\n    #     def on_toggle_change(change):\n    #         if change[\"new\"]:\n    #             panel.children = [toggle, controls, output]\n    #         else:\n    #             panel.children = [toggle]\n\n    #     toggle.observe(on_toggle_change, names=\"value\")\n\n    #     def on_close_click(_):\n    #         panel.close()\n\n    #     close_button.on_click(on_close_click)\n\n    #     def on_load_click(_):\n    #         with output:\n    #             clear_output()\n    #             try:\n    #                 df = pd.read_csv(url_text.value)\n    #                 opts = df.columns.tolist()\n    #                 lat_dd.options = opts\n    #                 lon_dd.options = opts\n    #                 val_dd.options = opts\n    #                 # Preselect if defaults provided\n    #                 if latitude in opts:\n    #                     lat_dd.value = latitude\n    #                 if longitude in opts:\n    #                     lon_dd.value = longitude\n    #                 if value in opts:\n    #                     val_dd.value = value\n    #                 panel.df = df\n    #                 print(f\"Loaded {len(df)} rows, columns: {opts}\")\n    #             except Exception as e:\n    #                 print(\"\u274c Error loading CSV:\", e)\n\n    #     load_button.on_click(on_load_click)\n\n    #     def on_add_click(_):\n    #         with output:\n    #             clear_output()\n    #             try:\n    #                 df = panel.df\n    #                 lat, lon, val = lat_dd.value, lon_dd.value, val_dd.value\n    #                 data = df[[lat, lon, val]].values.tolist()\n    #                 hm = Heatmap(locations=data, radius=radius_slider.value, name=\"Heat map\")\n    #                 self.add(hm)\n    #                 print(\"\ud83d\udc4d Heatmap added\")\n    #             except Exception as e:\n    #                 print(\"\u274c Error adding heatmap:\", e)\n\n    #     heatmap_button.on_click(on_add_click)\n\n    #     # Finally, add to the map\n    #     self.add(WidgetControl(widget=panel, position=position))\n\n    # def add_heatmap_gui(\n    #     self, position=\"topright\", latitude=None, longitude=None, value=None, radius=25\n    # ):\n    #     \"\"\"\n    #     Adds an inline GUI to the map for generating a heatmap from a CSV URL.\n\n    #     Args:\n    #         position (str): Position of the widget on the map. Defaults to \"topright\".\n    #         latitude (str, optional): The default latitude column name.\n    #         longitude (str, optional): The default longitude column name.\n    #         value (str, optional): The default value (intensity) column name.\n    #         radius (int, optional): Default radius of each point on the heatmap. Defaults to 25.\n    #     \"\"\"\n    #     import pandas as pd\n    #     from ipyleaflet import Heatmap\n\n    #     # --- Core UI Components ---\n    #     toggle = widgets.ToggleButton(\n    #         value=True,\n    #         tooltip=\"Show/hide heatmap panel\",\n    #         icon=\"fire\",\n    #         layout=widgets.Layout(width=\"45px\", height=\"45px\"),\n    #     )\n\n    #     url_text = widgets.Text(\n    #         placeholder=\"Paste CSV URL\",\n    #         description=\"CSV URL:\",\n    #         layout=widgets.Layout(width=\"350px\"),\n    #         style={\"description_width\": \"initial\"},\n    #     )\n\n    #     lat_dd = widgets.Dropdown(\n    #         description=\"Lat\", layout=widgets.Layout(width=\"200px\")\n    #     )\n    #     lon_dd = widgets.Dropdown(\n    #         description=\"Lon\", layout=widgets.Layout(width=\"200px\")\n    #     )\n    #     val_dd = widgets.Dropdown(\n    #         description=\"Value\", layout=widgets.Layout(width=\"200px\")\n    #     )\n\n    #     radius_slider = widgets.IntSlider(\n    #         value=radius,\n    #         min=1,\n    #         max=50,\n    #         step=1,\n    #         description=\"Radius:\",\n    #         continuous_update=False,\n    #         layout=widgets.Layout(width=\"250px\"),\n    #     )\n\n    #     load_button = widgets.Button(\n    #         description=\"Load CSV\", icon=\"download\", button_style=\"info\"\n    #     )\n    #     heatmap_button = widgets.Button(\n    #         description=\"Add Heatmap\", icon=\"plus\", button_style=\"success\"\n    #     )\n    #     close_button = widgets.Button(icon=\"times\", layout=widgets.Layout(width=\"40px\"))\n\n    #     # --- Layout Containers ---\n    #     controls_box = widgets.VBox(\n    #         [\n    #             url_text,\n    #             load_button,\n    #             widgets.HBox([lat_dd, lon_dd, val_dd]),\n    #             radius_slider,\n    #             heatmap_button,\n    #         ]\n    #     )\n\n    #     hbox = widgets.VBox([toggle, controls_box, close_button])\n\n    #     # --- Behavior Handlers ---\n    #     def on_toggle_change(change):\n    #         hbox.children = (\n    #             [toggle, controls_box, close_button] if change[\"new\"] else [toggle]\n    #         )\n\n    #     toggle.observe(on_toggle_change, names=\"value\")\n\n    #     def on_close_click(b):\n    #         hbox.close()\n\n    #     close_button.on_click(on_close_click)\n\n    #     def on_load_click(b):\n    #         try:\n    #             df = pd.read_csv(url_text.value)\n    #             options = df.columns.tolist()\n    #             lat_dd.options = options\n    #             lon_dd.options = options\n    #             val_dd.options = options\n\n    #             # Preselect columns if provided\n    #             if latitude in options:\n    #                 lat_dd.value = latitude\n    #             if longitude in options:\n    #                 lon_dd.value = longitude\n    #             if value in options:\n    #                 val_dd.value = value\n\n    #             hbox.df = df  # attach df to widget\n    #         except Exception as e:\n    #             print(f\"Error loading CSV: {e}\")\n\n    #     load_button.on_click(on_load_click)\n\n    #     def on_add_click(b):\n    #         try:\n    #             df = hbox.df\n    #             lat, lon, val = lat_dd.value, lon_dd.value, val_dd.value\n    #             data = df[[lat, lon, val]].values.tolist()\n    #             heatmap = Heatmap(\n    #                 locations=data, radius=radius_slider.value, name=\"Heat map\"\n    #             )\n    #             self.add(heatmap)\n    #         except Exception as e:\n    #             print(f\"Error adding heatmap: {e}\")\n\n    #     heatmap_button.on_click(on_add_click)\n\n    #     control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n    #     self.add(control)\n\n    def add_google_map(self, map_type=\"ROADMAP\"):\n        \"\"\"Add Google Map to the map.\n\n        Args:\n            map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n        \"\"\"\n        map_types = {\n            \"ROADMAP\": \"m\",\n            \"SATELLITE\": \"s\",\n            \"HYBRID\": \"y\",\n            \"TERRAIN\": \"p\",\n        }\n        map_type = map_types[map_type.upper()]\n\n        url = (\n            f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n        )\n        layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n        self.add(layer)\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features.\n            Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n        layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n        self.add_layer(layer)\n\n        if zoom_to_layer:\n            bounds = gdf.total_bounds\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        control = ipyleaflet.LayersControl(position=\"topright\")\n        self.add_control(control)\n\n    def add_raster(self, url, name=\"Raster\", colormap=None, opacity=None, **kwargs):\n        \"\"\"Adds a raster layer to the map.\n\n        Args:\n            url (str): The file path or URL to the raster data.\n            name (str, optional): The name of the layer. Defaults to \"Raster\".\n            colormap (str, optional): The colormap to apply. Defaults to None.\n            opacity (float, optional): The opacity of the layer. Defaults to None.\n            **kwargs: Additional keyword arguments for the tile layer.\n        \"\"\"\n        from localtileserver import TileClient, get_leaflet_tile_layer\n\n        client = TileClient(url)\n        tile_layer = get_leaflet_tile_layer(\n            client, name=name, colormap=colormap, opacity=opacity, **kwargs\n        )\n\n        self.add(tile_layer)\n        self.center = client.center()\n        self.zoom = client.default_zoom\n\n    def add_image(self, image, bounds=None, **kwargs):\n        \"\"\"Adds an image to the map.\n\n        Args:\n            image (str): The file path to the image.\n            bounds (list, optional): The bounds for the image. Defaults to None.\n            **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n        \"\"\"\n\n        if bounds is None:\n            bounds = [[-90, -180], [90, 180]]\n        overlay = ipyleaflet.ImageOverlay(url=image, bounds=bounds, **kwargs)\n        self.add(overlay)\n\n    def add_video(self, video, bounds=None, opacity=1.0, **kwargs):\n        \"\"\"Adds a video to the map.\n\n        Args:\n            video (str): The file path to the video.\n            bounds (list, optional): The bounds for the video. Defaults to None.\n            **kwargs: Additional keyword arguments for the ipyleaflet.VideoOverlay layer.\n        \"\"\"\n\n        if bounds is None or not bounds:\n            raise ValueError(\"Bounds must be specified for the video overlay.\")\n        overlay = ipyleaflet.VideoOverlay(\n            url=video, bounds=bounds, opacity=opacity, **kwargs\n        )\n        self.add(overlay)\n\n    def add_wms_layer(\n        self, url, layers, name, format=\"image/png\", transparent=True, **kwargs\n    ):\n        \"\"\"Adds a WMS layer to the map.\n\n        Args:\n            url (str): The WMS service URL.\n            layers (str): The layers to display.\n            **kwargs: Additional keyword arguments for the ipyleaflet.WMSLayer layer.\n        \"\"\"\n        layer = ipyleaflet.WMSLayer(\n            url=url,\n            layers=layers,\n            name=name,\n            format=format,\n            transparent=transparent,\n            **kwargs,\n        )\n        self.add(layer)\n\n    def add_search_control(\n        self,\n        url: str,\n        marker: Optional[ipyleaflet.Marker] = None,\n        zoom: Optional[int] = None,\n        position: Optional[str] = \"topleft\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Adds a search control to the map.\n\n        Args:\n            url (str): The url to the search API. For example, \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\".\n            marker (ipyleaflet.Marker, optional): The marker to be used for the search result. Defaults to None.\n            zoom (int, optional): The zoom level to be used for the search result. Defaults to None.\n            position (str, optional): The position of the search control. Defaults to \"topleft\".\n            kwargs (dict, optional): Additional keyword arguments to be passed to the search control. See https://ipyleaflet.readthedocs.io/en/latest/api_reference/search_control.html\n        \"\"\"\n        if marker is None:\n            marker = ipyleaflet.Marker(\n                icon=ipyleaflet.AwesomeIcon(\n                    name=\"check\", marker_color=\"green\", icon_color=\"darkred\"\n                )\n            )\n        search_control = ipyleaflet.SearchControl(\n            position=position,\n            url=url,\n            zoom=zoom,\n            marker=marker,\n            **kwargs,\n        )\n        self.add(search_control)\n        self.search_control = search_control\n\n    def add_time_slider(\n        self,\n        layers: dict = {},\n        labels: list = None,\n        time_interval: int = 1,\n        position: str = \"bottomright\",\n        slider_length: str = \"150px\",\n        zoom_to_layer: Optional[bool] = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Adds a time slider to the map.\n\n        Args:\n            layers (dict, optional): The dictionary containing a set of XYZ tile layers.\n            labels (list, optional): The list of labels to be used for the time series. Defaults to None.\n            time_interval (int, optional): Time interval in seconds. Defaults to 1.\n            position (str, optional): Position to place the time slider, can be any of ['topleft', 'topright', 'bottomleft', 'bottomright']. Defaults to \"bottomright\".\n            slider_length (str, optional): Length of the time slider. Defaults to \"150px\".\n            zoom_to_layer (bool, optional): Whether to zoom to the extent of the selected layer. Defaults to False.\n\n        \"\"\"\n        from .toolbar import time_slider\n\n        time_slider(\n            self,\n            layers,\n            labels,\n            time_interval,\n            position,\n            slider_length,\n            zoom_to_layer,\n            **kwargs,\n        )\n\n    def add_heatmap(\n        self,\n        data: Union[str, list, pd.DataFrame],\n        latitude: Optional[str] = \"latitude\",\n        longitude: Optional[str] = \"longitude\",\n        value: Optional[str] = \"value\",\n        name: Optional[str] = \"Heat map\",\n        radius: Optional[int] = 25,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Adds a heat map to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/heatmap.html\n\n        Args:\n            data (str | list | pd.DataFrame): File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\n            latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n            longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n            value (str, optional): The column name of values. Defaults to \"value\".\n            name (str, optional): Layer name to use. Defaults to \"Heat map\".\n            radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n\n        Raises:\n            ValueError: If data is not a list.\n        \"\"\"\n        import pandas as pd\n        from ipyleaflet import Heatmap\n\n        try:\n            if isinstance(data, str):\n                df = pd.read_csv(data)\n                data = df[[latitude, longitude, value]].values.tolist()\n            elif isinstance(data, pd.DataFrame):\n                data = data[[latitude, longitude, value]].values.tolist()\n            elif isinstance(data, list):\n                pass\n            else:\n                raise ValueError(\"data must be a list, a DataFrame, or a file path.\")\n\n            heatmap = Heatmap(locations=data, radius=radius, name=name, **kwargs)\n            self.add(heatmap)\n\n        except Exception as e:\n            raise Exception(e)\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.Map.add_basemap","title":"<code>add_basemap(self, basemap='OpenTopoMap')</code>","text":"<p>Add basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Defaults to \"OpenTopoMap\".</p> <code>'OpenTopoMap'</code> Source code in <code>beamgis/beamgis.py</code> <pre><code>def add_basemap(self, basemap=\"OpenTopoMap\"):\n    \"\"\"Add basemap to the map.\n\n    Args:\n        basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n    \"\"\"\n\n    url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n    layer = ipyleaflet.TileLayer(url=url, name=basemap)\n    self.add(layer)\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.Map.add_basemap_gui","title":"<code>add_basemap_gui(self, options=None, position='topright')</code>","text":"<p>Adds a graphical user interface (GUI) for selecting basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>list</code> <p>A list of basemap options to display in the dropdown. Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"CartoDB.DarkMatter\"].</p> <code>None</code> <code>position</code> <code>str</code> <p>The position of the widget on the map. Defaults to \"topright\".</p> <code>'topright'</code> <p>Behavior</p> <ul> <li>A toggle button is used to show or hide the dropdown and close button.</li> <li>The dropdown allows users to select a basemap from the provided options.</li> <li>The close button removes the widget from the map.</li> </ul> Source code in <code>beamgis/beamgis.py</code> <pre><code>def add_basemap_gui(self, options=None, position=\"topright\"):\n    \"\"\"\n    Adds a graphical user interface (GUI) for selecting basemaps.\n\n    Args:\n        options (list, optional): A list of basemap options to display in the dropdown.\n            Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"CartoDB.DarkMatter\"].\n        position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n\n    Behavior:\n        - A toggle button is used to show or hide the dropdown and close button.\n        - The dropdown allows users to select a basemap from the provided options.\n        - The close button removes the widget from the map.\n    \"\"\"\n    if options is None:\n        options = [\n            \"OpenStreetMap.Mapnik\",\n            \"OpenTopoMap\",\n            \"Esri.WorldImagery\",\n            \"CartoDB.DarkMatter\",\n        ]\n\n    # --- Widgets setup ---\n    toggle = widgets.ToggleButton(\n        value=True,\n        button_style=\"\",\n        tooltip=\"Click me\",\n        icon=\"map\",\n    )\n\n    toggle.layout = widgets.Layout(width=\"45px\", height=\"45px\")\n    dropdown = widgets.Dropdown(\n        options=options,\n        value=options[0],\n        description=\"Basemap:\",\n        style={\"description_width\": \"initial\"},\n    )\n\n    dropdown.layout = widgets.Layout(width=\"250px\", height=\"40px\")\n    close_btn = widgets.Button(icon=\"times\")\n    close_btn.layout = widgets.Layout(width=\"40px\", height=\"40px\")\n\n    hbox = widgets.HBox([toggle, dropdown, close_btn])\n\n    # --- Toggle visibility ---\n    def on_toggle_change(change):\n        if change[\"new\"]:\n            hbox.children = [toggle, dropdown, close_btn]\n        else:\n            hbox.children = [toggle]\n\n    toggle.observe(on_toggle_change, names=\"value\")\n\n    # --- Close the control ---\n    def on_close_click(b):\n        hbox.close()\n        toggle.close()\n        dropdown.close()\n        close_btn.close()\n\n    close_btn.on_click(on_close_click)\n\n    def on_dropdown_change(change):\n        \"\"\"\n        Adds a new basemap layer to the map when a new option is selected.\n\n        Args:\n            change (dict): The change event containing the new value of the dropdown.\n        \"\"\"\n        if change[\"new\"]:\n            url = eval(f\"ipyleaflet.basemaps.{change['new']}\").build_url()\n            new_tile_layer = ipyleaflet.TileLayer(url=url, name=change[\"new\"])\n            self.add_layer(new_tile_layer)\n\n    dropdown.observe(on_dropdown_change, names=\"value\")\n\n    control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n    self.add_control(control)\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>beamgis/beamgis.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.Map.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features.</p> <code>None</code> <code>Defaults</code> <code>to {\"color\"</code> <p>\"yellow\", \"fillOpacity\": 0.2}.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>beamgis/beamgis.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features.\n        Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n    layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n    self.add_layer(layer)\n\n    if zoom_to_layer:\n        bounds = gdf.total_bounds\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.Map.add_google_map","title":"<code>add_google_map(self, map_type='ROADMAP')</code>","text":"<p>Add Google Map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>map_type</code> <code>str</code> <p>Map type. Defaults to \"ROADMAP\".</p> <code>'ROADMAP'</code> Source code in <code>beamgis/beamgis.py</code> <pre><code>def add_google_map(self, map_type=\"ROADMAP\"):\n    \"\"\"Add Google Map to the map.\n\n    Args:\n        map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n    \"\"\"\n    map_types = {\n        \"ROADMAP\": \"m\",\n        \"SATELLITE\": \"s\",\n        \"HYBRID\": \"y\",\n        \"TERRAIN\": \"p\",\n    }\n    map_type = map_types[map_type.upper()]\n\n    url = (\n        f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n    )\n    layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n    self.add(layer)\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.Map.add_heatmap","title":"<code>add_heatmap(self, data, latitude='latitude', longitude='longitude', value='value', name='Heat map', radius=25, **kwargs)</code>","text":"<p>Adds a heat map to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/heatmap.html</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | list | pd.DataFrame</code> <p>File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv</p> required <code>latitude</code> <code>str</code> <p>The column name of latitude. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The column name of longitude. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>value</code> <code>str</code> <p>The column name of values. Defaults to \"value\".</p> <code>'value'</code> <code>name</code> <code>str</code> <p>Layer name to use. Defaults to \"Heat map\".</p> <code>'Heat map'</code> <code>radius</code> <code>int</code> <p>Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.</p> <code>25</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If data is not a list.</p> Source code in <code>beamgis/beamgis.py</code> <pre><code>def add_heatmap(\n    self,\n    data: Union[str, list, pd.DataFrame],\n    latitude: Optional[str] = \"latitude\",\n    longitude: Optional[str] = \"longitude\",\n    value: Optional[str] = \"value\",\n    name: Optional[str] = \"Heat map\",\n    radius: Optional[int] = 25,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Adds a heat map to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/heatmap.html\n\n    Args:\n        data (str | list | pd.DataFrame): File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\n        latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n        longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n        value (str, optional): The column name of values. Defaults to \"value\".\n        name (str, optional): Layer name to use. Defaults to \"Heat map\".\n        radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n\n    Raises:\n        ValueError: If data is not a list.\n    \"\"\"\n    import pandas as pd\n    from ipyleaflet import Heatmap\n\n    try:\n        if isinstance(data, str):\n            df = pd.read_csv(data)\n            data = df[[latitude, longitude, value]].values.tolist()\n        elif isinstance(data, pd.DataFrame):\n            data = data[[latitude, longitude, value]].values.tolist()\n        elif isinstance(data, list):\n            pass\n        else:\n            raise ValueError(\"data must be a list, a DataFrame, or a file path.\")\n\n        heatmap = Heatmap(locations=data, radius=radius, name=name, **kwargs)\n        self.add(heatmap)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.Map.add_heatmap_gui","title":"<code>add_heatmap_gui(self, position='bottomright', latitude=None, longitude=None, value=None, radius=25)</code>","text":"<p>Adds an inline GUI to the map for generating a heatmap from a CSV URL. Positioned in the bottom right with a clean, modern design. Output is cleared before each operation.</p> Source code in <code>beamgis/beamgis.py</code> <pre><code>def add_heatmap_gui(\n    self,\n    position=\"bottomright\",\n    latitude=None,\n    longitude=None,\n    value=None,\n    radius=25,\n):\n    \"\"\"\n    Adds an inline GUI to the map for generating a heatmap from a CSV URL.\n    Positioned in the bottom right with a clean, modern design.\n    Output is cleared before each operation.\n    \"\"\"\n    import pandas as pd\n\n    # --- Core UI Components ---\n    toggle = ToggleButton(\n        value=True,\n        tooltip=\"Show/hide heatmap panel\",\n        icon=\"fire\",\n        layout=Layout(width=\"45px\", height=\"45px\"),\n        button_style=\"info\",\n    )\n\n    url_text = Text(\n        placeholder=\"Paste CSV URL here...\",\n        layout=Layout(width=\"300px\", margin=\"0 5px\"),\n        style={\"description_width\": \"initial\"},\n    )\n\n    lat_dd = Dropdown(\n        description=\"Latitude:\",\n        layout=Layout(width=\"150px\", margin=\"0 5px\"),\n        style={\"description_width\": \"60px\"},\n    )\n    lon_dd = Dropdown(\n        description=\"Longitude:\",\n        layout=Layout(width=\"150px\", margin=\"0 5px\"),\n        style={\"description_width\": \"70px\"},\n    )\n    val_dd = Dropdown(\n        description=\"Value:\",\n        layout=Layout(width=\"150px\", margin=\"0 5px\"),\n        style={\"description_width\": \"50px\"},\n    )\n\n    radius_slider = IntSlider(\n        value=radius,\n        min=1,\n        max=50,\n        step=1,\n        description=\"Radius:\",\n        continuous_update=False,\n        layout=Layout(width=\"180px\", margin=\"0 5px\"),\n        style={\"description_width\": \"50px\"},\n    )\n\n    load_button = Button(\n        description=\"Load CSV\",\n        icon=\"download\",\n        button_style=\"info\",\n        layout=Layout(width=\"100px\", margin=\"0 5px\"),\n    )\n    heatmap_button = Button(\n        description=\"Add Heatmap\",\n        icon=\"plus\",\n        button_style=\"success\",\n        layout=Layout(width=\"120px\", margin=\"0 5px\"),\n    )\n    close_button = Button(\n        icon=\"times\",\n        layout=Layout(width=\"40px\", margin=\"0 5px\"),\n        button_style=\"danger\",\n    )\n\n    # --- Output widget for messages ---\n    output = Output(\n        layout=Layout(\n            border=\"1px solid #e0e0e0\",\n            padding=\"10px\",\n            max_height=\"150px\",\n            overflow=\"auto\",\n            margin=\"5px 0\",\n            background_color=\"#f9f9f9\",\n        )\n    )\n\n    # Header with title and close button\n    header = HBox(\n        [\n            HTML(\"&lt;h4 style='margin: 0; padding: 0;'&gt;Heatmap Generator&lt;/h4&gt;\"),\n            close_button,\n        ],\n        layout=Layout(\n            justify_content=\"space-between\",\n            width=\"100%\",\n            padding=\"5px 10px\",\n            background_color=\"#4CAF50\",\n            border_radius=\"5px 5px 0 0\",\n        ),\n    )\n\n    # --- Layout ---\n    controls = VBox(\n        [\n            HBox([url_text, load_button]),\n            HBox([lat_dd, lon_dd, val_dd]),\n            HBox([radius_slider, heatmap_button]),\n        ],\n        layout=Layout(padding=\"10px\", align_items=\"center\", width=\"100%\"),\n    )\n\n    # Main panel with header, controls and output\n    panel = VBox(\n        [header, controls, output],\n        layout=Layout(\n            background_color=\"white\",\n            border=\"1px solid #e0e0e0\",\n            border_radius=\"5px\",\n            box_shadow=\"0 2px 5px rgba(0,0,0,0.1)\",\n            width=\"auto\",\n            max_width=\"800px\",\n        ),\n    )\n\n    # Collapsible container\n    collapsible = VBox([toggle, panel])\n\n    # --- Behavior Handlers ---\n    def on_toggle_change(change):\n        collapsible.children = [toggle, panel] if change[\"new\"] else [toggle]\n\n    toggle.observe(on_toggle_change, names=\"value\")\n\n    def on_close_click(_):\n        collapsible.close()\n\n    close_button.on_click(on_close_click)\n\n    def on_load_click(_):\n        with output:\n            clear_output()\n            try:\n                df = pd.read_csv(url_text.value)\n                opts = df.columns.tolist()\n                lat_dd.options = opts\n                lon_dd.options = opts\n                val_dd.options = opts\n                # Preselect if defaults provided\n                if latitude in opts:\n                    lat_dd.value = latitude\n                if longitude in opts:\n                    lon_dd.value = longitude\n                if value in opts:\n                    val_dd.value = value\n                panel.df = df\n                print(f\"\u2705 Loaded {len(df)} rows\")\n                print(f\"\ud83d\udcca Columns: {', '.join(opts)}\")\n            except Exception as e:\n                print(\"\u274c Error loading CSV:\", e)\n\n    load_button.on_click(on_load_click)\n\n    def on_add_click(_):\n        with output:\n            clear_output()\n            try:\n                df = panel.df\n                lat, lon, val = lat_dd.value, lon_dd.value, val_dd.value\n                data = df[[lat, lon, val]].values.tolist()\n                hm = Heatmap(\n                    locations=data, radius=radius_slider.value, name=\"Heat map\"\n                )\n                self.add(hm)\n                print(\"\ud83c\udf0b Heatmap successfully added!\")\n                print(f\"\ud83d\udccd Points: {len(data)}\")\n                print(f\"\ud83d\udd18 Radius: {radius_slider.value}\")\n            except Exception as e:\n                print(\"\u274c Error adding heatmap:\", e)\n\n    heatmap_button.on_click(on_add_click)\n\n    heatmap_button.on_click(on_add_click)\n\n    # Finally, add to the map\n    self.add(WidgetControl(widget=collapsible, position=position))\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.Map.add_image","title":"<code>add_image(self, image, bounds=None, **kwargs)</code>","text":"<p>Adds an image to the map.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The file path to the image.</p> required <code>bounds</code> <code>list</code> <p>The bounds for the image. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.ImageOverlay layer.</p> <code>{}</code> Source code in <code>beamgis/beamgis.py</code> <pre><code>def add_image(self, image, bounds=None, **kwargs):\n    \"\"\"Adds an image to the map.\n\n    Args:\n        image (str): The file path to the image.\n        bounds (list, optional): The bounds for the image. Defaults to None.\n        **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n    \"\"\"\n\n    if bounds is None:\n        bounds = [[-90, -180], [90, 180]]\n    overlay = ipyleaflet.ImageOverlay(url=image, bounds=bounds, **kwargs)\n    self.add(overlay)\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>beamgis/beamgis.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    control = ipyleaflet.LayersControl(position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.Map.add_raster","title":"<code>add_raster(self, url, name='Raster', colormap=None, opacity=None, **kwargs)</code>","text":"<p>Adds a raster layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The file path or URL to the raster data.</p> required <code>name</code> <code>str</code> <p>The name of the layer. Defaults to \"Raster\".</p> <code>'Raster'</code> <code>colormap</code> <code>str</code> <p>The colormap to apply. Defaults to None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the tile layer.</p> <code>{}</code> Source code in <code>beamgis/beamgis.py</code> <pre><code>def add_raster(self, url, name=\"Raster\", colormap=None, opacity=None, **kwargs):\n    \"\"\"Adds a raster layer to the map.\n\n    Args:\n        url (str): The file path or URL to the raster data.\n        name (str, optional): The name of the layer. Defaults to \"Raster\".\n        colormap (str, optional): The colormap to apply. Defaults to None.\n        opacity (float, optional): The opacity of the layer. Defaults to None.\n        **kwargs: Additional keyword arguments for the tile layer.\n    \"\"\"\n    from localtileserver import TileClient, get_leaflet_tile_layer\n\n    client = TileClient(url)\n    tile_layer = get_leaflet_tile_layer(\n        client, name=name, colormap=colormap, opacity=opacity, **kwargs\n    )\n\n    self.add(tile_layer)\n    self.center = client.center()\n    self.zoom = client.default_zoom\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.Map.add_search_control","title":"<code>add_search_control(self, url, marker=None, zoom=None, position='topleft', **kwargs)</code>","text":"<p>Adds a search control to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url to the search API. For example, \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\".</p> required <code>marker</code> <code>ipyleaflet.Marker</code> <p>The marker to be used for the search result. Defaults to None.</p> <code>None</code> <code>zoom</code> <code>int</code> <p>The zoom level to be used for the search result. Defaults to None.</p> <code>None</code> <code>position</code> <code>str</code> <p>The position of the search control. Defaults to \"topleft\".</p> <code>'topleft'</code> <code>kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the search control. See https://ipyleaflet.readthedocs.io/en/latest/api_reference/search_control.html</p> <code>{}</code> Source code in <code>beamgis/beamgis.py</code> <pre><code>def add_search_control(\n    self,\n    url: str,\n    marker: Optional[ipyleaflet.Marker] = None,\n    zoom: Optional[int] = None,\n    position: Optional[str] = \"topleft\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Adds a search control to the map.\n\n    Args:\n        url (str): The url to the search API. For example, \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\".\n        marker (ipyleaflet.Marker, optional): The marker to be used for the search result. Defaults to None.\n        zoom (int, optional): The zoom level to be used for the search result. Defaults to None.\n        position (str, optional): The position of the search control. Defaults to \"topleft\".\n        kwargs (dict, optional): Additional keyword arguments to be passed to the search control. See https://ipyleaflet.readthedocs.io/en/latest/api_reference/search_control.html\n    \"\"\"\n    if marker is None:\n        marker = ipyleaflet.Marker(\n            icon=ipyleaflet.AwesomeIcon(\n                name=\"check\", marker_color=\"green\", icon_color=\"darkred\"\n            )\n        )\n    search_control = ipyleaflet.SearchControl(\n        position=position,\n        url=url,\n        zoom=zoom,\n        marker=marker,\n        **kwargs,\n    )\n    self.add(search_control)\n    self.search_control = search_control\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>beamgis/beamgis.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.Map.add_time_slider","title":"<code>add_time_slider(self, layers={}, labels=None, time_interval=1, position='bottomright', slider_length='150px', zoom_to_layer=False, **kwargs)</code>","text":"<p>Adds a time slider to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>dict</code> <p>The dictionary containing a set of XYZ tile layers.</p> <code>{}</code> <code>labels</code> <code>list</code> <p>The list of labels to be used for the time series. Defaults to None.</p> <code>None</code> <code>time_interval</code> <code>int</code> <p>Time interval in seconds. Defaults to 1.</p> <code>1</code> <code>position</code> <code>str</code> <p>Position to place the time slider, can be any of ['topleft', 'topright', 'bottomleft', 'bottomright']. Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>slider_length</code> <code>str</code> <p>Length of the time slider. Defaults to \"150px\".</p> <code>'150px'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the extent of the selected layer. Defaults to False.</p> <code>False</code> Source code in <code>beamgis/beamgis.py</code> <pre><code>def add_time_slider(\n    self,\n    layers: dict = {},\n    labels: list = None,\n    time_interval: int = 1,\n    position: str = \"bottomright\",\n    slider_length: str = \"150px\",\n    zoom_to_layer: Optional[bool] = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Adds a time slider to the map.\n\n    Args:\n        layers (dict, optional): The dictionary containing a set of XYZ tile layers.\n        labels (list, optional): The list of labels to be used for the time series. Defaults to None.\n        time_interval (int, optional): Time interval in seconds. Defaults to 1.\n        position (str, optional): Position to place the time slider, can be any of ['topleft', 'topright', 'bottomleft', 'bottomright']. Defaults to \"bottomright\".\n        slider_length (str, optional): Length of the time slider. Defaults to \"150px\".\n        zoom_to_layer (bool, optional): Whether to zoom to the extent of the selected layer. Defaults to False.\n\n    \"\"\"\n    from .toolbar import time_slider\n\n    time_slider(\n        self,\n        layers,\n        labels,\n        time_interval,\n        position,\n        slider_length,\n        zoom_to_layer,\n        **kwargs,\n    )\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>beamgis/beamgis.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.Map.add_video","title":"<code>add_video(self, video, bounds=None, opacity=1.0, **kwargs)</code>","text":"<p>Adds a video to the map.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <code>str</code> <p>The file path to the video.</p> required <code>bounds</code> <code>list</code> <p>The bounds for the video. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.VideoOverlay layer.</p> <code>{}</code> Source code in <code>beamgis/beamgis.py</code> <pre><code>def add_video(self, video, bounds=None, opacity=1.0, **kwargs):\n    \"\"\"Adds a video to the map.\n\n    Args:\n        video (str): The file path to the video.\n        bounds (list, optional): The bounds for the video. Defaults to None.\n        **kwargs: Additional keyword arguments for the ipyleaflet.VideoOverlay layer.\n    \"\"\"\n\n    if bounds is None or not bounds:\n        raise ValueError(\"Bounds must be specified for the video overlay.\")\n    overlay = ipyleaflet.VideoOverlay(\n        url=video, bounds=bounds, opacity=opacity, **kwargs\n    )\n    self.add(overlay)\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.Map.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, name, format='image/png', transparent=True, **kwargs)</code>","text":"<p>Adds a WMS layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The WMS service URL.</p> required <code>layers</code> <code>str</code> <p>The layers to display.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.WMSLayer layer.</p> <code>{}</code> Source code in <code>beamgis/beamgis.py</code> <pre><code>def add_wms_layer(\n    self, url, layers, name, format=\"image/png\", transparent=True, **kwargs\n):\n    \"\"\"Adds a WMS layer to the map.\n\n    Args:\n        url (str): The WMS service URL.\n        layers (str): The layers to display.\n        **kwargs: Additional keyword arguments for the ipyleaflet.WMSLayer layer.\n    \"\"\"\n    layer = ipyleaflet.WMSLayer(\n        url=url,\n        layers=layers,\n        name=name,\n        format=format,\n        transparent=transparent,\n        **kwargs,\n    )\n    self.add(layer)\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.basemap_xyz_tiles","title":"<code>basemap_xyz_tiles()</code>","text":"<p>Returns a dictionary containing a set of basemaps that are XYZ tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of XYZ tile layers.</p> Source code in <code>beamgis/beamgis.py</code> <pre><code>def basemap_xyz_tiles():\n    \"\"\"Returns a dictionary containing a set of basemaps that are XYZ tile layers.\n\n    Returns:\n        dict: A dictionary of XYZ tile layers.\n    \"\"\"\n    from leafmap import basemaps\n\n    layers_dict = {}\n    keys = dict(basemaps).keys()\n    for key in keys:\n        if isinstance(basemaps[key], ipyleaflet.WMSLayer):\n            pass\n        else:\n            layers_dict[key] = basemaps[key]\n    return layers_dict\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.csv_to_df","title":"<code>csv_to_df(in_csv, **kwargs)</code>","text":"<p>Converts a CSV file to pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>File path to the input CSV.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pandas DataFrame</p> Source code in <code>beamgis/beamgis.py</code> <pre><code>def csv_to_df(in_csv, **kwargs):\n    \"\"\"Converts a CSV file to pandas dataframe.\n\n    Args:\n        in_csv (str): File path to the input CSV.\n\n    Returns:\n        pd.DataFrame: pandas DataFrame\n    \"\"\"\n    import pandas as pd\n\n    try:\n        return pd.read_csv(in_csv, **kwargs)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.planet_monthly","title":"<code>planet_monthly(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet monthly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>beamgis/beamgis.py</code> <pre><code>def planet_monthly(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet monthly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n\n    link = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_monthly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for year in range(2016, year_now + 1):\n        for month in range(1, 13):\n            m_str = str(year) + \"_\" + str(month).zfill(2)\n\n            if year == year_now and month &gt;= month_now:\n                break\n\n            url = f\"{prefix}{m_str}{subfix}{api_key}\"\n            link.append(url)\n\n    return link\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.planet_monthly_tiles","title":"<code>planet_monthly_tiles(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>beamgis/beamgis.py</code> <pre><code>def planet_monthly_tiles(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    link = planet_monthly(api_key, token_name)\n\n    for url in link:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 7]\n\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.planet_quarterly","title":"<code>planet_quarterly(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet quarterly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>beamgis/beamgis.py</code> <pre><code>def planet_quarterly(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet quarterly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n    quarter_now = (month_now - 1) // 3 + 1\n\n    link = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_quarterly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for year in range(2016, year_now + 1):\n        for quarter in range(1, 5):\n            m_str = str(year) + \"q\" + str(quarter)\n\n            if year == year_now and quarter &gt;= quarter_now:\n                break\n\n            url = f\"{prefix}{m_str}{subfix}{api_key}\"\n            link.append(url)\n\n    return link\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.planet_quarterly_tiles","title":"<code>planet_quarterly_tiles(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>beamgis/beamgis.py</code> <pre><code>def planet_quarterly_tiles(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet  quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    links = planet_quarterly(api_key, token_name)\n\n    for url in links:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 6]\n\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"beamgis/#beamgis.beamgis.stac_assets","title":"<code>stac_assets(url=None, collection=None, item=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get all assets of a STAC item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of assets.</p> Source code in <code>beamgis/beamgis.py</code> <pre><code>def stac_assets(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get all assets of a STAC item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        list: A list of assets.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if isinstance(url, pystac.Item):\n        try:\n            url = url.self_href\n        except Exception as e:\n            print(e)\n\n    if url is not None:\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(f\"{titiler_endpoint}/stac/assets\", params=kwargs).json()\n    else:\n        r = requests.get(titiler_endpoint.url_for_stac_assets(), params=kwargs).json()\n\n    return r\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>This module contains some common functions for both folium and ipyleaflet.</p>"},{"location":"common/#beamgis.common.The_national_map_USGS","title":"<code> The_national_map_USGS        </code>","text":"<p>The national map is a collection of topological datasets, maintained by the USGS.</p> <p>It provides an API endpoint which can be used to find downloadable links for the products offered.     - Full description of datasets available can retrieved.       This consists of metadata such as detail description and publication dates.     - A wide range of dataformats are available</p> <p>This class is a tiny wrapper to find and download files using the API.</p> <p>More complete documentation for the API can be found at     https://apps.nationalmap.gov/tnmaccess/#/</p> Source code in <code>beamgis/common.py</code> <pre><code>class The_national_map_USGS:\n    \"\"\"\n    The national map is a collection of topological datasets, maintained by the USGS.\n\n    It provides an API endpoint which can be used to find downloadable links for the products offered.\n        - Full description of datasets available can retrieved.\n          This consists of metadata such as detail description and publication dates.\n        - A wide range of dataformats are available\n\n    This class is a tiny wrapper to find and download files using the API.\n\n    More complete documentation for the API can be found at\n        https://apps.nationalmap.gov/tnmaccess/#/\n    \"\"\"\n\n    def __init__(self):\n        self.api_endpoint = r\"https://tnmaccess.nationalmap.gov/api/v1/\"\n        self.DS = self.datasets_full\n\n    @property\n    def datasets_full(self) -&gt; list:\n        \"\"\"\n        Full description of datasets provided.\n        Returns a JSON or empty list.\n        \"\"\"\n        link = f\"{self.api_endpoint}datasets?\"\n        try:\n            return requests.get(link).json()\n        except Exception:\n            print(f\"Failed to load metadata from The National Map API endpoint\\n{link}\")\n            return []\n\n    @property\n    def prodFormats(self) -&gt; list:\n        \"\"\"\n        Return all datatypes available in any of the collections.\n        Note that \"All\" is only peculiar to one dataset.\n        \"\"\"\n        return set(i[\"displayName\"] for ds in self.DS for i in ds[\"formats\"])\n\n    @property\n    def datasets(self) -&gt; list:\n        \"\"\"\n        Returns a list of dataset tags (most common human readable self description for specific datasets).\n        \"\"\"\n        return set(y[\"sbDatasetTag\"] for x in self.DS for y in x[\"tags\"])\n\n    def parse_region(self, region, geopandas_args={}) -&gt; list:\n        \"\"\"\n\n        Translate a Vector dataset to its bounding box.\n\n        Args:\n            region (str | list): an URL|filepath to a vector dataset to a polygon\n            geopandas_reader_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n                Used for reading a region URL|filepath.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(region, str):\n            if region.startswith(\"http\"):\n                region = github_raw_url(region)\n                region = download_file(region)\n            elif not os.path.exists(region):\n                raise ValueError(\"region must be a path or a URL to a vector dataset.\")\n\n            roi = gpd.read_file(region, **geopandas_args)\n            roi = roi.to_crs(epsg=4326)\n            return roi.total_bounds\n        return region\n\n    def download_tiles(\n        self, region=None, out_dir=None, download_args={}, geopandas_args={}, API={}\n    ) -&gt; None:\n        \"\"\"\n\n        Download the US National Elevation Datasets (NED) for a region.\n\n        Args:\n            region (str | list, optional): An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy].\n                Alternatively you could use API parameters such as polygon or bbox.\n            out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n            download_args (dict, optional): A dictionary of arguments to pass to the download_file function. Defaults to {}.\n            geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n                Used for reading a region URL|filepath.\n            API (dict, optional): A dictionary of arguments to pass to the self.find_details() function.\n                Exposes most of the documented API. Defaults to {}.\n\n        Returns:\n            None\n        \"\"\"\n\n        if os.environ.get(\"USE_MKDOCS\") is not None:\n            return\n\n        if out_dir is None:\n            out_dir = os.getcwd()\n        else:\n            out_dir = os.path.abspath(out_dir)\n\n        tiles = self.find_tiles(\n            region, return_type=\"list\", geopandas_args=geopandas_args, API=API\n        )\n        T = len(tiles)\n        errors = 0\n        done = 0\n\n        for i, link in enumerate(tiles):\n            file_name = os.path.basename(link)\n            out_name = os.path.join(out_dir, file_name)\n            if i &lt; 5 or (i &lt; 50 and not (i % 5)) or not (i % 20):\n                print(f\"Downloading {i+1} of {T}: {file_name}\")\n            try:\n                download_file(link, out_name, **download_args)\n                done += 1\n            except KeyboardInterrupt:\n                print(\"Cancelled download\")\n                break\n            except Exception:\n                errors += 1\n                print(f\"Failed to download {i+1} of {T}: {file_name}\")\n\n        print(\n            f\"{done} Downloads completed, {errors} downloads failed, {T} files available\"\n        )\n        return\n\n    def find_tiles(self, region=None, return_type=\"list\", geopandas_args={}, API={}):\n        \"\"\"\n        Find a list of downloadable files.\n\n        Args:\n            region (str | list, optional): An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy].\n                Alternatively you could use API parameters such as polygon or bbox.\n            out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n            return_type (str): list | dict. Defaults to list. Changes the return output type and content.\n            geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n                Used for reading a region URL|filepath.\n            API (dict, optional): A dictionary of arguments to pass to the self.find_details() function.\n                Exposes most of the documented API parameters. Defaults to {}.\n\n        Returns:\n            list: A list of download_urls.\n            dict: A dictionary with urls and related metadata\n        \"\"\"\n        assert region or API, \"Provide a region or use the API\"\n\n        if region:\n            API[\"bbox\"] = self.parse_region(region, geopandas_args)\n\n        results = self.find_details(**API)\n        if return_type == \"list\":\n            return [i[\"downloadURL\"] for i in results.get(\"items\")]\n        return results\n\n    def find_details(\n        self,\n        bbox: List[float] = None,\n        polygon: List[Tuple[float, float]] = None,\n        datasets: str = None,\n        prodFormats: str = None,\n        prodExtents: str = None,\n        q: str = None,\n        dateType: str = None,\n        start: str = None,\n        end: str = None,\n        offset: int = 0,\n        max: int = None,\n        outputFormat: str = \"JSON\",\n        polyType: str = None,\n        polyCode: str = None,\n        extentQuery: int = None,\n    ) -&gt; Dict:\n        \"\"\"\n        Possible search parameters (kwargs) support by API\n\n        Parameter               Values\n            Description\n        ---------------------------------------------------------------------------------------------------\n        bbox                    'minx, miny, maxx, maxy'\n            Geographic longitude/latitude values expressed in  decimal degrees in a comma-delimited list.\n        polygon                 '[x,y x,y x,y x,y x,y]'\n            Polygon, longitude/latitude values expressed in decimal degrees in a space-delimited list.\n        datasets                See: Datasets (Optional)\n            Dataset tag name (sbDatasetTag)\n            From https://apps.nationalmap.gov/tnmaccess/#/product\n        prodFormats             See: Product Formats (Optional)\n            Dataset-specific format\n\n        prodExtents             See: Product Extents (Optional)\n            Dataset-specific extent\n        q                       free text\n            Text input which can be used to filter by product titles and text descriptions.\n        dateType                dateCreated | lastUpdated | Publication\n            Type of date to search by.\n        start                   'YYYY-MM-DD'\n            Start date\n        end                     'YYYY-MM-DD'\n            End date (required if start date is provided)\n        offset                  integer\n            Offset into paginated results - default=0\n        max                     integer\n            Number of results returned\n        outputFormat            JSON | CSV | pjson\n            Default=JSON\n        polyType                state | huc2 | huc4 | huc8\n            Well Known Polygon Type. Use this parameter to deliver data by state or HUC\n            (hydrologic unit codes defined by the Watershed Boundary Dataset/WBD)\n        polyCode                state FIPS code or huc number\n            Well Known Polygon Code. This value needs to coordinate with the polyType parameter.\n        extentQuery             integer\n            A Polygon code in the science base system, typically from an uploaded shapefile\n        \"\"\"\n\n        try:\n            # call locals before creating new locals\n            used_locals = {k: v for k, v in locals().items() if v and k != \"self\"}\n\n            # Parsing\n            if polygon:\n                used_locals[\"polygon\"] = \",\".join(\n                    \" \".join(map(str, point)) for point in polygon\n                )\n            if bbox:\n                used_locals[\"bbox\"] = str(bbox)[1:-1]\n\n            if max:\n                max += 2\n\n            # Fetch response\n            response = requests.get(f\"{self.api_endpoint}products?\", params=used_locals)\n            if response.status_code // 100 == 2:\n                return response.json()\n            else:\n                # Parameter validation handled by API endpoint error responses\n                print(response.json())\n            return {}\n        except Exception as e:\n            print(e)\n            return {}\n</code></pre>"},{"location":"common/#beamgis.common.The_national_map_USGS.datasets","title":"<code>datasets: list</code>  <code>property</code> <code>readonly</code>","text":"<p>Returns a list of dataset tags (most common human readable self description for specific datasets).</p>"},{"location":"common/#beamgis.common.The_national_map_USGS.datasets_full","title":"<code>datasets_full: list</code>  <code>property</code> <code>readonly</code>","text":"<p>Full description of datasets provided. Returns a JSON or empty list.</p>"},{"location":"common/#beamgis.common.The_national_map_USGS.prodFormats","title":"<code>prodFormats: list</code>  <code>property</code> <code>readonly</code>","text":"<p>Return all datatypes available in any of the collections. Note that \"All\" is only peculiar to one dataset.</p>"},{"location":"common/#beamgis.common.The_national_map_USGS.download_tiles","title":"<code>download_tiles(self, region=None, out_dir=None, download_args={}, geopandas_args={}, API={})</code>","text":"<p>Download the US National Elevation Datasets (NED) for a region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str | list</code> <p>An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy]. Alternatively you could use API parameters such as polygon or bbox.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The directory to download the files to. Defaults to None, which uses the current working directory.</p> <code>None</code> <code>download_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the download_file function. Defaults to {}.</p> <code>{}</code> <code>geopandas_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the geopandas.read_file() function. Used for reading a region URL|filepath.</p> <code>{}</code> <code>API</code> <code>dict</code> <p>A dictionary of arguments to pass to the self.find_details() function. Exposes most of the documented API. Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>beamgis/common.py</code> <pre><code>def download_tiles(\n    self, region=None, out_dir=None, download_args={}, geopandas_args={}, API={}\n) -&gt; None:\n    \"\"\"\n\n    Download the US National Elevation Datasets (NED) for a region.\n\n    Args:\n        region (str | list, optional): An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy].\n            Alternatively you could use API parameters such as polygon or bbox.\n        out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n        download_args (dict, optional): A dictionary of arguments to pass to the download_file function. Defaults to {}.\n        geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n            Used for reading a region URL|filepath.\n        API (dict, optional): A dictionary of arguments to pass to the self.find_details() function.\n            Exposes most of the documented API. Defaults to {}.\n\n    Returns:\n        None\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n    else:\n        out_dir = os.path.abspath(out_dir)\n\n    tiles = self.find_tiles(\n        region, return_type=\"list\", geopandas_args=geopandas_args, API=API\n    )\n    T = len(tiles)\n    errors = 0\n    done = 0\n\n    for i, link in enumerate(tiles):\n        file_name = os.path.basename(link)\n        out_name = os.path.join(out_dir, file_name)\n        if i &lt; 5 or (i &lt; 50 and not (i % 5)) or not (i % 20):\n            print(f\"Downloading {i+1} of {T}: {file_name}\")\n        try:\n            download_file(link, out_name, **download_args)\n            done += 1\n        except KeyboardInterrupt:\n            print(\"Cancelled download\")\n            break\n        except Exception:\n            errors += 1\n            print(f\"Failed to download {i+1} of {T}: {file_name}\")\n\n    print(\n        f\"{done} Downloads completed, {errors} downloads failed, {T} files available\"\n    )\n    return\n</code></pre>"},{"location":"common/#beamgis.common.The_national_map_USGS.find_details","title":"<code>find_details(self, bbox=None, polygon=None, datasets=None, prodFormats=None, prodExtents=None, q=None, dateType=None, start=None, end=None, offset=0, max=None, outputFormat='JSON', polyType=None, polyCode=None, extentQuery=None)</code>","text":"<p>Possible search parameters (kwargs) support by API</p> <p>Parameter               Values     Description</p> <p>bbox                    'minx, miny, maxx, maxy'     Geographic longitude/latitude values expressed in  decimal degrees in a comma-delimited list. polygon                 '[x,y x,y x,y x,y x,y]'     Polygon, longitude/latitude values expressed in decimal degrees in a space-delimited list. datasets                See: Datasets (Optional)     Dataset tag name (sbDatasetTag)     From https://apps.nationalmap.gov/tnmaccess/#/product prodFormats             See: Product Formats (Optional)     Dataset-specific format</p> <p>prodExtents             See: Product Extents (Optional)     Dataset-specific extent q                       free text     Text input which can be used to filter by product titles and text descriptions. dateType                dateCreated | lastUpdated | Publication     Type of date to search by. start                   'YYYY-MM-DD'     Start date end                     'YYYY-MM-DD'     End date (required if start date is provided) offset                  integer     Offset into paginated results - default=0 max                     integer     Number of results returned outputFormat            JSON | CSV | pjson     Default=JSON polyType                state | huc2 | huc4 | huc8     Well Known Polygon Type. Use this parameter to deliver data by state or HUC     (hydrologic unit codes defined by the Watershed Boundary Dataset/WBD) polyCode                state FIPS code or huc number     Well Known Polygon Code. This value needs to coordinate with the polyType parameter. extentQuery             integer     A Polygon code in the science base system, typically from an uploaded shapefile</p> Source code in <code>beamgis/common.py</code> <pre><code>def find_details(\n    self,\n    bbox: List[float] = None,\n    polygon: List[Tuple[float, float]] = None,\n    datasets: str = None,\n    prodFormats: str = None,\n    prodExtents: str = None,\n    q: str = None,\n    dateType: str = None,\n    start: str = None,\n    end: str = None,\n    offset: int = 0,\n    max: int = None,\n    outputFormat: str = \"JSON\",\n    polyType: str = None,\n    polyCode: str = None,\n    extentQuery: int = None,\n) -&gt; Dict:\n    \"\"\"\n    Possible search parameters (kwargs) support by API\n\n    Parameter               Values\n        Description\n    ---------------------------------------------------------------------------------------------------\n    bbox                    'minx, miny, maxx, maxy'\n        Geographic longitude/latitude values expressed in  decimal degrees in a comma-delimited list.\n    polygon                 '[x,y x,y x,y x,y x,y]'\n        Polygon, longitude/latitude values expressed in decimal degrees in a space-delimited list.\n    datasets                See: Datasets (Optional)\n        Dataset tag name (sbDatasetTag)\n        From https://apps.nationalmap.gov/tnmaccess/#/product\n    prodFormats             See: Product Formats (Optional)\n        Dataset-specific format\n\n    prodExtents             See: Product Extents (Optional)\n        Dataset-specific extent\n    q                       free text\n        Text input which can be used to filter by product titles and text descriptions.\n    dateType                dateCreated | lastUpdated | Publication\n        Type of date to search by.\n    start                   'YYYY-MM-DD'\n        Start date\n    end                     'YYYY-MM-DD'\n        End date (required if start date is provided)\n    offset                  integer\n        Offset into paginated results - default=0\n    max                     integer\n        Number of results returned\n    outputFormat            JSON | CSV | pjson\n        Default=JSON\n    polyType                state | huc2 | huc4 | huc8\n        Well Known Polygon Type. Use this parameter to deliver data by state or HUC\n        (hydrologic unit codes defined by the Watershed Boundary Dataset/WBD)\n    polyCode                state FIPS code or huc number\n        Well Known Polygon Code. This value needs to coordinate with the polyType parameter.\n    extentQuery             integer\n        A Polygon code in the science base system, typically from an uploaded shapefile\n    \"\"\"\n\n    try:\n        # call locals before creating new locals\n        used_locals = {k: v for k, v in locals().items() if v and k != \"self\"}\n\n        # Parsing\n        if polygon:\n            used_locals[\"polygon\"] = \",\".join(\n                \" \".join(map(str, point)) for point in polygon\n            )\n        if bbox:\n            used_locals[\"bbox\"] = str(bbox)[1:-1]\n\n        if max:\n            max += 2\n\n        # Fetch response\n        response = requests.get(f\"{self.api_endpoint}products?\", params=used_locals)\n        if response.status_code // 100 == 2:\n            return response.json()\n        else:\n            # Parameter validation handled by API endpoint error responses\n            print(response.json())\n        return {}\n    except Exception as e:\n        print(e)\n        return {}\n</code></pre>"},{"location":"common/#beamgis.common.The_national_map_USGS.find_tiles","title":"<code>find_tiles(self, region=None, return_type='list', geopandas_args={}, API={})</code>","text":"<p>Find a list of downloadable files.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str | list</code> <p>An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy]. Alternatively you could use API parameters such as polygon or bbox.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The directory to download the files to. Defaults to None, which uses the current working directory.</p> required <code>return_type</code> <code>str</code> <p>list | dict. Defaults to list. Changes the return output type and content.</p> <code>'list'</code> <code>geopandas_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the geopandas.read_file() function. Used for reading a region URL|filepath.</p> <code>{}</code> <code>API</code> <code>dict</code> <p>A dictionary of arguments to pass to the self.find_details() function. Exposes most of the documented API parameters. Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of download_urls. dict: A dictionary with urls and related metadata</p> Source code in <code>beamgis/common.py</code> <pre><code>def find_tiles(self, region=None, return_type=\"list\", geopandas_args={}, API={}):\n    \"\"\"\n    Find a list of downloadable files.\n\n    Args:\n        region (str | list, optional): An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy].\n            Alternatively you could use API parameters such as polygon or bbox.\n        out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n        return_type (str): list | dict. Defaults to list. Changes the return output type and content.\n        geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n            Used for reading a region URL|filepath.\n        API (dict, optional): A dictionary of arguments to pass to the self.find_details() function.\n            Exposes most of the documented API parameters. Defaults to {}.\n\n    Returns:\n        list: A list of download_urls.\n        dict: A dictionary with urls and related metadata\n    \"\"\"\n    assert region or API, \"Provide a region or use the API\"\n\n    if region:\n        API[\"bbox\"] = self.parse_region(region, geopandas_args)\n\n    results = self.find_details(**API)\n    if return_type == \"list\":\n        return [i[\"downloadURL\"] for i in results.get(\"items\")]\n    return results\n</code></pre>"},{"location":"common/#beamgis.common.The_national_map_USGS.parse_region","title":"<code>parse_region(self, region, geopandas_args={})</code>","text":"<p>Translate a Vector dataset to its bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str | list</code> <p>an URL|filepath to a vector dataset to a polygon</p> required <code>geopandas_reader_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the geopandas.read_file() function. Used for reading a region URL|filepath.</p> required Source code in <code>beamgis/common.py</code> <pre><code>def parse_region(self, region, geopandas_args={}) -&gt; list:\n    \"\"\"\n\n    Translate a Vector dataset to its bounding box.\n\n    Args:\n        region (str | list): an URL|filepath to a vector dataset to a polygon\n        geopandas_reader_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n            Used for reading a region URL|filepath.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(region, str):\n        if region.startswith(\"http\"):\n            region = github_raw_url(region)\n            region = download_file(region)\n        elif not os.path.exists(region):\n            raise ValueError(\"region must be a path or a URL to a vector dataset.\")\n\n        roi = gpd.read_file(region, **geopandas_args)\n        roi = roi.to_crs(epsg=4326)\n        return roi.total_bounds\n    return region\n</code></pre>"},{"location":"common/#beamgis.common.WhiteboxTools","title":"<code> WhiteboxTools            (WhiteboxTools)         </code>","text":"<p>This class inherits the whitebox WhiteboxTools class.</p> Source code in <code>beamgis/common.py</code> <pre><code>class WhiteboxTools(whitebox.WhiteboxTools):\n    \"\"\"This class inherits the whitebox WhiteboxTools class.\"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"common/#beamgis.common.__install_from_github","title":"<code>__install_from_github(url)</code>","text":"<p>Install a package from a GitHub repository.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the GitHub repository.</p> required Source code in <code>beamgis/common.py</code> <pre><code>def __install_from_github(url: str) -&gt; None:\n    \"\"\"Install a package from a GitHub repository.\n\n    Args:\n        url (str): The URL of the GitHub repository.\n    \"\"\"\n\n    try:\n        download_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        if not os.path.exists(download_dir):\n            os.makedirs(download_dir)\n\n        repo_name = os.path.basename(url)\n        zip_url = os.path.join(url, \"archive/master.zip\")\n        filename = repo_name + \"-master.zip\"\n        download_from_url(\n            url=zip_url, out_file_name=filename, out_dir=download_dir, unzip=True\n        )\n\n        pkg_dir = os.path.join(download_dir, repo_name + \"-master\")\n        pkg_name = os.path.basename(url)\n        work_dir = os.getcwd()\n        os.chdir(pkg_dir)\n        print(\"Installing {}...\".format(pkg_name))\n        cmd = \"pip install .\"\n        os.system(cmd)\n        os.chdir(work_dir)\n        print(\"{} has been installed successfully.\".format(pkg_name))\n        # print(\"\\nPlease comment out 'install_from_github()' and restart the kernel to take effect:\\nJupyter menu -&gt; Kernel -&gt; Restart &amp; Clear Output\")\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.add_crs","title":"<code>add_crs(filename, epsg)</code>","text":"<p>Add a CRS to a raster dataset.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the raster dataset.</p> required <code>epsg</code> <code>int | str</code> <p>The EPSG code of the CRS.</p> required Source code in <code>beamgis/common.py</code> <pre><code>def add_crs(filename, epsg):\n    \"\"\"Add a CRS to a raster dataset.\n\n    Args:\n        filename (str): The filename of the raster dataset.\n        epsg (int | str): The EPSG code of the CRS.\n\n    \"\"\"\n    try:\n        import rasterio\n    except ImportError:\n        raise ImportError(\n            \"rasterio is required for adding a CRS to a raster. Please install it using 'pip install rasterio'.\"\n        )\n\n    if not os.path.exists(filename):\n        raise ValueError(\"filename must exist.\")\n\n    if isinstance(epsg, int):\n        epsg = f\"EPSG:{epsg}\"\n    elif isinstance(epsg, str):\n        epsg = \"EPSG:\" + epsg\n    else:\n        raise ValueError(\"epsg must be an integer or string.\")\n\n    crs = rasterio.crs.CRS({\"init\": epsg})\n    with rasterio.open(filename, mode=\"r+\") as src:\n        src.crs = crs\n</code></pre>"},{"location":"common/#beamgis.common.add_image_to_gif","title":"<code>add_image_to_gif(in_gif, out_gif, in_image, xy=None, image_size=(80, 80), circle_mask=False)</code>","text":"<p>Adds an image logo to a GIF image.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>Input file path to the GIF image.</p> required <code>out_gif</code> <code>str</code> <p>Output file path to the GIF image.</p> required <code>in_image</code> <code>str</code> <p>Input file path to the image.</p> required <code>xy</code> <code>tuple</code> <p>Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>None</code> <code>image_size</code> <code>tuple</code> <p>Resize image. Defaults to (80, 80).</p> <code>(80, 80)</code> <code>circle_mask</code> <code>bool</code> <p>Whether to apply a circle mask to the image. This only works with non-png images. Defaults to False.</p> <code>False</code> Source code in <code>beamgis/common.py</code> <pre><code>def add_image_to_gif(\n    in_gif, out_gif, in_image, xy=None, image_size=(80, 80), circle_mask=False\n):\n    \"\"\"Adds an image logo to a GIF image.\n\n    Args:\n        in_gif (str): Input file path to the GIF image.\n        out_gif (str): Output file path to the GIF image.\n        in_image (str): Input file path to the image.\n        xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        image_size (tuple, optional): Resize image. Defaults to (80, 80).\n        circle_mask (bool, optional): Whether to apply a circle mask to the image. This only works with non-png images. Defaults to False.\n    \"\"\"\n    import io\n\n    from PIL import Image, ImageDraw, ImageSequence\n\n    warnings.simplefilter(\"ignore\")\n\n    in_gif = os.path.abspath(in_gif)\n\n    is_url = False\n    if in_image.startswith(\"http\"):\n        is_url = True\n\n    if not os.path.exists(in_gif):\n        print(\"The input gif file does not exist.\")\n        return\n\n    if (not is_url) and (not os.path.exists(in_image)):\n        print(\"The provided logo file does not exist.\")\n        return\n\n    out_dir = check_dir((os.path.dirname(out_gif)))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    try:\n        gif = Image.open(in_gif)\n    except Exception as e:\n        print(\"An error occurred while opening the image.\")\n        print(e)\n        return\n\n    logo_raw_image = None\n    try:\n        if in_image.startswith(\"http\"):\n            logo_raw_image = open_image_from_url(in_image)\n        else:\n            in_image = os.path.abspath(in_image)\n            logo_raw_image = Image.open(in_image)\n    except Exception as e:\n        print(e)\n\n    logo_raw_size = logo_raw_image.size\n\n    ratio = max(\n        logo_raw_size[0] / image_size[0],\n        logo_raw_size[1] / image_size[1],\n    )\n    image_resize = (int(logo_raw_size[0] / ratio), int(logo_raw_size[1] / ratio))\n    image_size = min(logo_raw_size[0], image_size[0]), min(\n        logo_raw_size[1], image_size[1]\n    )\n\n    logo_image = logo_raw_image.convert(\"RGBA\")\n    logo_image.thumbnail(image_size, Image.ANTIALIAS)\n\n    gif_width, gif_height = gif.size\n    mask_im = None\n\n    if circle_mask:\n        mask_im = Image.new(\"L\", image_size, 0)\n        draw = ImageDraw.Draw(mask_im)\n        draw.ellipse((0, 0, image_size[0], image_size[1]), fill=255)\n\n    if has_transparency(logo_raw_image):\n        mask_im = logo_image.copy()\n\n    if xy is None:\n        # default logo location is 5% width and 5% height of the image.\n        delta = 10\n        xy = (gif_width - image_resize[0] - delta, gif_height - image_resize[1] - delta)\n        # xy = (int(0.05 * gif_width), int(0.05 * gif_height))\n    elif (xy is not None) and (not isinstance(xy, tuple)) and (len(xy) == 2):\n        print(\"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\")\n        return\n    elif all(isinstance(item, int) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (x &gt; 0) and (x &lt; gif_width) and (y &gt; 0) and (y &lt; gif_height):\n            pass\n        else:\n            print(\n                \"xy is out of bounds. x must be within [0, {}], and y must be within [0, {}]\".format(\n                    gif_width, gif_height\n                )\n            )\n            return\n    elif all(isinstance(item, str) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (\"%\" in x) and (\"%\" in y):\n            try:\n                x = int(float(x.replace(\"%\", \"\")) / 100.0 * gif_width)\n                y = int(float(y.replace(\"%\", \"\")) / 100.0 * gif_height)\n                xy = (x, y)\n            except Exception:\n                raise Exception(\n                    \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\"\n                )\n\n    else:\n        raise Exception(\n            \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\"\n        )\n\n    try:\n        frames = []\n        for _, frame in enumerate(ImageSequence.Iterator(gif)):\n            frame = frame.convert(\"RGBA\")\n            frame.paste(logo_image, xy, mask_im)\n\n            b = io.BytesIO()\n            frame.save(b, format=\"GIF\")\n            frame = Image.open(b)\n            frames.append(frame)\n\n        frames[0].save(out_gif, save_all=True, append_images=frames[1:])\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#beamgis.common.add_mask_to_image","title":"<code>add_mask_to_image(image, mask, output, color='red')</code>","text":"<p>Overlay a binary mask (e.g., roads, building footprints, etc) on an image. Credits to Xingjian Shi for the sample code.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>A local path or HTTP URL to an image.</p> required <code>mask</code> <code>str</code> <p>A local path or HTTP URL to a binary mask.</p> required <code>output</code> <code>str</code> <p>A local path to the output image.</p> required <code>color</code> <code>str</code> <p>Color of the mask. Defaults to 'red'.</p> <code>'red'</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If rasterio and detectron2 are not installed.</p> Source code in <code>beamgis/common.py</code> <pre><code>def add_mask_to_image(image, mask, output, color=\"red\"):\n    \"\"\"Overlay a binary mask (e.g., roads, building footprints, etc) on an image. Credits to Xingjian Shi for the sample code.\n\n    Args:\n        image (str): A local path or HTTP URL to an image.\n        mask (str): A local path or HTTP URL to a binary mask.\n        output (str): A local path to the output image.\n        color (str, optional): Color of the mask. Defaults to 'red'.\n\n    Raises:\n        ImportError: If rasterio and detectron2 are not installed.\n    \"\"\"\n    try:\n        import rasterio\n        from detectron2.utils.visualizer import Visualizer\n        from PIL import Image\n    except ImportError:\n        raise ImportError(\n            \"Please install rasterio and detectron2 to use this function. See https://detectron2.readthedocs.io/en/latest/tutorials/install.html\"\n        )\n\n    ds = rasterio.open(image)\n    image_arr = ds.read()\n\n    mask_arr = rasterio.open(mask).read()\n\n    vis = Visualizer(image_arr.transpose((1, 2, 0)))\n    vis.draw_binary_mask(mask_arr[0] &gt; 0, color=color)\n\n    out_arr = Image.fromarray(vis.get_output().get_image())\n\n    out_arr.save(output)\n\n    if ds.crs is not None:\n        numpy_to_cog(output, output, profile=image)\n</code></pre>"},{"location":"common/#beamgis.common.add_progress_bar_to_gif","title":"<code>add_progress_bar_to_gif(in_gif, out_gif, progress_bar_color='blue', progress_bar_height=5, duration=100, loop=0)</code>","text":"<p>Adds a progress bar to a GIF image.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The file path to the input GIF image.</p> required <code>out_gif</code> <code>str</code> <p>The file path to the output GIF image.</p> required <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'blue'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>duration</code> <code>int</code> <p>controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation. Defaults to 100.</p> <code>100</code> <code>loop</code> <code>int</code> <p>controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> Source code in <code>beamgis/common.py</code> <pre><code>def add_progress_bar_to_gif(\n    in_gif,\n    out_gif,\n    progress_bar_color=\"blue\",\n    progress_bar_height=5,\n    duration=100,\n    loop=0,\n):\n    \"\"\"Adds a progress bar to a GIF image.\n\n    Args:\n        in_gif (str): The file path to the input GIF image.\n        out_gif (str): The file path to the output GIF image.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        duration (int, optional): controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation. Defaults to 100.\n        loop (int, optional): controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n\n    \"\"\"\n    import io\n\n    from PIL import Image, ImageDraw, ImageSequence\n\n    warnings.simplefilter(\"ignore\")\n\n    in_gif = os.path.abspath(in_gif)\n    out_gif = os.path.abspath(out_gif)\n\n    if not os.path.exists(in_gif):\n        print(\"The input gif file does not exist.\")\n        return\n\n    if not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    progress_bar_color = check_color(progress_bar_color)\n\n    try:\n        image = Image.open(in_gif)\n    except Exception as e:\n        raise Exception(\"An error occurred while opening the gif.\")\n\n    count = image.n_frames\n    W, H = image.size\n    progress_bar_widths = [i * 1.0 / count * W for i in range(1, count + 1)]\n    progress_bar_shapes = [\n        [(0, H - progress_bar_height), (x, H)] for x in progress_bar_widths\n    ]\n\n    try:\n        frames = []\n        # Loop over each frame in the animated image\n        for index, frame in enumerate(ImageSequence.Iterator(image)):\n            # Draw the text on the frame\n            frame = frame.convert(\"RGB\")\n            draw = ImageDraw.Draw(frame)\n            # w, h = draw.textsize(text[index])\n            draw.rectangle(progress_bar_shapes[index], fill=progress_bar_color)\n            del draw\n\n            b = io.BytesIO()\n            frame.save(b, format=\"GIF\")\n            frame = Image.open(b)\n\n            frames.append(frame)\n        # https://www.pythoninformer.com/python-libraries/pillow/creating-animated-gif/\n        # Save the frames as a new image\n\n        frames[0].save(\n            out_gif,\n            save_all=True,\n            append_images=frames[1:],\n            duration=duration,\n            loop=loop,\n            optimize=True,\n        )\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.add_text_to_gif","title":"<code>add_text_to_gif(in_gif, out_gif, xy=None, text_sequence=None, font_type='arial.ttf', font_size=20, font_color='#000000', add_progress_bar=True, progress_bar_color='white', progress_bar_height=5, duration=100, loop=0)</code>","text":"<p>Adds animated text to a GIF image.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The file path to the input GIF image.</p> required <code>out_gif</code> <code>str</code> <p>The file path to the output GIF image.</p> required <code>xy</code> <code>tuple</code> <p>Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>None</code> <code>text_sequence</code> <code>int, str, list</code> <p>Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.</p> <code>None</code> <code>font_type</code> <code>str</code> <p>Font type. Defaults to \"arial.ttf\".</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>Font size. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.</p> <code>'#000000'</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar at the bottom of the GIF. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'white'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>duration</code> <code>int</code> <p>controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100.</p> <code>100</code> <code>loop</code> <code>int</code> <p>controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> Source code in <code>beamgis/common.py</code> <pre><code>def add_text_to_gif(\n    in_gif,\n    out_gif,\n    xy=None,\n    text_sequence=None,\n    font_type=\"arial.ttf\",\n    font_size=20,\n    font_color=\"#000000\",\n    add_progress_bar=True,\n    progress_bar_color=\"white\",\n    progress_bar_height=5,\n    duration=100,\n    loop=0,\n):\n    \"\"\"Adds animated text to a GIF image.\n\n    Args:\n        in_gif (str): The file path to the input GIF image.\n        out_gif (str): The file path to the output GIF image.\n        xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.\n        font_type (str, optional): Font type. Defaults to \"arial.ttf\".\n        font_size (int, optional): Font size. Defaults to 20.\n        font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.\n        add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        duration (int, optional): controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100.\n        loop (int, optional): controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n\n    \"\"\"\n    import io\n\n    import importlib.resources\n    from PIL import Image, ImageDraw, ImageFont, ImageSequence\n\n    warnings.simplefilter(\"ignore\")\n    pkg_dir = os.path.dirname(importlib.resources.files(\"leafmap\") / \"leafmap.py\")\n    default_font = os.path.join(pkg_dir, \"data/fonts/arial.ttf\")\n\n    in_gif = os.path.abspath(in_gif)\n    out_gif = os.path.abspath(out_gif)\n\n    if not os.path.exists(in_gif):\n        print(\"The input gif file does not exist.\")\n        return\n\n    if not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    if font_type == \"arial.ttf\":\n        font = ImageFont.truetype(default_font, font_size)\n    elif font_type == \"alibaba.otf\":\n        default_font = os.path.join(pkg_dir, \"data/fonts/alibaba.otf\")\n        font = ImageFont.truetype(default_font, font_size)\n    else:\n        try:\n            font_list = system_fonts(show_full_path=True)\n            font_names = [os.path.basename(f) for f in font_list]\n            if (font_type in font_list) or (font_type in font_names):\n                font = ImageFont.truetype(font_type, font_size)\n            else:\n                print(\n                    \"The specified font type could not be found on your system. Using the default font instead.\"\n                )\n                font = ImageFont.truetype(default_font, font_size)\n        except Exception as e:\n            print(e)\n            font = ImageFont.truetype(default_font, font_size)\n\n    color = check_color(font_color)\n    progress_bar_color = check_color(progress_bar_color)\n\n    try:\n        image = Image.open(in_gif)\n    except Exception as e:\n        print(\"An error occurred while opening the gif.\")\n        print(e)\n        return\n\n    count = image.n_frames\n    W, H = image.size\n    progress_bar_widths = [i * 1.0 / count * W for i in range(1, count + 1)]\n    progress_bar_shapes = [\n        [(0, H - progress_bar_height), (x, H)] for x in progress_bar_widths\n    ]\n\n    if xy is None:\n        # default text location is 5% width and 5% height of the image.\n        xy = (int(0.05 * W), int(0.05 * H))\n    elif (xy is not None) and (not isinstance(xy, tuple)) and (len(xy) == 2):\n        print(\"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\")\n        return\n    elif all(isinstance(item, int) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (x &gt; 0) and (x &lt; W) and (y &gt; 0) and (y &lt; H):\n            pass\n        else:\n            print(\n                f\"xy is out of bounds. x must be within [0, {W}], and y must be within [0, {H}]\"\n            )\n            return\n    elif all(isinstance(item, str) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (\"%\" in x) and (\"%\" in y):\n            try:\n                x = int(float(x.replace(\"%\", \"\")) / 100.0 * W)\n                y = int(float(y.replace(\"%\", \"\")) / 100.0 * H)\n                xy = (x, y)\n            except Exception:\n                raise Exception(\n                    \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\"\n                )\n    else:\n        print(\n            \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\"\n        )\n        return\n\n    if text_sequence is None:\n        text = [str(x) for x in range(1, count + 1)]\n    elif isinstance(text_sequence, int):\n        text = [str(x) for x in range(text_sequence, text_sequence + count + 1)]\n    elif isinstance(text_sequence, str):\n        try:\n            text_sequence = int(text_sequence)\n            text = [str(x) for x in range(text_sequence, text_sequence + count + 1)]\n        except Exception:\n            text = [text_sequence] * count\n    elif isinstance(text_sequence, list) and len(text_sequence) != count:\n        print(\n            f\"The length of the text sequence must be equal to the number ({count}) of frames in the gif.\"\n        )\n        return\n    else:\n        text = [str(x) for x in text_sequence]\n\n    try:\n        frames = []\n        # Loop over each frame in the animated image\n        for index, frame in enumerate(ImageSequence.Iterator(image)):\n            # Draw the text on the frame\n            frame = frame.convert(\"RGB\")\n            draw = ImageDraw.Draw(frame)\n            # w, h = draw.textsize(text[index])\n            draw.text(xy, text[index], font=font, fill=color)\n            if add_progress_bar:\n                draw.rectangle(progress_bar_shapes[index], fill=progress_bar_color)\n            del draw\n\n            b = io.BytesIO()\n            frame.save(b, format=\"GIF\")\n            frame = Image.open(b)\n\n            frames.append(frame)\n        # https://www.pythoninformer.com/python-libraries/pillow/creating-animated-gif/\n        # Save the frames as a new image\n\n        frames[0].save(\n            out_gif,\n            save_all=True,\n            append_images=frames[1:],\n            duration=duration,\n            loop=loop,\n            optimize=True,\n        )\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#beamgis.common.adjust_longitude","title":"<code>adjust_longitude(in_fc)</code>","text":"<p>Adjusts longitude if it is less than -180 or greater than 180.</p> <p>Parameters:</p> Name Type Description Default <code>in_fc</code> <code>dict</code> <p>The input dictionary containing coordinates.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the converted longitudes</p> Source code in <code>beamgis/common.py</code> <pre><code>def adjust_longitude(in_fc):\n    \"\"\"Adjusts longitude if it is less than -180 or greater than 180.\n\n    Args:\n        in_fc (dict): The input dictionary containing coordinates.\n\n    Returns:\n        dict: A dictionary containing the converted longitudes\n    \"\"\"\n    try:\n        keys = in_fc.keys()\n\n        if \"geometry\" in keys:\n            coordinates = in_fc[\"geometry\"][\"coordinates\"]\n\n            if in_fc[\"geometry\"][\"type\"] == \"Point\":\n                longitude = coordinates[0]\n                if longitude &lt; -180:\n                    longitude = 360 + longitude\n                elif longitude &gt; 180:\n                    longitude = longitude - 360\n                in_fc[\"geometry\"][\"coordinates\"][0] = longitude\n\n            elif in_fc[\"geometry\"][\"type\"] == \"Polygon\":\n                for index1, item in enumerate(coordinates):\n                    for index2, element in enumerate(item):\n                        longitude = element[0]\n                        if longitude &lt; -180:\n                            longitude = 360 + longitude\n                        elif longitude &gt; 180:\n                            longitude = longitude - 360\n                        in_fc[\"geometry\"][\"coordinates\"][index1][index2][0] = longitude\n\n            elif in_fc[\"geometry\"][\"type\"] == \"LineString\":\n                for index, element in enumerate(coordinates):\n                    longitude = element[0]\n                    if longitude &lt; -180:\n                        longitude = 360 + longitude\n                    elif longitude &gt; 180:\n                        longitude = longitude - 360\n                    in_fc[\"geometry\"][\"coordinates\"][index][0] = longitude\n\n        elif \"type\" in keys:\n            coordinates = in_fc[\"coordinates\"]\n\n            if in_fc[\"type\"] == \"Point\":\n                longitude = coordinates[0]\n                if longitude &lt; -180:\n                    longitude = 360 + longitude\n                elif longitude &gt; 180:\n                    longitude = longitude - 360\n                in_fc[\"coordinates\"][0] = longitude\n\n            elif in_fc[\"type\"] == \"Polygon\":\n                for index1, item in enumerate(coordinates):\n                    for index2, element in enumerate(item):\n                        longitude = element[0]\n                        if longitude &lt; -180:\n                            longitude = 360 + longitude\n                        elif longitude &gt; 180:\n                            longitude = longitude - 360\n                        in_fc[\"coordinates\"][index1][index2][0] = longitude\n\n            elif in_fc[\"type\"] == \"LineString\":\n                for index, element in enumerate(coordinates):\n                    longitude = element[0]\n                    if longitude &lt; -180:\n                        longitude = 360 + longitude\n                    elif longitude &gt; 180:\n                        longitude = longitude - 360\n                    in_fc[\"coordinates\"][index][0] = longitude\n\n        return in_fc\n\n    except Exception as e:\n        print(e)\n        return None\n</code></pre>"},{"location":"common/#beamgis.common.arc_active_map","title":"<code>arc_active_map()</code>","text":"<p>Get the active map in ArcGIS Pro.</p> <p>Returns:</p> Type Description <code>arcpy.Map</code> <p>The active map in ArcGIS Pro.</p> Source code in <code>beamgis/common.py</code> <pre><code>def arc_active_map():\n    \"\"\"Get the active map in ArcGIS Pro.\n\n    Returns:\n        arcpy.Map: The active map in ArcGIS Pro.\n    \"\"\"\n    if is_arcpy():\n        import arcpy  # pylint: disable=E0401\n\n        aprx = arcpy.mp.ArcGISProject(\"CURRENT\")\n        m = aprx.activeMap\n        return m\n    else:\n        return None\n</code></pre>"},{"location":"common/#beamgis.common.arc_active_view","title":"<code>arc_active_view()</code>","text":"<p>Get the active view in ArcGIS Pro.</p> <p>Returns:</p> Type Description <code>arcpy.MapView</code> <p>The active view in ArcGIS Pro.</p> Source code in <code>beamgis/common.py</code> <pre><code>def arc_active_view():\n    \"\"\"Get the active view in ArcGIS Pro.\n\n    Returns:\n        arcpy.MapView: The active view in ArcGIS Pro.\n    \"\"\"\n    if is_arcpy():\n        import arcpy  # pylint: disable=E0401\n\n        aprx = arcpy.mp.ArcGISProject(\"CURRENT\")\n        view = aprx.activeView\n        return view\n    else:\n        return None\n</code></pre>"},{"location":"common/#beamgis.common.arc_add_layer","title":"<code>arc_add_layer(url, name=None, shown=True, opacity=1.0)</code>","text":"<p>Add a layer to the active map in ArcGIS Pro.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the tile layer to add.</p> required <code>name</code> <code>str</code> <p>The name of the layer. Defaults to None.</p> <code>None</code> <code>shown</code> <code>bool</code> <p>Whether the layer is shown. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.0.</p> <code>1.0</code> Source code in <code>beamgis/common.py</code> <pre><code>def arc_add_layer(url, name=None, shown=True, opacity=1.0):\n    \"\"\"Add a layer to the active map in ArcGIS Pro.\n\n    Args:\n        url (str): The URL of the tile layer to add.\n        name (str, optional): The name of the layer. Defaults to None.\n        shown (bool, optional): Whether the layer is shown. Defaults to True.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n    \"\"\"\n    if is_arcpy():\n        m = arc_active_map()\n        if m is not None:\n            m.addDataFromPath(url)\n            if isinstance(name, str):\n                layers = m.listLayers(\"Tiled service layer\")\n                if len(layers) &gt; 0:\n                    layer = layers[0]\n                    layer.name = name\n                    layer.visible = shown\n                    layer.transparency = 100 - (opacity * 100)\n</code></pre>"},{"location":"common/#beamgis.common.arc_zoom_to_bounds","title":"<code>arc_zoom_to_bounds(bounds)</code>","text":"<p>Zoom to a bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list</code> <p>The bounding box to zoom to in the form [xmin, ymin, xmax, ymax] or [(ymin, xmin), (ymax, xmax)].</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>description</p> Source code in <code>beamgis/common.py</code> <pre><code>def arc_zoom_to_bounds(bounds):\n    \"\"\"Zoom to a bounding box.\n\n    Args:\n        bounds (list): The bounding box to zoom to in the form [xmin, ymin, xmax, ymax] or [(ymin, xmin), (ymax, xmax)].\n\n    Raises:\n        ValueError: _description_\n    \"\"\"\n\n    if len(bounds) == 4:\n        xmin, ymin, xmax, ymax = bounds\n    elif len(bounds) == 2:\n        (ymin, xmin), (ymax, xmax) = bounds\n    else:\n        raise ValueError(\"bounds must be a tuple of length 2 or 4.\")\n\n    arc_zoom_to_extent(xmin, ymin, xmax, ymax)\n</code></pre>"},{"location":"common/#beamgis.common.arc_zoom_to_extent","title":"<code>arc_zoom_to_extent(xmin, ymin, xmax, ymax)</code>","text":"<p>Zoom to an extent in ArcGIS Pro.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float</code> <p>The minimum x value of the extent.</p> required <code>ymin</code> <code>float</code> <p>The minimum y value of the extent.</p> required <code>xmax</code> <code>float</code> <p>The maximum x value of the extent.</p> required <code>ymax</code> <code>float</code> <p>The maximum y value of the extent.</p> required Source code in <code>beamgis/common.py</code> <pre><code>def arc_zoom_to_extent(xmin, ymin, xmax, ymax):\n    \"\"\"Zoom to an extent in ArcGIS Pro.\n\n    Args:\n        xmin (float): The minimum x value of the extent.\n        ymin (float): The minimum y value of the extent.\n        xmax (float): The maximum x value of the extent.\n        ymax (float): The maximum y value of the extent.\n    \"\"\"\n    if is_arcpy():\n        import arcpy  # pylint: disable=E0401\n\n        view = arc_active_view()\n        if view is not None:\n            view.camera.setExtent(\n                arcpy.Extent(\n                    xmin,\n                    ymin,\n                    xmax,\n                    ymax,\n                    spatial_reference=arcpy.SpatialReference(4326),\n                )\n            )\n\n        # if isinstance(zoom, int):\n        #     scale = 156543.04 * math.cos(0) / math.pow(2, zoom)\n        #     view.camera.scale = scale  # Not working properly\n</code></pre>"},{"location":"common/#beamgis.common.array_to_image","title":"<code>array_to_image(array, output=None, source=None, dtype=None, compress='deflate', transpose=True, cellsize=None, crs=None, transform=None, driver='COG', colormap=None, **kwargs)</code>","text":"<p>Save a NumPy array as a GeoTIFF using the projection information from an existing GeoTIFF file.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>np.ndarray</code> <p>The NumPy array to be saved as a GeoTIFF.</p> required <code>output</code> <code>str</code> <p>The path to the output image. If None, a temporary file will be created. Defaults to None.</p> <code>None</code> <code>source</code> <code>str</code> <p>The path to an existing GeoTIFF file with map projection information. Defaults to None.</p> <code>None</code> <code>dtype</code> <code>np.dtype</code> <p>The data type of the output array. Defaults to None.</p> <code>None</code> <code>compress</code> <code>str</code> <p>The compression method. Can be one of the following: \"deflate\", \"lzw\", \"packbits\", \"jpeg\". Defaults to \"deflate\".</p> <code>'deflate'</code> <code>transpose</code> <code>bool</code> <p>Whether to transpose the array from (bands, rows, columns) to (rows, columns, bands). Defaults to True.</p> <code>True</code> <code>cellsize</code> <code>float</code> <p>The resolution of the output image in meters. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The CRS of the output image. Defaults to None.</p> <code>None</code> <code>transform</code> <code>tuple</code> <p>The affine transformation matrix, can be rio.transform() or a tuple like (0.5, 0.0, -180.25, 0.0, -0.5, 83.780361). Defaults to None.</p> <code>None</code> <code>driver</code> <code>str</code> <p>The driver to use for creating the output file, such as 'GTiff'. Defaults to \"COG\".</p> <code>'COG'</code> <code>colormap</code> <code>dict</code> <p>A dictionary defining the colormap (value: (R, G, B, A)).</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the rasterio.open() function.</p> <code>{}</code> Source code in <code>beamgis/common.py</code> <pre><code>def array_to_image(\n    array,\n    output: str = None,\n    source: str = None,\n    dtype: str = None,\n    compress: str = \"deflate\",\n    transpose: bool = True,\n    cellsize: float = None,\n    crs: str = None,\n    transform: tuple = None,\n    driver: str = \"COG\",\n    colormap: dict = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Save a NumPy array as a GeoTIFF using the projection information from an existing GeoTIFF file.\n\n    Args:\n        array (np.ndarray): The NumPy array to be saved as a GeoTIFF.\n        output (str): The path to the output image. If None, a temporary file will be created. Defaults to None.\n        source (str, optional): The path to an existing GeoTIFF file with map projection information. Defaults to None.\n        dtype (np.dtype, optional): The data type of the output array. Defaults to None.\n        compress (str, optional): The compression method. Can be one of the following: \"deflate\", \"lzw\", \"packbits\", \"jpeg\". Defaults to \"deflate\".\n        transpose (bool, optional): Whether to transpose the array from (bands, rows, columns) to (rows, columns, bands). Defaults to True.\n        cellsize (float, optional): The resolution of the output image in meters. Defaults to None.\n        crs (str, optional): The CRS of the output image. Defaults to None.\n        transform (tuple, optional): The affine transformation matrix, can be rio.transform() or a tuple like (0.5, 0.0, -180.25, 0.0, -0.5, 83.780361).\n            Defaults to None.\n        driver (str, optional): The driver to use for creating the output file, such as 'GTiff'. Defaults to \"COG\".\n        colormap (dict, optional): A dictionary defining the colormap (value: (R, G, B, A)).\n        **kwargs: Additional keyword arguments to be passed to the rasterio.open() function.\n    \"\"\"\n\n    import numpy as np\n    import rasterio\n    import xarray as xr\n    import rioxarray\n    from rasterio.transform import Affine\n\n    if output is None:\n        return array_to_memory_file(\n            array,\n            source,\n            dtype,\n            compress,\n            transpose,\n            cellsize,\n            crs=crs,\n            transform=transform,\n            driver=driver,\n            colormap=colormap,\n            **kwargs,\n        )\n\n    if isinstance(array, xr.DataArray):\n        if (\n            hasattr(array, \"rio\")\n            and (array.rio.crs is not None)\n            and (array.rio.transform() is not None)\n        ):\n\n            if \"latitude\" in array.dims and \"longitude\" in array.dims:\n                array = array.rename({\"latitude\": \"y\", \"longitude\": \"x\"})\n            elif \"lat\" in array.dims and \"lon\" in array.dims:\n                array = array.rename({\"lat\": \"y\", \"lon\": \"x\"})\n\n            if array.ndim == 2 and (\"x\" in array.dims) and (\"y\" in array.dims):\n                array = array.transpose(\"y\", \"x\")\n            elif array.ndim == 3 and (\"x\" in array.dims) and (\"y\" in array.dims):\n                dims = list(array.dims)\n                dims.remove(\"x\")\n                dims.remove(\"y\")\n                array = array.transpose(dims[0], \"y\", \"x\")\n            if \"long_name\" in array.attrs:\n                array.attrs.pop(\"long_name\")\n\n            array.rio.to_raster(\n                output, driver=driver, compress=compress, dtype=dtype, **kwargs\n            )\n            if colormap:\n                write_image_colormap(output, colormap, output)\n            return output\n\n    if array.ndim == 3 and transpose:\n        array = np.transpose(array, (1, 2, 0))\n\n    out_dir = os.path.dirname(os.path.abspath(output))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    ext = os.path.splitext(output)[-1].lower()\n    if ext == \"\":\n        output += \".tif\"\n        driver = \"COG\"\n    elif ext == \".png\":\n        driver = \"PNG\"\n    elif ext == \".jpg\" or ext == \".jpeg\":\n        driver = \"JPEG\"\n    elif ext == \".jp2\":\n        driver = \"JP2OpenJPEG\"\n    elif ext == \".tiff\":\n        driver = \"GTiff\"\n    else:\n        driver = \"COG\"\n\n    if source is not None:\n        with rasterio.open(source) as src:\n            crs = src.crs\n            transform = src.transform\n            if compress is None:\n                compress = src.compression\n    else:\n        if cellsize is None:\n            raise ValueError(\"resolution must be provided if source is not provided\")\n        if crs is None:\n            raise ValueError(\n                \"crs must be provided if source is not provided, such as EPSG:3857\"\n            )\n\n        if transform is None:\n            # Define the geotransformation parameters\n            xmin, ymin, xmax, ymax = (\n                0,\n                0,\n                cellsize * array.shape[1],\n                cellsize * array.shape[0],\n            )\n            transform = rasterio.transform.from_bounds(\n                xmin, ymin, xmax, ymax, array.shape[1], array.shape[0]\n            )\n        elif isinstance(transform, Affine):\n            pass\n        elif isinstance(transform, (tuple, list)):\n            transform = Affine(*transform)\n\n        kwargs[\"transform\"] = transform\n\n    if dtype is None:\n        # Determine the minimum and maximum values in the array\n        min_value = np.min(array)\n        max_value = np.max(array)\n        # Determine the best dtype for the array\n        if min_value &gt;= 0 and max_value &lt;= 1:\n            dtype = np.float32\n        elif min_value &gt;= 0 and max_value &lt;= 255:\n            dtype = np.uint8\n        elif min_value &gt;= -128 and max_value &lt;= 127:\n            dtype = np.int8\n        elif min_value &gt;= 0 and max_value &lt;= 65535:\n            dtype = np.uint16\n        elif min_value &gt;= -32768 and max_value &lt;= 32767:\n            dtype = np.int16\n        else:\n            dtype = np.float64\n\n    # Convert the array to the best dtype\n    array = array.astype(dtype)\n\n    # Define the GeoTIFF metadata\n    metadata = {\n        \"driver\": driver,\n        \"height\": array.shape[0],\n        \"width\": array.shape[1],\n        \"dtype\": array.dtype,\n        \"crs\": crs,\n        \"transform\": transform,\n    }\n\n    if array.ndim == 2:\n        metadata[\"count\"] = 1\n    elif array.ndim == 3:\n        metadata[\"count\"] = array.shape[2]\n    if compress is not None and (driver in [\"GTiff\", \"COG\"]):\n        metadata[\"compress\"] = compress\n\n    metadata.update(**kwargs)\n    # Create a new GeoTIFF file and write the array to it\n    with rasterio.open(output, \"w\", **metadata) as dst:\n        if array.ndim == 2:\n            dst.write(array, 1)\n            if colormap:\n                dst.write_colormap(1, colormap)\n        elif array.ndim == 3:\n            for i in range(array.shape[2]):\n                dst.write(array[:, :, i], i + 1)\n                if colormap:\n                    dst.write_colormap(i + 1, colormap)\n    return output\n</code></pre>"},{"location":"common/#beamgis.common.array_to_memory_file","title":"<code>array_to_memory_file(array, source=None, dtype=None, compress='deflate', transpose=True, cellsize=None, crs=None, transform=None, driver='COG', colormap=None, **kwargs)</code>","text":"<p>Convert a NumPy array to a memory file.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>numpy.ndarray</code> <p>The input NumPy array.</p> required <code>source</code> <code>str</code> <p>Path to the source file to extract metadata from. Defaults to None.</p> <code>None</code> <code>dtype</code> <code>str</code> <p>The desired data type of the array. Defaults to None.</p> <code>None</code> <code>compress</code> <code>str</code> <p>The compression method for the output file. Defaults to \"deflate\".</p> <code>'deflate'</code> <code>transpose</code> <code>bool</code> <p>Whether to transpose the array from (bands, rows, columns) to (rows, columns, bands). Defaults to True.</p> <code>True</code> <code>cellsize</code> <code>float</code> <p>The cell size of the array if source is not provided. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The coordinate reference system of the array if source is not provided. Defaults to None.</p> <code>None</code> <code>transform</code> <code>tuple</code> <p>The affine transformation matrix if source is not provided. Can be rio.transform() or a tuple like (0.5, 0.0, -180.25, 0.0, -0.5, 83.780361). Defaults to None.</p> <code>None</code> <code>driver</code> <code>str</code> <p>The driver to use for creating the output file, such as 'GTiff'. Defaults to \"COG\".</p> <code>'COG'</code> <code>colormap</code> <code>dict</code> <p>A dictionary defining the colormap (value: (R, G, B, A)).</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the rasterio.open() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>rasterio.DatasetReader</code> <p>The rasterio dataset reader object for the converted array.</p> Source code in <code>beamgis/common.py</code> <pre><code>def array_to_memory_file(\n    array,\n    source: str = None,\n    dtype: str = None,\n    compress: str = \"deflate\",\n    transpose: bool = True,\n    cellsize: float = None,\n    crs: str = None,\n    transform: tuple = None,\n    driver=\"COG\",\n    colormap: dict = None,\n    **kwargs,\n):\n    \"\"\"Convert a NumPy array to a memory file.\n\n    Args:\n        array (numpy.ndarray): The input NumPy array.\n        source (str, optional): Path to the source file to extract metadata from. Defaults to None.\n        dtype (str, optional): The desired data type of the array. Defaults to None.\n        compress (str, optional): The compression method for the output file. Defaults to \"deflate\".\n        transpose (bool, optional): Whether to transpose the array from (bands, rows, columns) to (rows, columns, bands). Defaults to True.\n        cellsize (float, optional): The cell size of the array if source is not provided. Defaults to None.\n        crs (str, optional): The coordinate reference system of the array if source is not provided. Defaults to None.\n        transform (tuple, optional): The affine transformation matrix if source is not provided.\n            Can be rio.transform() or a tuple like (0.5, 0.0, -180.25, 0.0, -0.5, 83.780361). Defaults to None.\n        driver (str, optional): The driver to use for creating the output file, such as 'GTiff'. Defaults to \"COG\".\n        colormap (dict, optional): A dictionary defining the colormap (value: (R, G, B, A)).\n        **kwargs: Additional keyword arguments to be passed to the rasterio.open() function.\n\n    Returns:\n        rasterio.DatasetReader: The rasterio dataset reader object for the converted array.\n    \"\"\"\n    import rasterio\n    import numpy as np\n    import xarray as xr\n    from rasterio.transform import Affine\n\n    if isinstance(array, xr.DataArray):\n        coords = [coord for coord in array.coords]\n        if coords[0] == \"time\":\n            x_dim = coords[1]\n            y_dim = coords[2]\n            array = (\n                array.isel(time=0).rename({y_dim: \"y\", x_dim: \"x\"}).transpose(\"y\", \"x\")\n            )\n        if hasattr(array, \"rio\"):\n            if hasattr(array.rio, \"crs\"):\n                if array.rio.crs is not None:\n                    crs = array.rio.crs\n            if transform is None and hasattr(array.rio, \"transform\"):\n                transform = array.rio.transform()\n        elif source is None:\n            if hasattr(array, \"encoding\"):\n                if \"source\" in array.encoding:\n                    source = array.encoding[\"source\"]\n        array = array.values\n\n    if array.ndim == 3 and transpose:\n        array = np.transpose(array, (1, 2, 0))\n    if source is not None:\n        with rasterio.open(source) as src:\n            crs = src.crs\n            transform = src.transform\n            if compress is None:\n                compress = src.compression\n    else:\n        if crs is None:\n            raise ValueError(\n                \"crs must be provided if source is not provided, such as EPSG:3857\"\n            )\n\n        if transform is None:\n            if cellsize is None:\n                raise ValueError(\"cellsize must be provided if source is not provided\")\n            # Define the geotransformation parameters\n            xmin, ymin, xmax, ymax = (\n                0,\n                0,\n                cellsize * array.shape[1],\n                cellsize * array.shape[0],\n            )\n            # (west, south, east, north, width, height)\n            transform = rasterio.transform.from_bounds(\n                xmin, ymin, xmax, ymax, array.shape[1], array.shape[0]\n            )\n        elif isinstance(transform, Affine):\n            pass\n        elif isinstance(transform, (tuple, list)):\n            transform = Affine(*transform)\n\n        kwargs[\"transform\"] = transform\n\n    if dtype is None:\n        # Determine the minimum and maximum values in the array\n        min_value = np.min(array)\n        max_value = np.max(array)\n        # Determine the best dtype for the array\n        if min_value &gt;= 0 and max_value &lt;= 1:\n            dtype = np.float32\n        elif min_value &gt;= 0 and max_value &lt;= 255:\n            dtype = np.uint8\n        elif min_value &gt;= -128 and max_value &lt;= 127:\n            dtype = np.int8\n        elif min_value &gt;= 0 and max_value &lt;= 65535:\n            dtype = np.uint16\n        elif min_value &gt;= -32768 and max_value &lt;= 32767:\n            dtype = np.int16\n        else:\n            dtype = np.float64\n\n    # Convert the array to the best dtype\n    array = array.astype(dtype)\n    # Define the GeoTIFF metadata\n    metadata = {\n        \"driver\": driver,\n        \"height\": array.shape[0],\n        \"width\": array.shape[1],\n        \"dtype\": array.dtype,\n        \"crs\": crs,\n        \"transform\": transform,\n    }\n\n    if array.ndim == 2:\n        metadata[\"count\"] = 1\n    elif array.ndim == 3:\n        metadata[\"count\"] = array.shape[2]\n    if compress is not None:\n        metadata[\"compress\"] = compress\n\n    metadata.update(**kwargs)\n\n    # Create a new memory file and write the array to it\n    memory_file = rasterio.MemoryFile()\n    dst = memory_file.open(**metadata)\n\n    if array.ndim == 2:\n        dst.write(array, 1)\n        if colormap:\n            dst.write_colormap(1, colormap)\n    elif array.ndim == 3:\n        for i in range(array.shape[2]):\n            dst.write(array[:, :, i], i + 1)\n            if colormap:\n                dst.write_colormap(i + 1, colormap)\n\n    dst.close()\n    # Read the dataset from memory\n    dataset_reader = rasterio.open(dst.name, mode=\"r\")\n\n    return dataset_reader\n</code></pre>"},{"location":"common/#beamgis.common.assign_continuous_colors","title":"<code>assign_continuous_colors(df, column, cmap=None, colors=None, labels=None, scheme='Quantiles', k=5, legend_kwds=None, classification_kwds=None, to_rgb=True, return_type='array', return_legend=False)</code>","text":"<p>Assigns continuous colors to a DataFrame column based on a specified scheme.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>A pandas DataFrame.</p> required <code>column</code> <code>str</code> <p>The name of the column to assign colors.</p> required <code>cmap</code> <code>str</code> <p>The name of the colormap to use.</p> <code>None</code> <code>colors</code> <code>list</code> <p>A list of custom colors.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of custom labels for the legend.</p> <code>None</code> <code>scheme</code> <code>str</code> <p>The scheme for classifying the data. Default is 'Quantiles'.</p> <code>'Quantiles'</code> <code>k</code> <code>int</code> <p>The number of classes for classification.</p> <code>5</code> <code>legend_kwds</code> <code>dict</code> <p>Additional keyword arguments for configuring the legend.</p> <code>None</code> <code>classification_kwds</code> <code>dict</code> <p>Additional keyword arguments for configuring the classification.</p> <code>None</code> <code>to_rgb</code> <code>bool</code> <p>Whether to convert colors to RGB values. Default is True.</p> <code>True</code> <code>return_type</code> <code>str</code> <p>The type of the returned values. Default is 'array'.</p> <code>'array'</code> <code>return_legend</code> <code>bool</code> <p>Whether to return the legend. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[numpy.ndarray, Tuple[numpy.ndarray, dict]]</code> <p>The assigned colors as a numpy array or a tuple containing the colors and the legend, depending on the value of return_legend.</p> Source code in <code>beamgis/common.py</code> <pre><code>def assign_continuous_colors(\n    df,\n    column: str,\n    cmap: str = None,\n    colors: list = None,\n    labels: list = None,\n    scheme: str = \"Quantiles\",\n    k: int = 5,\n    legend_kwds: dict = None,\n    classification_kwds: dict = None,\n    to_rgb: bool = True,\n    return_type: str = \"array\",\n    return_legend: bool = False,\n) -&gt; Union[np.ndarray, Tuple[np.ndarray, dict]]:\n    \"\"\"Assigns continuous colors to a DataFrame column based on a specified scheme.\n\n    Args:\n        df: A pandas DataFrame.\n        column: The name of the column to assign colors.\n        cmap: The name of the colormap to use.\n        colors: A list of custom colors.\n        labels: A list of custom labels for the legend.\n        scheme: The scheme for classifying the data. Default is 'Quantiles'.\n        k: The number of classes for classification.\n        legend_kwds: Additional keyword arguments for configuring the legend.\n        classification_kwds: Additional keyword arguments for configuring the classification.\n        to_rgb: Whether to convert colors to RGB values. Default is True.\n        return_type: The type of the returned values. Default is 'array'.\n        return_legend: Whether to return the legend. Default is False.\n\n    Returns:\n        The assigned colors as a numpy array or a tuple containing the colors and the legend, depending on the value of return_legend.\n    \"\"\"\n    import numpy as np\n\n    data = df[[column]].copy()\n    new_df, legend = classify(\n        data, column, cmap, colors, labels, scheme, k, legend_kwds, classification_kwds\n    )\n    values = new_df[\"color\"].values.tolist()\n\n    if to_rgb:\n        values = [hex_to_rgb(check_color(color)) for color in values]\n        if return_type == \"array\":\n            values = np.array(values, dtype=np.uint8)\n\n    if return_legend:\n        return values, legend\n    else:\n        return values\n</code></pre>"},{"location":"common/#beamgis.common.assign_discrete_colors","title":"<code>assign_discrete_colors(df, column, cmap, to_rgb=True, return_type='array')</code>","text":"<p>Assigns unique colors to each category in a categorical column of a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>The input dataframe.</p> required <code>column</code> <code>str</code> <p>The name of the categorical column.</p> required <code>cmap</code> <code>dict</code> <p>A dictionary mapping categories to colors.</p> required <code>to_rgb</code> <code>bool</code> <p>Whether to convert the colors to RGB values. Defaults to True.</p> <code>True</code> <code>return_type</code> <code>str</code> <p>The type of the returned values. Can be 'list' or 'array'. Defaults to 'array'.</p> <code>'array'</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of colors for each category in the categorical column.</p> Source code in <code>beamgis/common.py</code> <pre><code>def assign_discrete_colors(df, column, cmap, to_rgb=True, return_type=\"array\"):\n    \"\"\"\n    Assigns unique colors to each category in a categorical column of a dataframe.\n\n    Args:\n        df (pandas.DataFrame): The input dataframe.\n        column (str): The name of the categorical column.\n        cmap (dict): A dictionary mapping categories to colors.\n        to_rgb (bool): Whether to convert the colors to RGB values. Defaults to True.\n        return_type (str): The type of the returned values. Can be 'list' or 'array'. Defaults to 'array'.\n\n    Returns:\n        list: A list of colors for each category in the categorical column.\n    \"\"\"\n    import numpy as np\n\n    # Copy the categorical column from the original dataframe\n    category_column = df[column].copy()\n\n    # Map colors to the categorical values\n    category_column = category_column.map(cmap)\n\n    values = category_column.values.tolist()\n\n    if to_rgb:\n        values = [hex_to_rgb(check_color(color)) for color in values]\n        if return_type == \"array\":\n            values = np.array(values, dtype=np.uint8)\n\n    return values\n</code></pre>"},{"location":"common/#beamgis.common.basemap_xyz_tiles","title":"<code>basemap_xyz_tiles()</code>","text":"<p>Returns a dictionary containing a set of basemaps that are XYZ tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of XYZ tile layers.</p> Source code in <code>beamgis/common.py</code> <pre><code>def basemap_xyz_tiles():\n    \"\"\"Returns a dictionary containing a set of basemaps that are XYZ tile layers.\n\n    Returns:\n        dict: A dictionary of XYZ tile layers.\n    \"\"\"\n    from .leafmap import basemaps\n\n    layers_dict = {}\n    keys = dict(basemaps).keys()\n    for key in keys:\n        if isinstance(basemaps[key], ipyleaflet.WMSLayer):\n            pass\n        else:\n            layers_dict[key] = basemaps[key]\n    return layers_dict\n</code></pre>"},{"location":"common/#beamgis.common.bbox_to_gdf","title":"<code>bbox_to_gdf(bbox, crs='epsg:4326')</code>","text":"<p>Convert a bounding box to a GeoPandas GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list</code> <p>A bounding box in the format of [minx, miny, maxx, maxy].</p> required <code>crs</code> <code>str</code> <p>The CRS of the bounding box. Defaults to 'epsg:4326'.</p> <code>'epsg:4326'</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame with a single polygon.</p> Source code in <code>beamgis/common.py</code> <pre><code>def bbox_to_gdf(bbox, crs=\"epsg:4326\"):\n    \"\"\"Convert a bounding box to a GeoPandas GeoDataFrame.\n\n    Args:\n        bbox (list): A bounding box in the format of [minx, miny, maxx, maxy].\n        crs (str, optional): The CRS of the bounding box. Defaults to 'epsg:4326'.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame with a single polygon.\n    \"\"\"\n    import geopandas as gpd\n    from shapely.geometry import Polygon\n\n    return gpd.GeoDataFrame(\n        geometry=[Polygon.from_bounds(*bbox)],\n        crs=crs,\n    )\n</code></pre>"},{"location":"common/#beamgis.common.bbox_to_geojson","title":"<code>bbox_to_geojson(bounds)</code>","text":"<p>Convert coordinates of a bounding box to a geojson.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list | tuple</code> <p>A list of coordinates representing [left, bottom, right, top] or m.bounds.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A geojson feature.</p> Source code in <code>beamgis/common.py</code> <pre><code>def bbox_to_geojson(bounds):\n    \"\"\"Convert coordinates of a bounding box to a geojson.\n\n    Args:\n        bounds (list | tuple): A list of coordinates representing [left, bottom, right, top] or m.bounds.\n\n    Returns:\n        dict: A geojson feature.\n    \"\"\"\n\n    if isinstance(bounds, tuple) and len(bounds) == 2:\n        bounds = [bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]]\n\n    return {\n        \"geometry\": {\n            \"type\": \"Polygon\",\n            \"coordinates\": [\n                [\n                    [bounds[0], bounds[3]],\n                    [bounds[0], bounds[1]],\n                    [bounds[2], bounds[1]],\n                    [bounds[2], bounds[3]],\n                    [bounds[0], bounds[3]],\n                ]\n            ],\n        },\n        \"type\": \"Feature\",\n    }\n</code></pre>"},{"location":"common/#beamgis.common.bbox_to_polygon","title":"<code>bbox_to_polygon(bbox)</code>","text":"<p>Convert a bounding box to a shapely Polygon.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list</code> <p>A bounding box in the format of [minx, miny, maxx, maxy].</p> required <p>Returns:</p> Type Description <code>Polygon</code> <p>A shapely Polygon.</p> Source code in <code>beamgis/common.py</code> <pre><code>def bbox_to_polygon(bbox):\n    \"\"\"Convert a bounding box to a shapely Polygon.\n\n    Args:\n        bbox (list): A bounding box in the format of [minx, miny, maxx, maxy].\n\n    Returns:\n        Polygon: A shapely Polygon.\n    \"\"\"\n    from shapely.geometry import Polygon\n\n    return Polygon.from_bounds(*bbox)\n</code></pre>"},{"location":"common/#beamgis.common.blend_images","title":"<code>blend_images(img1, img2, alpha=0.5, output=False, show=True, figsize=(12, 10), axis='off', **kwargs)</code>","text":"<p>Blends two images together using the addWeighted function from the OpenCV library.</p> <p>Parameters:</p> Name Type Description Default <code>img1</code> <code>numpy.ndarray</code> <p>The first input image on top represented as a NumPy array.</p> required <code>img2</code> <code>numpy.ndarray</code> <p>The second input image at the bottom represented as a NumPy array.</p> required <code>alpha</code> <code>float</code> <p>The weighting factor for the first image in the blend. By default, this is set to 0.5.</p> <code>0.5</code> <code>output</code> <code>str</code> <p>The path to the output image. Defaults to False.</p> <code>False</code> <code>show</code> <code>bool</code> <p>Whether to display the blended image. Defaults to True.</p> <code>True</code> <code>figsize</code> <code>tuple</code> <p>The size of the figure. Defaults to (12, 10).</p> <code>(12, 10)</code> <code>axis</code> <code>str</code> <p>The axis of the figure. Defaults to \"off\".</p> <code>'off'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the cv2.addWeighted() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>The blended image as a NumPy array.</p> Source code in <code>beamgis/common.py</code> <pre><code>def blend_images(\n    img1,\n    img2,\n    alpha=0.5,\n    output=False,\n    show=True,\n    figsize=(12, 10),\n    axis=\"off\",\n    **kwargs,\n):\n    \"\"\"\n    Blends two images together using the addWeighted function from the OpenCV library.\n\n    Args:\n        img1 (numpy.ndarray): The first input image on top represented as a NumPy array.\n        img2 (numpy.ndarray): The second input image at the bottom represented as a NumPy array.\n        alpha (float): The weighting factor for the first image in the blend. By default, this is set to 0.5.\n        output (str, optional): The path to the output image. Defaults to False.\n        show (bool, optional): Whether to display the blended image. Defaults to True.\n        figsize (tuple, optional): The size of the figure. Defaults to (12, 10).\n        axis (str, optional): The axis of the figure. Defaults to \"off\".\n        **kwargs: Additional keyword arguments to pass to the cv2.addWeighted() function.\n\n    Returns:\n        numpy.ndarray: The blended image as a NumPy array.\n    \"\"\"\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    try:\n        import cv2\n    except ImportError:\n        raise ImportError(\"The blend_images function requires the OpenCV library.\")\n\n    # Resize the images to have the same dimensions\n    if isinstance(img1, str):\n        if img1.startswith(\"http\"):\n            img1 = download_file(img1)\n\n        if not os.path.exists(img1):\n            raise ValueError(f\"Input path {img1} does not exist.\")\n\n        img1 = cv2.imread(img1)\n\n    if isinstance(img2, str):\n        if img2.startswith(\"http\"):\n            img2 = download_file(img2)\n\n        if not os.path.exists(img2):\n            raise ValueError(f\"Input path {img2} does not exist.\")\n\n        img2 = cv2.imread(img2)\n\n    if img1.dtype == np.float32:\n        img1 = (img1 * 255).astype(np.uint8)\n\n    if img2.dtype == np.float32:\n        img2 = (img2 * 255).astype(np.uint8)\n\n    if img1.dtype != img2.dtype:\n        img2 = img2.astype(img1.dtype)\n\n    img1 = cv2.resize(img1, (img2.shape[1], img2.shape[0]))\n\n    # Blend the images using the addWeighted function\n    beta = 1 - alpha\n    blend_img = cv2.addWeighted(img1, alpha, img2, beta, 0, **kwargs)\n\n    if output:\n        array_to_image(blend_img, output, img2)\n\n    if show:\n        plt.figure(figsize=figsize)\n        plt.imshow(blend_img)\n        plt.axis(axis)\n        plt.show()\n    else:\n        return blend_img\n</code></pre>"},{"location":"common/#beamgis.common.bounds_to_xy_range","title":"<code>bounds_to_xy_range(bounds)</code>","text":"<p>Convert bounds to x and y range to be used as input to bokeh map.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Union[List[Union[Tuple[float, float], float]], Tuple[float, float, float, float]]</code> <p>A list of bounds in the form [(south, west), (north, east)] or [xmin, ymin, xmax, ymax].</p> required <p>Returns:</p> Type Description <code>Tuple[Tuple[float, float], Tuple[float, float]]</code> <p>A tuple of (x_range, y_range).</p> Source code in <code>beamgis/common.py</code> <pre><code>def bounds_to_xy_range(\n    bounds: Union[\n        List[Union[Tuple[float, float], float]], Tuple[float, float, float, float]\n    ],\n) -&gt; Tuple[Tuple[float, float], Tuple[float, float]]:\n    \"\"\"\n    Convert bounds to x and y range to be used as input to bokeh map.\n\n    Args:\n        bounds (Union[List[Union[Tuple[float, float], float]], Tuple[float, float, float, float]]):\n            A list of bounds in the form [(south, west), (north, east)] or [xmin, ymin, xmax, ymax].\n\n    Returns:\n        Tuple[Tuple[float, float], Tuple[float, float]]: A tuple of (x_range, y_range).\n    \"\"\"\n    if isinstance(bounds, tuple):\n        if len(bounds) != 4:\n            raise ValueError(\n                \"Tuple bounds must have exactly 4 elements (xmin, ymin, xmax, ymax).\"\n            )\n        west, south, east, north = bounds\n    elif isinstance(bounds, list):\n        if len(bounds) == 2 and all(\n            isinstance(coord, tuple) and len(coord) == 2 for coord in bounds\n        ):\n            (south, west), (north, east) = bounds\n        elif len(bounds) == 4 and all(\n            isinstance(coord, (int, float)) for coord in bounds\n        ):\n            west, south, east, north = bounds\n        else:\n            raise ValueError(\n                \"List bounds must be in the form [(south, west), (north, east)] or [xmin, ymin, xmax, ymax].\"\n            )\n    else:\n        raise TypeError(\"bounds must be a list or tuple\")\n\n    xmin, ymin = lnglat_to_meters(west, south)\n    xmax, ymax = lnglat_to_meters(east, north)\n    x_range = (xmin, xmax)\n    y_range = (ymin, ymax)\n    return x_range, y_range\n</code></pre>"},{"location":"common/#beamgis.common.center_zoom_to_xy_range","title":"<code>center_zoom_to_xy_range(center, zoom)</code>","text":"<p>Convert center and zoom to x and y range to be used as input to bokeh map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>A tuple of (latitude, longitude).</p> required <code>zoom</code> <code>int</code> <p>The zoom level.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (x_range, y_range).</p> Source code in <code>beamgis/common.py</code> <pre><code>def center_zoom_to_xy_range(center, zoom):\n    \"\"\"Convert center and zoom to x and y range to be used as input to bokeh map.\n\n    Args:\n        center (tuple): A tuple of (latitude, longitude).\n        zoom (int): The zoom level.\n\n    Returns:\n        tuple: A tuple of (x_range, y_range).\n    \"\"\"\n\n    if isinstance(center, tuple) or isinstance(center, list):\n        pass\n    else:\n        raise TypeError(\"center must be a tuple or list\")\n\n    if not isinstance(zoom, int):\n        raise TypeError(\"zoom must be an integer\")\n\n    latitude, longitude = center\n    x_range = (-179, 179)\n    y_range = (-70, 70)\n    x_full_length = x_range[1] - x_range[0]\n    y_full_length = y_range[1] - y_range[0]\n\n    x_length = x_full_length / 2 ** (zoom - 2)\n    y_length = y_full_length / 2 ** (zoom - 2)\n\n    south = latitude - y_length / 2\n    north = latitude + y_length / 2\n    west = longitude - x_length / 2\n    east = longitude + x_length / 2\n\n    xmin, ymin = lnglat_to_meters(west, south)\n    xmax, ymax = lnglat_to_meters(east, north)\n\n    x_range = (xmin, xmax)\n    y_range = (ymin, ymax)\n\n    return x_range, y_range\n</code></pre>"},{"location":"common/#beamgis.common.cesium_to_streamlit","title":"<code>cesium_to_streamlit(html, width=800, height=600, responsive=True, scrolling=False, token_name=None, token_value=None, **kwargs)</code>","text":"<p>Renders an cesium HTML file in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>The HTML file to render. It can a local file path or a URL.</p> required <code>width</code> <code>int</code> <p>Width of the map. Defaults to 800.</p> <code>800</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>600</code> <code>responsive</code> <code>bool</code> <p>Whether to make the map responsive. Defaults to True.</p> <code>True</code> <code>scrolling</code> <code>bool</code> <p>Whether to allow the map to scroll. Defaults to False.</p> <code>False</code> <code>token_name</code> <code>str</code> <p>The name of the token in the HTML file to be replaced. Defaults to None.</p> <code>None</code> <code>token_value</code> <code>str</code> <p>The value of the token to pass to the HTML file. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>streamlit.components</code> <p>components.html object.</p> Source code in <code>beamgis/common.py</code> <pre><code>def cesium_to_streamlit(\n    html,\n    width=800,\n    height=600,\n    responsive=True,\n    scrolling=False,\n    token_name=None,\n    token_value=None,\n    **kwargs,\n):\n    \"\"\"Renders an cesium HTML file in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.\n\n    Args:\n        html (str): The HTML file to render. It can a local file path or a URL.\n        width (int, optional): Width of the map. Defaults to 800.\n        height (int, optional): Height of the map. Defaults to 600.\n        responsive (bool, optional): Whether to make the map responsive. Defaults to True.\n        scrolling (bool, optional): Whether to allow the map to scroll. Defaults to False.\n        token_name (str, optional): The name of the token in the HTML file to be replaced. Defaults to None.\n        token_value (str, optional): The value of the token to pass to the HTML file. Defaults to None.\n\n    Returns:\n        streamlit.components: components.html object.\n    \"\"\"\n    if token_name is None:\n        token_name = \"your_access_token\"\n\n    if token_value is None:\n        token_value = os.environ.get(\"CESIUM_TOKEN\")\n\n    html_to_streamlit(\n        html, width, height, responsive, scrolling, token_name, token_value\n    )\n</code></pre>"},{"location":"common/#beamgis.common.check_cmap","title":"<code>check_cmap(cmap)</code>","text":"<p>Check the colormap and return a list of colors.</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>str | list | Box</code> <p>The colormap to check.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of colors.</p> Source code in <code>beamgis/common.py</code> <pre><code>def check_cmap(cmap):\n    \"\"\"Check the colormap and return a list of colors.\n\n    Args:\n        cmap (str | list | Box): The colormap to check.\n\n    Returns:\n        list: A list of colors.\n    \"\"\"\n\n    from box import Box\n    from .colormaps import get_palette\n\n    if isinstance(cmap, str):\n        try:\n            return get_palette(cmap)\n        except Exception as e:\n            raise Exception(f\"{cmap} is not a valid colormap.\")\n    elif isinstance(cmap, Box):\n        return list(cmap[\"default\"])\n    elif isinstance(cmap, list) or isinstance(cmap, tuple):\n        return cmap\n    else:\n        raise Exception(f\"{cmap} is not a valid colormap.\")\n</code></pre>"},{"location":"common/#beamgis.common.check_color","title":"<code>check_color(in_color)</code>","text":"<p>Checks the input color and returns the corresponding hex color code.</p> <p>Parameters:</p> Name Type Description Default <code>in_color</code> <code>str or tuple or list</code> <p>It can be a string (e.g., 'red', '#ffff00', 'ffff00', 'ff0') or RGB tuple (e.g., (255, 127, 0)).</p> required <p>Returns:</p> Type Description <code>str</code> <p>A hex color code.</p> Source code in <code>beamgis/common.py</code> <pre><code>def check_color(in_color: Union[str, Tuple]) -&gt; str:\n    \"\"\"Checks the input color and returns the corresponding hex color code.\n\n    Args:\n            in_color (str or tuple or list): It can be a string (e.g., 'red', '#ffff00', 'ffff00', 'ff0') or RGB tuple (e.g., (255, 127, 0)).\n\n    Returns:\n        str: A hex color code.\n    \"\"\"\n    import colour\n\n    out_color = \"#000000\"  # default black color\n    if (isinstance(in_color, tuple) or isinstance(in_color, list)) and len(\n        in_color\n    ) == 3:\n        # rescale color if necessary\n        if all(isinstance(item, int) for item in in_color):\n            in_color = [c / 255.0 for c in in_color]\n\n        return colour.Color(rgb=tuple(in_color)).hex_l\n\n    else:\n        # try to guess the color system\n        try:\n            return colour.Color(in_color).hex_l\n\n        except Exception as e:\n            pass\n\n        # try again by adding an extra # (GEE handle hex codes without #)\n        try:\n            return colour.Color(f\"#{in_color}\").hex_l\n\n        except Exception as e:\n            print(\n                f\"The provided color ({in_color}) is invalid. Using the default black color.\"\n            )\n            print(e)\n\n        return out_color\n</code></pre>"},{"location":"common/#beamgis.common.check_dir","title":"<code>check_dir(dir_path, make_dirs=True)</code>","text":"<p>Checks if a directory exists and creates it if it does not.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>[str</code> <p>The path to the directory.</p> required <code>make_dirs</code> <code>bool</code> <p>Whether to create the directory if it does not exist. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the directory could not be found.</p> <code>TypeError</code> <p>If the input directory path is not a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The path to the directory.</p> Source code in <code>beamgis/common.py</code> <pre><code>def check_dir(dir_path, make_dirs=True):\n    \"\"\"Checks if a directory exists and creates it if it does not.\n\n    Args:\n        dir_path ([str): The path to the directory.\n        make_dirs (bool, optional): Whether to create the directory if it does not exist. Defaults to True.\n\n    Raises:\n        FileNotFoundError: If the directory could not be found.\n        TypeError: If the input directory path is not a string.\n\n    Returns:\n        str: The path to the directory.\n    \"\"\"\n\n    if isinstance(dir_path, str):\n        if dir_path.startswith(\"~\"):\n            dir_path = os.path.expanduser(dir_path)\n        else:\n            dir_path = os.path.abspath(dir_path)\n\n        if not os.path.exists(dir_path) and make_dirs:\n            os.makedirs(dir_path)\n\n        if os.path.exists(dir_path):\n            return dir_path\n        else:\n            raise FileNotFoundError(\"The provided directory could not be found.\")\n    else:\n        raise TypeError(\"The provided directory path must be a string.\")\n</code></pre>"},{"location":"common/#beamgis.common.check_file_path","title":"<code>check_file_path(file_path, make_dirs=True)</code>","text":"<p>Gets the absolute file path.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file.</p> required <code>make_dirs</code> <code>bool</code> <p>Whether to create the directory if it does not exist. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the directory could not be found.</p> <code>TypeError</code> <p>If the input directory path is not a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The absolute path to the file.</p> Source code in <code>beamgis/common.py</code> <pre><code>def check_file_path(file_path, make_dirs=True):\n    \"\"\"Gets the absolute file path.\n\n    Args:\n        file_path (str): The path to the file.\n        make_dirs (bool, optional): Whether to create the directory if it does not exist. Defaults to True.\n\n    Raises:\n        FileNotFoundError: If the directory could not be found.\n        TypeError: If the input directory path is not a string.\n\n    Returns:\n        str: The absolute path to the file.\n    \"\"\"\n    if isinstance(file_path, str):\n        if file_path.startswith(\"~\"):\n            file_path = os.path.expanduser(file_path)\n        else:\n            file_path = os.path.abspath(file_path)\n\n        file_dir = os.path.dirname(file_path)\n        if not os.path.exists(file_dir) and make_dirs:\n            os.makedirs(file_dir)\n\n        return file_path\n\n    else:\n        raise TypeError(\"The provided file path must be a string.\")\n</code></pre>"},{"location":"common/#beamgis.common.check_html_string","title":"<code>check_html_string(html_string)</code>","text":"<p>Check if an HTML string contains local images and convert them to base64.</p> <p>Parameters:</p> Name Type Description Default <code>html_string</code> <code>str</code> <p>The HTML string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML string with local images converted to base64.</p> Source code in <code>beamgis/common.py</code> <pre><code>def check_html_string(html_string):\n    \"\"\"Check if an HTML string contains local images and convert them to base64.\n\n    Args:\n        html_string (str): The HTML string.\n\n    Returns:\n        str: The HTML string with local images converted to base64.\n    \"\"\"\n    import re\n    import base64\n\n    # Search for img tags with src attribute\n    img_regex = r'&lt;img[^&gt;]+src\\s*=\\s*[\"\\']([^\"\\':]+)[\"\\'][^&gt;]*&gt;'\n\n    for match in re.findall(img_regex, html_string):\n        with open(match, \"rb\") as img_file:\n            img_data = img_file.read()\n            base64_data = base64.b64encode(img_data).decode(\"utf-8\")\n            html_string = html_string.replace(\n                'src=\"{}\"'.format(match),\n                'src=\"data:image/png;base64,' + base64_data + '\"',\n            )\n\n    return html_string\n</code></pre>"},{"location":"common/#beamgis.common.check_url","title":"<code>check_url(url)</code>","text":"<p>Check if an HTTP URL is working.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the URL is working (returns a 200 status code), False otherwise.</p> Source code in <code>beamgis/common.py</code> <pre><code>def check_url(url: str) -&gt; bool:\n    \"\"\"Check if an HTTP URL is working.\n\n    Args:\n        url (str): The URL to check.\n\n    Returns:\n        bool: True if the URL is working (returns a 200 status code), False otherwise.\n    \"\"\"\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            return True\n        else:\n            return False\n    except requests.exceptions.RequestException:\n        return False\n</code></pre>"},{"location":"common/#beamgis.common.classify","title":"<code>classify(data, column, cmap=None, colors=None, labels=None, scheme='Quantiles', k=5, legend_kwds=None, classification_kwds=None)</code>","text":"<p>Classify a dataframe column using a variety of classification schemes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame | gpd.GeoDataFrame</code> <p>The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.</p> required <code>column</code> <code>str</code> <p>The column to classify.</p> required <code>cmap</code> <code>str</code> <p>The name of a colormap recognized by matplotlib. Defaults to None.</p> <code>None</code> <code>colors</code> <code>list</code> <p>A list of colors to use for the classification. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of labels to use for the legend. Defaults to None.</p> <code>None</code> <code>scheme</code> <code>str</code> <p>Name of a choropleth classification scheme (requires mapclassify). Name of a choropleth classification scheme (requires mapclassify). A mapclassify.MapClassifier object will be used under the hood. Supported are all schemes provided by mapclassify (e.g. 'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled', 'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced', 'JenksCaspallSampled', 'MaxP', 'MaximumBreaks', 'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean', 'UserDefined'). Arguments can be passed in classification_kwds.</p> <code>'Quantiles'</code> <code>k</code> <code>int</code> <p>Number of classes (ignored if scheme is None or if column is categorical). Default to 5.</p> <code>5</code> <code>legend_kwds</code> <code>dict</code> <p>Keyword arguments to pass to :func:<code>matplotlib.pyplot.legend</code> or <code>matplotlib.pyplot.colorbar</code>. Defaults to None. Keyword arguments to pass to :func:<code>matplotlib.pyplot.legend</code> or Additional accepted keywords when <code>scheme</code> is specified: fmt : string     A formatting specification for the bin edges of the classes in the     legend. For example, to have no decimals: <code>{\"fmt\": \"{:.0f}\"}</code>. labels : list-like     A list of legend labels to override the auto-generated labblels.     Needs to have the same number of elements as the number of     classes (<code>k</code>). interval : boolean (default False)     An option to control brackets from mapclassify legend.     If True, open/closed interval brackets are shown in the legend.</p> <code>None</code> <code>classification_kwds</code> <code>dict</code> <p>Keyword arguments to pass to mapclassify. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>pd.DataFrame, dict</code> <p>A pandas dataframe with the classification applied and a legend dictionary.</p> Source code in <code>beamgis/common.py</code> <pre><code>def classify(\n    data,\n    column,\n    cmap=None,\n    colors=None,\n    labels=None,\n    scheme=\"Quantiles\",\n    k=5,\n    legend_kwds=None,\n    classification_kwds=None,\n):\n    \"\"\"Classify a dataframe column using a variety of classification schemes.\n\n    Args:\n        data (str | pd.DataFrame | gpd.GeoDataFrame): The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.\n        column (str): The column to classify.\n        cmap (str, optional): The name of a colormap recognized by matplotlib. Defaults to None.\n        colors (list, optional): A list of colors to use for the classification. Defaults to None.\n        labels (list, optional): A list of labels to use for the legend. Defaults to None.\n        scheme (str, optional): Name of a choropleth classification scheme (requires mapclassify).\n            Name of a choropleth classification scheme (requires mapclassify).\n            A mapclassify.MapClassifier object will be used\n            under the hood. Supported are all schemes provided by mapclassify (e.g.\n            'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled',\n            'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced',\n            'JenksCaspallSampled', 'MaxP', 'MaximumBreaks',\n            'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean',\n            'UserDefined'). Arguments can be passed in classification_kwds.\n        k (int, optional): Number of classes (ignored if scheme is None or if column is categorical). Default to 5.\n        legend_kwds (dict, optional): Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or `matplotlib.pyplot.colorbar`. Defaults to None.\n            Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or\n            Additional accepted keywords when `scheme` is specified:\n            fmt : string\n                A formatting specification for the bin edges of the classes in the\n                legend. For example, to have no decimals: ``{\"fmt\": \"{:.0f}\"}``.\n            labels : list-like\n                A list of legend labels to override the auto-generated labblels.\n                Needs to have the same number of elements as the number of\n                classes (`k`).\n            interval : boolean (default False)\n                An option to control brackets from mapclassify legend.\n                If True, open/closed interval brackets are shown in the legend.\n        classification_kwds (dict, optional): Keyword arguments to pass to mapclassify. Defaults to None.\n\n    Returns:\n        pd.DataFrame, dict: A pandas dataframe with the classification applied and a legend dictionary.\n    \"\"\"\n\n    import numpy as np\n    import pandas as pd\n    import geopandas as gpd\n    import matplotlib as mpl\n    import matplotlib.pyplot as plt\n\n    try:\n        import mapclassify\n    except ImportError:\n        raise ImportError(\n            \"mapclassify is required for this function. Install with `pip install mapclassify`.\"\n        )\n\n    if (\n        isinstance(data, gpd.GeoDataFrame)\n        or isinstance(data, pd.DataFrame)\n        or isinstance(data, pd.Series)\n    ):\n        df = data\n    else:\n        try:\n            df = gpd.read_file(data)\n        except Exception:\n            raise TypeError(\n                \"Data must be a GeoDataFrame or a path to a file that can be read by geopandas.read_file().\"\n            )\n\n    if df.empty:\n        warnings.warn(\n            \"The GeoDataFrame you are attempting to plot is \"\n            \"empty. Nothing has been displayed.\",\n            UserWarning,\n        )\n        return\n\n    columns = df.columns.values.tolist()\n    if column not in columns:\n        raise ValueError(\n            f\"{column} is not a column in the GeoDataFrame. It must be one of {columns}.\"\n        )\n\n    # Convert categorical data to numeric\n    init_column = None\n    value_list = None\n    if np.issubdtype(df[column].dtype, np.object_):\n        value_list = df[column].unique().tolist()\n        value_list.sort()\n        df[\"category\"] = df[column].replace(value_list, range(0, len(value_list)))\n        init_column = column\n        column = \"category\"\n        k = len(value_list)\n\n    if legend_kwds is not None:\n        legend_kwds = legend_kwds.copy()\n\n    # To accept pd.Series and np.arrays as column\n    if isinstance(column, (np.ndarray, pd.Series)):\n        if column.shape[0] != df.shape[0]:\n            raise ValueError(\n                \"The dataframe and given column have different number of rows.\"\n            )\n        else:\n            values = column\n\n            # Make sure index of a Series matches index of df\n            if isinstance(values, pd.Series):\n                values = values.reindex(df.index)\n    else:\n        values = df[column]\n\n    values = df[column]\n    nan_idx = np.asarray(pd.isna(values), dtype=\"bool\")\n\n    if cmap is None:\n        cmap = \"Blues\"\n    try:\n        cmap = plt.get_cmap(cmap, k)\n    except:\n        cmap = plt.cm.get_cmap(cmap, k)\n    if colors is None:\n        colors = [mpl.colors.rgb2hex(cmap(i))[1:] for i in range(cmap.N)]\n        colors = [\"#\" + i for i in colors]\n    elif isinstance(colors, list):\n        colors = [check_color(i) for i in colors]\n    elif isinstance(colors, str):\n        colors = [check_color(colors)] * k\n\n    allowed_schemes = [\n        \"BoxPlot\",\n        \"EqualInterval\",\n        \"FisherJenks\",\n        \"FisherJenksSampled\",\n        \"HeadTailBreaks\",\n        \"JenksCaspall\",\n        \"JenksCaspallForced\",\n        \"JenksCaspallSampled\",\n        \"MaxP\",\n        \"MaximumBreaks\",\n        \"NaturalBreaks\",\n        \"Quantiles\",\n        \"Percentiles\",\n        \"StdMean\",\n        \"UserDefined\",\n    ]\n\n    if scheme.lower() not in [s.lower() for s in allowed_schemes]:\n        raise ValueError(\n            f\"{scheme} is not a valid scheme. It must be one of {allowed_schemes}.\"\n        )\n\n    if classification_kwds is None:\n        classification_kwds = {}\n    if \"k\" not in classification_kwds:\n        classification_kwds[\"k\"] = k\n\n    binning = mapclassify.classify(\n        np.asarray(values[~nan_idx]), scheme, **classification_kwds\n    )\n    df[\"category\"] = binning.yb\n    df[\"color\"] = [colors[i] for i in df[\"category\"]]\n\n    if legend_kwds is None:\n        legend_kwds = {}\n\n    if \"interval\" not in legend_kwds:\n        legend_kwds[\"interval\"] = True\n\n    if \"fmt\" not in legend_kwds:\n        if np.issubdtype(df[column].dtype, np.floating):\n            legend_kwds[\"fmt\"] = \"{:.2f}\"\n        else:\n            legend_kwds[\"fmt\"] = \"{:.0f}\"\n\n    if labels is None:\n        # set categorical to True for creating the legend\n        if legend_kwds is not None and \"labels\" in legend_kwds:\n            if len(legend_kwds[\"labels\"]) != binning.k:\n                raise ValueError(\n                    \"Number of labels must match number of bins, \"\n                    \"received {} labels for {} bins\".format(\n                        len(legend_kwds[\"labels\"]), binning.k\n                    )\n                )\n            else:\n                labels = list(legend_kwds.pop(\"labels\"))\n        else:\n            # fmt = \"{:.2f}\"\n            if legend_kwds is not None and \"fmt\" in legend_kwds:\n                fmt = legend_kwds.pop(\"fmt\")\n\n            labels = binning.get_legend_classes(fmt)\n            if legend_kwds is not None:\n                show_interval = legend_kwds.pop(\"interval\", False)\n            else:\n                show_interval = False\n            if not show_interval:\n                labels = [c[1:-1] for c in labels]\n\n        if init_column is not None:\n            labels = value_list\n    elif isinstance(labels, list):\n        if len(labels) != len(colors):\n            raise ValueError(\"The number of labels must match the number of colors.\")\n    else:\n        raise ValueError(\"labels must be a list or None.\")\n\n    legend_dict = dict(zip(labels, colors))\n    df[\"category\"] = df[\"category\"] + 1\n    return df, legend_dict\n</code></pre>"},{"location":"common/#beamgis.common.clip_image","title":"<code>clip_image(image, mask, output, to_cog=True)</code>","text":"<p>Clip an image by mask.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>Path to the image file in GeoTIFF format.</p> required <code>mask</code> <code>str | list | dict</code> <p>The mask used to extract the image. It can be a path to vector datasets (e.g., GeoJSON, Shapefile), a list of coordinates, or m.user_roi.</p> required <code>output</code> <code>str</code> <p>Path to the output file.</p> required <code>to_cog</code> <code>bool</code> <p>Flags to indicate if you want to convert the output to COG. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the fiona or rasterio package is not installed.</p> <code>FileNotFoundError</code> <p>If the image is not found.</p> <code>ValueError</code> <p>If the mask is not a valid GeoJSON or raster file.</p> <code>FileNotFoundError</code> <p>If the mask file is not found.</p> Source code in <code>beamgis/common.py</code> <pre><code>def clip_image(image, mask, output, to_cog=True):\n    \"\"\"Clip an image by mask.\n\n    Args:\n        image (str): Path to the image file in GeoTIFF format.\n        mask (str | list | dict): The mask used to extract the image. It can be a path to vector datasets (e.g., GeoJSON, Shapefile), a list of coordinates, or m.user_roi.\n        output (str): Path to the output file.\n        to_cog (bool, optional): Flags to indicate if you want to convert the output to COG. Defaults to True.\n\n    Raises:\n        ImportError: If the fiona or rasterio package is not installed.\n        FileNotFoundError: If the image is not found.\n        ValueError: If the mask is not a valid GeoJSON or raster file.\n        FileNotFoundError: If the mask file is not found.\n    \"\"\"\n    try:\n        import json\n        import fiona\n        import rasterio\n        import rasterio.mask\n    except ImportError as e:\n        raise ImportError(e)\n\n    if not os.path.exists(image):\n        raise FileNotFoundError(f\"{image} does not exist.\")\n\n    if not output.endswith(\".tif\"):\n        raise ValueError(\"Output must be a tif file.\")\n\n    output = check_file_path(output)\n\n    if isinstance(mask, str):\n        if mask.startswith(\"http\"):\n            mask = download_file(mask, output)\n        if not os.path.exists(mask):\n            raise FileNotFoundError(f\"{mask} does not exist.\")\n    elif isinstance(mask, list) or isinstance(mask, dict):\n        if isinstance(mask, list):\n            geojson = {\n                \"type\": \"FeatureCollection\",\n                \"features\": [\n                    {\n                        \"type\": \"Feature\",\n                        \"properties\": {},\n                        \"geometry\": {\"type\": \"Polygon\", \"coordinates\": [mask]},\n                    }\n                ],\n            }\n        else:\n            geojson = {\n                \"type\": \"FeatureCollection\",\n                \"features\": [mask],\n            }\n        mask = temp_file_path(\".geojson\")\n        with open(mask, \"w\") as f:\n            json.dump(geojson, f)\n\n    with fiona.open(mask, \"r\") as shapefile:\n        shapes = [feature[\"geometry\"] for feature in shapefile]\n\n    with rasterio.open(image) as src:\n        out_image, out_transform = rasterio.mask.mask(src, shapes, crop=True)\n        out_meta = src.meta\n\n    out_meta.update(\n        {\n            \"driver\": \"GTiff\",\n            \"height\": out_image.shape[1],\n            \"width\": out_image.shape[2],\n            \"transform\": out_transform,\n        }\n    )\n\n    with rasterio.open(output, \"w\", **out_meta) as dest:\n        dest.write(out_image)\n\n    if to_cog:\n        image_to_cog(output, output)\n</code></pre>"},{"location":"common/#beamgis.common.cog_validate","title":"<code>cog_validate(source, verbose=False)</code>","text":"<p>Validate Cloud Optimized Geotiff.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>A dataset path or URL. Will be opened in \"r\" mode.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print the output of the validation. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the rio-cogeo package is not installed.</p> <code>FileNotFoundError</code> <p>If the provided file could not be found.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the validation results (True is src_path is a valid COG, List of validation errors, and a list of validation warnings).</p> Source code in <code>beamgis/common.py</code> <pre><code>def cog_validate(source, verbose=False):\n    \"\"\"Validate Cloud Optimized Geotiff.\n\n    Args:\n        source (str): A dataset path or URL. Will be opened in \"r\" mode.\n        verbose (bool, optional): Whether to print the output of the validation. Defaults to False.\n\n    Raises:\n        ImportError: If the rio-cogeo package is not installed.\n        FileNotFoundError: If the provided file could not be found.\n\n    Returns:\n        tuple: A tuple containing the validation results (True is src_path is a valid COG, List of validation errors, and a list of validation warnings).\n    \"\"\"\n    try:\n        from rio_cogeo.cogeo import cog_validate, cog_info\n    except ImportError:\n        raise ImportError(\n            \"The rio-cogeo package is not installed. Please install it with `pip install rio-cogeo` or `conda install rio-cogeo -c conda-forge`.\"\n        )\n\n    if not source.startswith(\"http\"):\n        source = check_file_path(source)\n\n        if not os.path.exists(source):\n            raise FileNotFoundError(\"The provided input file could not be found.\")\n\n    if verbose:\n        return cog_info(source)\n    else:\n        return cog_validate(source)\n</code></pre>"},{"location":"common/#beamgis.common.color_code_dataframe","title":"<code>color_code_dataframe(data, legend_dict)</code>","text":"<p>Converts values in a dataframe to color codes based on a legend dictionary.</p> <p>This function takes a dataframe (or path to a dataframe) and a legend dictionary and returns a new dataframe with values replaced by their corresponding color codes. It supports both numeric range legends and categorical legends.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, pandas.core.frame.DataFrame, gpd.GeoDataFrame]</code> <p>Input data source, can be: - Path to a CSV file or geospatial file - pandas DataFrame - geopandas GeoDataFrame</p> required <code>legend_dict</code> <code>Dict[str, str]</code> <p>Dictionary mapping values to colors, can be: - Numeric ranges (\"[ 100000, 200000]\") mapped to color codes - Categorical values (\"low\", \"medium\") mapped to color codes - Can include a \"Nodata\" key for None/NaN values</p> required <p>Returns:</p> Type Description <code>Union[pandas.core.frame.DataFrame, gpd.GeoDataFrame]</code> <p>A new dataframe with values replaced by color codes, preserving the input data type (DataFrame or GeoDataFrame)</p> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If the input data type is not supported</p> <code>ValueError</code> <p>If the file format is not supported</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Example with numeric ranges\n&gt;&gt;&gt; range_legend = {\n...     \"[ 0, 200000]\": \"#daeaf6\",\n...     \"(200001, 400000]\": \"#9ecae1\",\n...     \"Nodata\": \"#f0f0f0\"\n... }\n&gt;&gt;&gt; color_df = color_code_dataframe(\"housing_data.csv\", range_legend)\n</code></pre> <pre><code>&gt;&gt;&gt; # Example with categorical values\n&gt;&gt;&gt; cat_legend = {\n...     \"low\": \"#daeaf6\",\n...     \"medium\": \"#9ecae1\",\n...     \"high\": \"#2171b5\",\n...     \"Nodata\": \"#f0f0f0\"\n... }\n&gt;&gt;&gt; df = pd.DataFrame({\"Risk\": [\"low\", \"medium\", \"high\", None]})\n&gt;&gt;&gt; color_df = color_code_dataframe(df, cat_legend)\n</code></pre> Source code in <code>beamgis/common.py</code> <pre><code>def color_code_dataframe(\n    data: Union[str, pd.DataFrame, \"gpd.GeoDataFrame\"], legend_dict: Dict[str, str]\n) -&gt; Union[pd.DataFrame, \"gpd.GeoDataFrame\"]:\n    \"\"\"Converts values in a dataframe to color codes based on a legend dictionary.\n\n    This function takes a dataframe (or path to a dataframe) and a legend dictionary\n    and returns a new dataframe with values replaced by their corresponding color codes.\n    It supports both numeric range legends and categorical legends.\n\n    Args:\n        data: Input data source, can be:\n            - Path to a CSV file or geospatial file\n            - pandas DataFrame\n            - geopandas GeoDataFrame\n        legend_dict: Dictionary mapping values to colors, can be:\n            - Numeric ranges (\"[ 100000, 200000]\") mapped to color codes\n            - Categorical values (\"low\", \"medium\") mapped to color codes\n            - Can include a \"Nodata\" key for None/NaN values\n\n    Returns:\n        A new dataframe with values replaced by color codes, preserving the\n        input data type (DataFrame or GeoDataFrame)\n\n    Raises:\n        TypeError: If the input data type is not supported\n        ValueError: If the file format is not supported\n\n    Examples:\n        &gt;&gt;&gt; # Example with numeric ranges\n        &gt;&gt;&gt; range_legend = {\n        ...     \"[ 0, 200000]\": \"#daeaf6\",\n        ...     \"(200001, 400000]\": \"#9ecae1\",\n        ...     \"Nodata\": \"#f0f0f0\"\n        ... }\n        &gt;&gt;&gt; color_df = color_code_dataframe(\"housing_data.csv\", range_legend)\n\n        &gt;&gt;&gt; # Example with categorical values\n        &gt;&gt;&gt; cat_legend = {\n        ...     \"low\": \"#daeaf6\",\n        ...     \"medium\": \"#9ecae1\",\n        ...     \"high\": \"#2171b5\",\n        ...     \"Nodata\": \"#f0f0f0\"\n        ... }\n        &gt;&gt;&gt; df = pd.DataFrame({\"Risk\": [\"low\", \"medium\", \"high\", None]})\n        &gt;&gt;&gt; color_df = color_code_dataframe(df, cat_legend)\n    \"\"\"\n    import re\n\n    # Handle different input types\n    if isinstance(data, str):\n        # Input is a path to a file\n        path = Path(data)\n        if path.suffix.lower() == \".csv\":\n            df = pd.read_csv(data)\n        elif path.suffix.lower() in [\".geojson\", \".shp\"]:\n            df = gpd.read_file(data)\n        else:\n            raise ValueError(f\"Unsupported file format: {path.suffix}\")\n    elif isinstance(data, pd.DataFrame):\n        # Input is already a pandas DataFrame\n        df = data.copy()\n    elif isinstance(data, gpd.GeoDataFrame):\n        # Input is a GeoDataFrame\n        df = data.copy()\n    else:\n        raise TypeError(\"Input must be a file path, pandas DataFrame, or GeoDataFrame\")\n\n    # Determine legend type: numeric ranges or categorical\n    # Exclude \"Nodata\" key from this check\n    legend_without_nodata = {\n        k: v\n        for k, v in legend_dict.items()\n        if k != \"Nodata\" and not isinstance(k, str) or k.lower() != \"nodata\"\n    }\n    is_range_legend = any(\n        \"[\" in key or \"(\" in key for key in legend_without_nodata.keys()\n    )\n\n    # Get the \"Nodata\" color if provided\n    nodata_keys = [\"Nodata\", \"nodata\", \"NODATA\", \"NoData\"]\n    nodata_color = None\n    for key in nodata_keys:\n        if key in legend_dict:\n            nodata_color = legend_dict[key]\n            break\n\n    # Function to get color based on numeric value and range legend\n    def get_color_for_numeric(value: Any) -&gt; Optional[str]:\n        \"\"\"Maps a numeric value to a color based on the range legend.\n\n        Args:\n            value: The value to map to a color\n\n        Returns:\n            The corresponding color code or None if no match is found\n        \"\"\"\n        if pd.isna(value) or value is None:\n            return nodata_color\n\n        if not isinstance(value, (int, float)):\n            return nodata_color\n\n        for range_str, color in legend_dict.items():\n            # Skip the Nodata entry\n            if isinstance(range_str, str) and range_str.lower() == \"nodata\":\n                continue\n\n            # Parse the range string like \"[ 182913, 357522]\" or \"( 357522, 415584]\"\n            match = re.search(r\"[\\[\\(]\\s*(\\d+),\\s*(\\d+)[\\]\\)]\", range_str)\n            if not match:\n                continue\n\n            lower_bound = int(match.group(1))\n            upper_bound = int(match.group(2))\n            lower_inclusive = range_str.startswith(\"[\")\n            upper_inclusive = range_str.endswith(\"]\")\n\n            # Check if the value is within the range\n            above_lower = (\n                value &gt;= lower_bound if lower_inclusive else value &gt; lower_bound\n            )\n            below_upper = (\n                value &lt;= upper_bound if upper_inclusive else value &lt; upper_bound\n            )\n\n            if above_lower and below_upper:\n                return color\n\n        return None\n\n    # Function to get color based on categorical value\n    def get_color_for_categorical(value: Any) -&gt; Optional[str]:\n        \"\"\"Maps a categorical value to a color.\n\n        Args:\n            value: The value to map to a color\n\n        Returns:\n            The corresponding color code or None if no match is found\n        \"\"\"\n        if pd.isna(value) or value is None:\n            return nodata_color\n\n        # Convert to string for comparison\n        str_value = str(value).lower()\n\n        # Try direct matching\n        if str_value in legend_dict:\n            return legend_dict[str_value]\n\n        # Try case-insensitive matching\n        for cat, color in legend_dict.items():\n            if isinstance(cat, str) and cat.lower() == \"nodata\":\n                continue\n\n            if isinstance(cat, str) and cat.lower() == str_value:\n                return color\n\n        return None\n\n    # Select appropriate color mapping function\n    get_color = get_color_for_numeric if is_range_legend else get_color_for_categorical\n\n    # Identify columns to process\n    if is_range_legend:\n        # For numeric ranges, look for numeric columns and date-formatted columns\n        columns_to_process: List[str] = []\n        for col in df.columns:\n            # Check if column name matches date pattern\n            if isinstance(col, str) and re.match(r\"^\\d{4}-\\d{2}-\\d{2}$\", col):\n                columns_to_process.append(col)\n                continue\n\n            # Check if column contains numbers\n            if pd.api.types.is_numeric_dtype(df[col]):\n                # Exclude columns that are likely IDs or categorical codes\n                if not (\n                    col.lower().endswith(\"id\")\n                    or \"code\" in col.lower()\n                    or \"fips\" in col.lower()\n                ):\n                    columns_to_process.append(col)\n    else:\n        # For categorical legend, look for object or category columns\n        columns_to_process: List[str] = []\n        for col in df.columns:\n            if pd.api.types.is_object_dtype(\n                df[col]\n            ) or pd.api.types.is_categorical_dtype(df[col]):\n                columns_to_process.append(col)\n            # Also check if numeric columns might contain discrete categories\n            elif pd.api.types.is_numeric_dtype(df[col]) and df[col].nunique() &lt; 10:\n                columns_to_process.append(col)\n\n    # Replace each value with its corresponding color\n    for col in columns_to_process:\n        df[col] = df[col].apply(get_color)\n\n    return df\n</code></pre>"},{"location":"common/#beamgis.common.connect_points_as_line","title":"<code>connect_points_as_line(gdf, sort_column=None, crs='EPSG:4326', single_line=True)</code>","text":"<p>Connects points in a GeoDataFrame into either a single LineString or multiple LineStrings based on a specified sort column or the index if no column is provided. The resulting GeoDataFrame will have the specified CRS.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing point geometries.</p> required <code>sort_column</code> <code>Optional[str]</code> <p>Column name to sort the points by (e.g., 'timestamp').                          If None, the index is used for sorting. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The coordinate reference system (CRS) for the resulting GeoDataFrame.        Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>single_line</code> <code>bool</code> <p>If True, generates a single LineString connecting all points.                 If False, generates multiple LineStrings, each connecting two consecutive points.                 Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A new GeoDataFrame containing either a single LineString or multiple LineString geometries               based on the single_line parameter, with the specified CRS.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; line_gdf = connect_points_as_line(gdf, 'timestamp', crs=\"EPSG:3857\", single_line=True)\n&gt;&gt;&gt; line_gdf = connect_points_as_line(gdf, single_line=False)  # Uses index and defaults to EPSG:4326\n</code></pre> Source code in <code>beamgis/common.py</code> <pre><code>def connect_points_as_line(\n    gdf: \"GeoDataFrame\",\n    sort_column: Optional[str] = None,\n    crs: str = \"EPSG:4326\",\n    single_line: bool = True,\n) -&gt; \"GeoDataFrame\":\n    \"\"\"\n    Connects points in a GeoDataFrame into either a single LineString or multiple LineStrings\n    based on a specified sort column or the index if no column is provided. The resulting\n    GeoDataFrame will have the specified CRS.\n\n    Args:\n        gdf (GeoDataFrame): A GeoDataFrame containing point geometries.\n        sort_column (Optional[str]): Column name to sort the points by (e.g., 'timestamp').\n                                     If None, the index is used for sorting. Defaults to None.\n        crs (str): The coordinate reference system (CRS) for the resulting GeoDataFrame.\n                   Defaults to \"EPSG:4326\".\n        single_line (bool): If True, generates a single LineString connecting all points.\n                            If False, generates multiple LineStrings, each connecting two consecutive points.\n                            Defaults to True.\n\n    Returns:\n        GeoDataFrame: A new GeoDataFrame containing either a single LineString or multiple LineString geometries\n                      based on the single_line parameter, with the specified CRS.\n\n    Example:\n        &gt;&gt;&gt; line_gdf = connect_points_as_line(gdf, 'timestamp', crs=\"EPSG:3857\", single_line=True)\n        &gt;&gt;&gt; line_gdf = connect_points_as_line(gdf, single_line=False)  # Uses index and defaults to EPSG:4326\n    \"\"\"\n    from shapely.geometry import LineString\n    import geopandas as gpd\n\n    # Sort the GeoDataFrame by the specified column or by index if None\n    gdf_sorted = gdf.sort_values(by=sort_column) if sort_column else gdf.sort_index()\n\n    if single_line:\n        # Create a single LineString connecting all points\n        line = LineString(gdf_sorted.geometry.tolist())\n        line_gdf = gpd.GeoDataFrame(geometry=[line], crs=crs)\n    else:\n        # Generate LineStrings for each consecutive pair of points\n        lines = [\n            LineString([gdf_sorted.geometry.iloc[i], gdf_sorted.geometry.iloc[i + 1]])\n            for i in range(len(gdf_sorted) - 1)\n        ]\n        line_gdf = gpd.GeoDataFrame(geometry=lines, crs=crs)\n\n    return line_gdf\n</code></pre>"},{"location":"common/#beamgis.common.connect_postgis","title":"<code>connect_postgis(database, host='localhost', user=None, password=None, port=5432, use_env_var=False)</code>","text":"<p>Connects to a PostGIS database.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>str</code> <p>Name of the database</p> required <code>host</code> <code>str</code> <p>Hosting server for the database. Defaults to \"localhost\".</p> <code>'localhost'</code> <code>user</code> <code>str</code> <p>User name to access the database. Defaults to None.</p> <code>None</code> <code>password</code> <code>str</code> <p>Password to access the database. Defaults to None.</p> <code>None</code> <code>port</code> <code>int</code> <p>Port number to connect to at the server host. Defaults to 5432.</p> <code>5432</code> <code>use_env_var</code> <code>bool</code> <p>Whether to use environment variables. It set to True, user and password are treated as an environment variables with default values user=\"SQL_USER\" and password=\"SQL_PASSWORD\". Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If user is not specified.</p> <code>ValueError</code> <p>If password is not specified.</p> <p>Returns:</p> Type Description <code>[type]</code> <p>[description]</p> Source code in <code>beamgis/common.py</code> <pre><code>def connect_postgis(\n    database, host=\"localhost\", user=None, password=None, port=5432, use_env_var=False\n):\n    \"\"\"Connects to a PostGIS database.\n\n    Args:\n        database (str): Name of the database\n        host (str, optional): Hosting server for the database. Defaults to \"localhost\".\n        user (str, optional): User name to access the database. Defaults to None.\n        password (str, optional): Password to access the database. Defaults to None.\n        port (int, optional): Port number to connect to at the server host. Defaults to 5432.\n        use_env_var (bool, optional): Whether to use environment variables. It set to True, user and password are treated as an environment variables with default values user=\"SQL_USER\" and password=\"SQL_PASSWORD\". Defaults to False.\n\n    Raises:\n        ValueError: If user is not specified.\n        ValueError: If password is not specified.\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    check_package(\n        name=\"sqlalchemy\",\n        URL=\"https://docs.sqlalchemy.org/en/14/intro.html#installation\",\n    )\n\n    from sqlalchemy import create_engine\n\n    if use_env_var:\n        if user is not None:\n            user = os.getenv(user)\n        else:\n            user = os.getenv(\"SQL_USER\")\n\n        if password is not None:\n            password = os.getenv(password)\n        else:\n            password = os.getenv(\"SQL_PASSWORD\")\n\n        if user is None:\n            raise ValueError(\"user is not specified.\")\n        if password is None:\n            raise ValueError(\"password is not specified.\")\n\n    connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n    engine = create_engine(connection_string)\n\n    return engine\n</code></pre>"},{"location":"common/#beamgis.common.construct_bbox","title":"<code>construct_bbox(*args, *, buffer=0.001, crs='EPSG:4326', return_gdf=False)</code>","text":"<p>Construct a bounding box (bbox) geometry based on either a centroid point or bbox.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Union[float, Tuple[float, float, float, float]]</code> <p>Coordinates for the geometry. - If 2 arguments are provided, it is interpreted as a centroid (x, y) with a buffer. - If 4 arguments are provided, it is interpreted as a bbox (minx, miny, maxx, maxy).</p> <code>()</code> <code>buffer</code> <code>float</code> <p>The buffer distance around the centroid point (default is 0.01 degrees).</p> <code>0.001</code> <code>crs</code> <code>str</code> <p>The coordinate reference system (default is \"EPSG:4326\").</p> <code>'EPSG:4326'</code> <code>return_gdf</code> <code>bool</code> <p>Whether to return a GeoDataFrame (default is False).</p> <code>False</code> <p>Returns:</p> Type Description <code>shapely.geometry.Polygon</code> <p>The constructed bounding box (Polygon).</p> Source code in <code>beamgis/common.py</code> <pre><code>def construct_bbox(\n    *args: Union[float, Tuple[float, float, float, float]],\n    buffer: float = 0.001,\n    crs: str = \"EPSG:4326\",\n    return_gdf: bool = False,\n) -&gt; Union[\"Polygon\", \"gpd.GeoDataFrame\"]:\n    \"\"\"\n    Construct a bounding box (bbox) geometry based on either a centroid point or bbox.\n\n    Args:\n        *args: Coordinates for the geometry.\n            - If 2 arguments are provided, it is interpreted as a centroid (x, y) with a buffer.\n            - If 4 arguments are provided, it is interpreted as a bbox (minx, miny, maxx, maxy).\n        buffer (float): The buffer distance around the centroid point (default is 0.01 degrees).\n        crs (str): The coordinate reference system (default is \"EPSG:4326\").\n        return_gdf (bool): Whether to return a GeoDataFrame (default is False).\n\n    Returns:\n        shapely.geometry.Polygon: The constructed bounding box (Polygon).\n    \"\"\"\n    from shapely.geometry import box\n\n    if len(args) == 2:\n        # Case 1: Create a bounding box around the centroid point with a buffer\n        x, y = args\n        minx, miny = x - buffer, y - buffer\n        maxx, maxy = x + buffer, y + buffer\n        geometry = box(minx, miny, maxx, maxy)\n\n    elif len(args) == 4:\n        # Case 2: Create a bounding box directly from the given coordinates\n        geometry = box(args[0], args[1], args[2], args[3])\n\n    else:\n        raise ValueError(\n            \"Provide either 2 arguments for centroid (x, y) or 4 arguments for bbox (minx, miny, maxx, maxy).\"\n        )\n\n    if return_gdf:\n        return gpd.GeoDataFrame(geometry=[geometry], columns=[\"geometry\"], crs=crs)\n    else:\n        return geometry\n</code></pre>"},{"location":"common/#beamgis.common.convert_coordinates","title":"<code>convert_coordinates(x, y, source_crs, target_crs='epsg:4326')</code>","text":"<p>Convert coordinates from the source EPSG code to the target EPSG code.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x-coordinate of the point.</p> required <code>y</code> <code>float</code> <p>The y-coordinate of the point.</p> required <code>source_crs</code> <code>str</code> <p>The EPSG code of the source coordinate system.</p> required <code>target_crs</code> <code>str</code> <p>The EPSG code of the target coordinate system. Defaults to '4326' (EPSG code for WGS84).</p> <code>'epsg:4326'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the converted longitude and latitude.</p> Source code in <code>beamgis/common.py</code> <pre><code>def convert_coordinates(x, y, source_crs, target_crs=\"epsg:4326\"):\n    \"\"\"Convert coordinates from the source EPSG code to the target EPSG code.\n\n    Args:\n        x (float): The x-coordinate of the point.\n        y (float): The y-coordinate of the point.\n        source_crs (str): The EPSG code of the source coordinate system.\n        target_crs (str, optional): The EPSG code of the target coordinate system.\n            Defaults to '4326' (EPSG code for WGS84).\n\n    Returns:\n        tuple: A tuple containing the converted longitude and latitude.\n    \"\"\"\n    import pyproj\n\n    # Create the transformer\n    transformer = pyproj.Transformer.from_crs(source_crs, target_crs, always_xy=True)\n\n    # Perform the transformation\n    lon, lat = transformer.transform(x, y)  # pylint: disable=E0633\n\n    # Return the converted coordinates\n    return lon, lat\n</code></pre>"},{"location":"common/#beamgis.common.convert_lidar","title":"<code>convert_lidar(source, destination=None, point_format_id=None, file_version=None, **kwargs)</code>","text":"<p>Converts a Las from one point format to another Automatically upgrades the file version if source file version     is not compatible with the new point_format_id</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | laspy.lasdatas.base.LasBase</code> <p>The source data to be converted.</p> required <code>destination</code> <code>str</code> <p>The destination file path. Defaults to None.</p> <code>None</code> <code>point_format_id</code> <code>int</code> <p>The new point format id (the default is None, which won't change the source format id).</p> <code>None</code> <code>file_version</code> <code>str</code> <p>The new file version. None by default which means that the file_version may be upgraded for compatibility with the new point_format. The file version will not be downgraded.</p> <code>None</code> <p>Returns:</p> Type Description <code>aspy.lasdatas.base.LasBase</code> <p>The converted LasData object.</p> Source code in <code>beamgis/common.py</code> <pre><code>def convert_lidar(\n    source, destination=None, point_format_id=None, file_version=None, **kwargs\n):\n    \"\"\"Converts a Las from one point format to another Automatically upgrades the file version if source file version\n        is not compatible with the new point_format_id\n\n    Args:\n        source (str | laspy.lasdatas.base.LasBase): The source data to be converted.\n        destination (str, optional): The destination file path. Defaults to None.\n        point_format_id (int, optional): The new point format id (the default is None, which won't change the source format id).\n        file_version (str, optional): The new file version. None by default which means that the file_version may be upgraded\n            for compatibility with the new point_format. The file version will not be downgraded.\n\n    Returns:\n        aspy.lasdatas.base.LasBase: The converted LasData object.\n    \"\"\"\n    try:\n        import laspy\n    except ImportError:\n        print(\n            \"The laspy package is required for this function. Use `pip install laspy[lazrs,laszip]` to install it.\"\n        )\n        return\n\n    if isinstance(source, str):\n        source = read_lidar(source)\n\n    las = laspy.convert(\n        source, point_format_id=point_format_id, file_version=file_version\n    )\n\n    if destination is None:\n        return las\n    else:\n        destination = check_file_path(destination)\n        write_lidar(las, destination, **kwargs)\n        return destination\n</code></pre>"},{"location":"common/#beamgis.common.convert_to_gdf","title":"<code>convert_to_gdf(data, geometry=None, lat=None, lon=None, crs='EPSG:4326', included=None, excluded=None, obj_to_str=False, open_args=None, **kwargs)</code>","text":"<p>Convert data to a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[pd.DataFrame, str]</code> <p>The input data, either as a DataFrame or a file path.</p> required <code>geometry</code> <code>Optional[str]</code> <p>The column name containing geometry data. Defaults to None.</p> <code>None</code> <code>lat</code> <code>Optional[str]</code> <p>The column name containing latitude data. Defaults to None.</p> <code>None</code> <code>lon</code> <code>Optional[str]</code> <p>The column name containing longitude data. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The coordinate reference system to use. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>included</code> <code>Optional[List[str]]</code> <p>List of columns to include. Defaults to None.</p> <code>None</code> <code>excluded</code> <code>Optional[List[str]]</code> <p>List of columns to exclude. Defaults to None.</p> <code>None</code> <code>obj_to_str</code> <code>bool</code> <p>Whether to convert object dtype columns to string. Defaults to False.</p> <code>False</code> <code>open_args</code> <code>Optional[Dict[str, Any]]</code> <p>Additional arguments for file opening functions. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for GeoDataFrame creation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>The converted GeoDataFrame.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the file format is unsupported or required columns are not provided.</p> Source code in <code>beamgis/common.py</code> <pre><code>def convert_to_gdf(\n    data: Union[pd.DataFrame, str],\n    geometry: Optional[str] = None,\n    lat: Optional[str] = None,\n    lon: Optional[str] = None,\n    crs: str = \"EPSG:4326\",\n    included: Optional[List[str]] = None,\n    excluded: Optional[List[str]] = None,\n    obj_to_str: bool = False,\n    open_args: Optional[Dict[str, Any]] = None,\n    **kwargs: Any,\n) -&gt; \"gpd.GeoDataFrame\":\n    \"\"\"Convert data to a GeoDataFrame.\n\n    Args:\n        data (Union[pd.DataFrame, str]): The input data, either as a DataFrame or a file path.\n        geometry (Optional[str], optional): The column name containing geometry data. Defaults to None.\n        lat (Optional[str], optional): The column name containing latitude data. Defaults to None.\n        lon (Optional[str], optional): The column name containing longitude data. Defaults to None.\n        crs (str, optional): The coordinate reference system to use. Defaults to \"EPSG:4326\".\n        included (Optional[List[str]], optional): List of columns to include. Defaults to None.\n        excluded (Optional[List[str]], optional): List of columns to exclude. Defaults to None.\n        obj_to_str (bool, optional): Whether to convert object dtype columns to string. Defaults to False.\n        open_args (Optional[Dict[str, Any]], optional): Additional arguments for file opening functions. Defaults to None.\n        **kwargs (Any): Additional keyword arguments for GeoDataFrame creation.\n\n    Returns:\n        gpd.GeoDataFrame: The converted GeoDataFrame.\n\n    Raises:\n        ValueError: If the file format is unsupported or required columns are not provided.\n    \"\"\"\n    import geopandas as gpd\n    from shapely.geometry import Point, shape\n\n    if open_args is None:\n        open_args = {}\n\n    if not isinstance(data, pd.DataFrame):\n        if isinstance(data, str):\n            if data.endswith(\".parquet\"):\n                data = pd.read_parquet(data, **open_args)\n            elif data.endswith(\".csv\"):\n                data = pd.read_csv(data, **open_args)\n            elif data.endswith(\".json\"):\n                data = pd.read_json(data, **open_args)\n            elif data.endswith(\".xlsx\"):\n                data = pd.read_excel(data, **open_args)\n            else:\n                raise ValueError(\n                    \"Unsupported file format. Only Parquet, CSV, JSON, and Excel files are supported.\"\n                )\n\n    # If include_cols is specified, filter the DataFrame to include only those columns\n    if included:\n        if geometry:\n            included.append(geometry)\n        elif lat and lon:\n            included.append(lat)\n            included.append(lon)\n        data = data[included]\n\n    # Exclude specified columns if provided\n    if excluded:\n        data = data.drop(columns=excluded)\n\n    # Convert 'object' dtype columns to 'string' if obj_to_str is True\n    if obj_to_str:\n        data = data.astype(\n            {col: \"string\" for col in data.select_dtypes(include=\"object\").columns}\n        )\n\n    # Handle the creation of geometry\n    if geometry:\n\n        def convert_geometry(x):\n            if isinstance(x, str):\n                try:\n                    # Parse the string as JSON and then convert to a geometry\n                    return shape(json.loads(x))\n                except (json.JSONDecodeError, TypeError) as e:\n                    print(f\"Error converting geometry: {e}\")\n                    return None\n            return x\n\n        data = data[data[geometry].notnull()]\n        data[geometry] = data[geometry].apply(convert_geometry)\n    elif lat and lon:\n        # Create a geometry column from latitude and longitude\n        data[\"geometry\"] = data.apply(lambda row: Point(row[lon], row[lat]), axis=1)\n        geometry = \"geometry\"\n    else:\n        raise ValueError(\n            \"Either geometry_col or both lat_col and lon_col must be provided.\"\n        )\n\n    # Convert the DataFrame to a GeoDataFrame\n    gdf = gpd.GeoDataFrame(data, geometry=geometry, **kwargs)\n\n    # Set CRS (assuming WGS84 by default, modify as needed)\n    gdf.set_crs(crs, inplace=True)\n\n    return gdf\n</code></pre>"},{"location":"common/#beamgis.common.coords_to_geojson","title":"<code>coords_to_geojson(coords)</code>","text":"<p>Convert a list of bbox coordinates representing [left, bottom, right, top] to geojson FeatureCollection.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>list</code> <p>A list of bbox coordinates representing [left, bottom, right, top].</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A geojson FeatureCollection.</p> Source code in <code>beamgis/common.py</code> <pre><code>def coords_to_geojson(coords):\n    \"\"\"Convert a list of bbox coordinates representing [left, bottom, right, top] to geojson FeatureCollection.\n\n    Args:\n        coords (list): A list of bbox coordinates representing [left, bottom, right, top].\n\n    Returns:\n        dict: A geojson FeatureCollection.\n    \"\"\"\n\n    features = []\n    for bbox in coords:\n        features.append(bbox_to_geojson(bbox))\n    return {\"type\": \"FeatureCollection\", \"features\": features}\n</code></pre>"},{"location":"common/#beamgis.common.coords_to_vector","title":"<code>coords_to_vector(coords, output=None, crs='EPSG:4326', **kwargs)</code>","text":"<p>Convert a list of coordinates to a GeoDataFrame or a vector file.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>list</code> <p>A list of coordinates in the format of [(x1, y1), (x2, y2), ...].</p> required <code>output</code> <code>str</code> <p>The path to the output vector file. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The CRS of the coordinates. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFraem</code> <p>A GeoDataFrame of the coordinates.</p> Source code in <code>beamgis/common.py</code> <pre><code>def coords_to_vector(coords, output=None, crs=\"EPSG:4326\", **kwargs):\n    \"\"\"Convert a list of coordinates to a GeoDataFrame or a vector file.\n\n    Args:\n        coords (list): A list of coordinates in the format of [(x1, y1), (x2, y2), ...].\n        output (str, optional): The path to the output vector file. Defaults to None.\n        crs (str, optional): The CRS of the coordinates. Defaults to \"EPSG:4326\".\n\n    Returns:\n        gpd.GeoDataFraem: A GeoDataFrame of the coordinates.\n    \"\"\"\n    import geopandas as gpd\n    from shapely.geometry import Point\n\n    if not isinstance(coords, (list, tuple)):\n        raise TypeError(\"coords must be a list of coordinates\")\n\n    if isinstance(coords[0], int) or isinstance(coords[0], float):\n        coords = [(coords[0], coords[1])]\n\n    # convert the points to a GeoDataFrame\n    geometry = [Point(xy) for xy in coords]\n    gdf = gpd.GeoDataFrame(geometry=geometry, crs=\"EPSG:4326\")\n    gdf.to_crs(crs, inplace=True)\n\n    if output is not None:\n        gdf.to_file(output, **kwargs)\n    else:\n        return gdf\n</code></pre>"},{"location":"common/#beamgis.common.coords_to_xy","title":"<code>coords_to_xy(src_fp, coords, coord_crs='epsg:4326', request_payer='bucket-owner', env_args={}, open_args={}, **kwargs)</code>","text":"<p>Converts a list of coordinates to pixel coordinates, i.e., (col, row) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>src_fp</code> <code>str</code> <p>The source raster file path.</p> required <code>coords</code> <code>list</code> <p>A list of coordinates in the format of [[x1, y1], [x2, y2], ...]</p> required <code>coord_crs</code> <code>str</code> <p>The coordinate CRS of the input coordinates. Defaults to \"epsg:4326\".</p> <code>'epsg:4326'</code> <code>request_payer</code> <p>Specifies who pays for the download from S3. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>'bucket-owner'</code> <code>env_args</code> <p>Additional keyword arguments to pass to rasterio.Env.</p> <code>{}</code> <code>open_args</code> <p>Additional keyword arguments to pass to rasterio.open.</p> <code>{}</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to rasterio.transform.rowcol.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of pixel coordinates in the format of [[x1, y1], [x2, y2], ...]</p> Source code in <code>beamgis/common.py</code> <pre><code>def coords_to_xy(\n    src_fp: str,\n    coords: list,\n    coord_crs: str = \"epsg:4326\",\n    request_payer=\"bucket-owner\",\n    env_args={},\n    open_args={},\n    **kwargs,\n) -&gt; list:\n    \"\"\"Converts a list of coordinates to pixel coordinates, i.e., (col, row) coordinates.\n\n    Args:\n        src_fp: The source raster file path.\n        coords: A list of coordinates in the format of [[x1, y1], [x2, y2], ...]\n        coord_crs: The coordinate CRS of the input coordinates. Defaults to \"epsg:4326\".\n        request_payer: Specifies who pays for the download from S3.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        env_args: Additional keyword arguments to pass to rasterio.Env.\n        open_args: Additional keyword arguments to pass to rasterio.open.\n        **kwargs: Additional keyword arguments to pass to rasterio.transform.rowcol.\n\n    Returns:\n        A list of pixel coordinates in the format of [[x1, y1], [x2, y2], ...]\n    \"\"\"\n    import numpy as np\n    import rasterio\n\n    if isinstance(coords, np.ndarray):\n        coords = coords.tolist()\n\n    if len(coords) == 4 and all([isinstance(c, (int, float)) for c in coords]):\n        coords = [[coords[0], coords[1]], [coords[2], coords[3]]]\n\n    xs, ys = zip(*coords)\n    with rasterio.Env(AWS_REQUEST_PAYER=request_payer, **env_args):\n        with rasterio.open(src_fp, **open_args) as src:\n            width = src.width\n            height = src.height\n            if coord_crs != src.crs:\n                xs, ys = transform_coords(\n                    xs, ys, coord_crs, src.crs, **kwargs\n                )  # pylint: disable=E0633\n            rows, cols = rasterio.transform.rowcol(src.transform, xs, ys, **kwargs)\n        result = [[col, row] for col, row in zip(cols, rows)]\n\n        result = [\n            [x, y] for x, y in result if x &gt;= 0 and y &gt;= 0 and x &lt; width and y &lt; height\n        ]\n        if len(result) == 0:\n            print(\"No valid pixel coordinates found.\")\n        elif len(result) &lt; len(coords):\n            print(\"Some coordinates are out of the image boundary.\")\n\n        return result\n</code></pre>"},{"location":"common/#beamgis.common.create_code_cell","title":"<code>create_code_cell(code='', where='below')</code>","text":"<p>Creates a code cell in the IPython Notebook.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Code to fill the new code cell with. Defaults to ''.</p> <code>''</code> <code>where</code> <code>str</code> <p>Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'.</p> <code>'below'</code> Source code in <code>beamgis/common.py</code> <pre><code>def create_code_cell(code=\"\", where=\"below\"):\n    \"\"\"Creates a code cell in the IPython Notebook.\n\n    Args:\n        code (str, optional): Code to fill the new code cell with. Defaults to ''.\n        where (str, optional): Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'.\n    \"\"\"\n\n    import base64\n\n    # try:\n    #     import pyperclip\n    # except ImportError:\n    #     install_package(\"pyperclip\")\n    #     import pyperclip\n\n    from IPython.display import Javascript, display\n\n    # try:\n    #     pyperclip.copy(str(code))\n    # except Exception as e:\n    #     pass\n\n    encoded_code = (base64.b64encode(str.encode(code))).decode()\n    display(\n        Javascript(\n            \"\"\"\n        var code = IPython.notebook.insert_cell_{0}('code');\n        code.set_text(atob(\"{1}\"));\n    \"\"\".format(\n                where, encoded_code\n            )\n        )\n    )\n</code></pre>"},{"location":"common/#beamgis.common.create_download_link","title":"<code>create_download_link(filename, title='Click here to download: ', basename=None)</code>","text":"<p>Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The file path to the file to download</p> required <code>title</code> <code>str</code> <p>str. Defaults to \"Click here to download: \".</p> <code>'Click here to download: '</code> <p>Returns:</p> Type Description <code>str</code> <p>HTML download URL.</p> Source code in <code>beamgis/common.py</code> <pre><code>def create_download_link(filename, title=\"Click here to download: \", basename=None):\n    \"\"\"Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578\n\n    Args:\n        filename (str): The file path to the file to download\n        title (str, optional): str. Defaults to \"Click here to download: \".\n\n    Returns:\n        str: HTML download URL.\n    \"\"\"\n    import base64\n    from IPython.display import HTML\n\n    data = open(filename, \"rb\").read()\n    b64 = base64.b64encode(data)\n    payload = b64.decode()\n    if basename is None:\n        basename = os.path.basename(filename)\n    html = '&lt;a download=\"{filename}\" href=\"data:text/csv;base64,{payload}\" style=\"color:#0000FF;\" target=\"_blank\"&gt;{title}&lt;/a&gt;'\n    html = html.format(payload=payload, title=title + f\" {basename}\", filename=basename)\n    return HTML(html)\n</code></pre>"},{"location":"common/#beamgis.common.create_legend","title":"<code>create_legend(title='Legend', labels=None, colors=None, legend_dict=None, builtin_legend=None, opacity=1.0, position='bottomright', draggable=True, output=None, style={}, shape_type='rectangle')</code>","text":"<p>Create a legend in HTML format. Reference: https://bit.ly/3oV6vnH</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the legend. Defaults to 'Legend'. Defaults to \"Legend\".</p> <code>'Legend'</code> <code>colors</code> <code>list</code> <p>A list of legend colors. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of legend labels. Defaults to None.</p> <code>None</code> <code>legend_dict</code> <code>dict</code> <p>A dictionary containing legend items as keys and color as values. If provided, legend_keys and legend_colors will be ignored. Defaults to None.</p> <code>None</code> <code>builtin_legend</code> <code>str</code> <p>Name of the builtin legend to add to the map. Defaults to None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The opacity of the legend. Defaults to 1.0.</p> <code>1.0</code> <code>position</code> <code>str</code> <p>The position of the legend, can be one of the following: \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>draggable</code> <code>bool</code> <p>If True, the legend can be dragged to a new position. Defaults to True.</p> <code>True</code> <code>output</code> <code>str</code> <p>The output file path (*.html) to save the legend. Defaults to None.</p> <code>None</code> <code>style</code> <p>Additional keyword arguments to style the legend, such as position, bottom, right, z-index, border, background-color, border-radius, padding, font-size, etc. The default style is: style = {     'position': 'fixed',     'z-index': '9999',     'border': '2px solid grey',     'background-color': 'rgba(255, 255, 255, 0.8)',     'border-radius': '5px',     'padding': '10px',     'font-size': '14px',     'bottom': '20px',     'right': '5px' }</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML code of the legend.</p> Source code in <code>beamgis/common.py</code> <pre><code>def create_legend(\n    title=\"Legend\",\n    labels=None,\n    colors=None,\n    legend_dict=None,\n    builtin_legend=None,\n    opacity=1.0,\n    position=\"bottomright\",\n    draggable=True,\n    output=None,\n    style={},\n    shape_type=\"rectangle\",\n):\n    \"\"\"Create a legend in HTML format. Reference: https://bit.ly/3oV6vnH\n\n    Args:\n        title (str, optional): Title of the legend. Defaults to 'Legend'. Defaults to \"Legend\".\n        colors (list, optional): A list of legend colors. Defaults to None.\n        labels (list, optional): A list of legend labels. Defaults to None.\n        legend_dict (dict, optional): A dictionary containing legend items as keys and color as values.\n            If provided, legend_keys and legend_colors will be ignored. Defaults to None.\n        builtin_legend (str, optional): Name of the builtin legend to add to the map. Defaults to None.\n        opacity (float, optional): The opacity of the legend. Defaults to 1.0.\n        position (str, optional): The position of the legend, can be one of the following:\n            \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".\n        draggable (bool, optional): If True, the legend can be dragged to a new position. Defaults to True.\n        output (str, optional): The output file path (*.html) to save the legend. Defaults to None.\n        style: Additional keyword arguments to style the legend, such as position, bottom, right, z-index,\n            border, background-color, border-radius, padding, font-size, etc. The default style is:\n            style = {\n                'position': 'fixed',\n                'z-index': '9999',\n                'border': '2px solid grey',\n                'background-color': 'rgba(255, 255, 255, 0.8)',\n                'border-radius': '5px',\n                'padding': '10px',\n                'font-size': '14px',\n                'bottom': '20px',\n                'right': '5px'\n            }\n\n    Returns:\n        str: The HTML code of the legend.\n    \"\"\"\n\n    import importlib.resources\n    from .legends import builtin_legends\n\n    pkg_dir = os.path.dirname(importlib.resources.files(\"leafmap\") / \"leafmap.py\")\n    legend_template = os.path.join(pkg_dir, \"data/template/legend_style.html\")\n\n    if draggable:\n        legend_template = os.path.join(pkg_dir, \"data/template/legend.txt\")\n\n    if not os.path.exists(legend_template):\n        raise FileNotFoundError(\"The legend template does not exist.\")\n\n    if labels is not None:\n        if not isinstance(labels, list):\n            print(\"The legend keys must be a list.\")\n            return\n    else:\n        labels = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"]\n\n    if colors is not None:\n        if not isinstance(colors, list):\n            print(\"The legend colors must be a list.\")\n            return\n        elif all(isinstance(item, tuple) for item in colors):\n            try:\n                colors = [rgb_to_hex(x) for x in colors]\n            except Exception as e:\n                print(e)\n        elif all((item.startswith(\"#\") and len(item) == 7) for item in colors):\n            pass\n        elif all((len(item) == 6) for item in colors):\n            pass\n        else:\n            print(\"The legend colors must be a list of tuples.\")\n            return\n    else:\n        colors = [\n            \"#8DD3C7\",\n            \"#FFFFB3\",\n            \"#BEBADA\",\n            \"#FB8072\",\n            \"#80B1D3\",\n        ]\n\n    if len(labels) != len(colors):\n        print(\"The legend keys and values must be the same length.\")\n        return\n\n    allowed_builtin_legends = builtin_legends.keys()\n    if builtin_legend is not None:\n        if builtin_legend not in allowed_builtin_legends:\n            print(\n                \"The builtin legend must be one of the following: {}\".format(\n                    \", \".join(allowed_builtin_legends)\n                )\n            )\n            return\n        else:\n            legend_dict = builtin_legends[builtin_legend]\n            labels = list(legend_dict.keys())\n            colors = list(legend_dict.values())\n\n    if legend_dict is not None:\n        if not isinstance(legend_dict, dict):\n            print(\"The legend dict must be a dictionary.\")\n            return\n        else:\n            labels = list(legend_dict.keys())\n            colors = list(legend_dict.values())\n            if all(isinstance(item, tuple) for item in colors):\n                try:\n                    colors = [rgb_to_hex(x) for x in colors]\n                except Exception as e:\n                    print(e)\n\n    allowed_positions = [\n        \"topleft\",\n        \"topright\",\n        \"bottomleft\",\n        \"bottomright\",\n    ]\n    if position not in allowed_positions:\n        raise ValueError(\n            \"The position must be one of the following: {}\".format(\n                \", \".join(allowed_positions)\n            )\n        )\n\n    if position == \"bottomright\":\n        if \"bottom\" not in style:\n            style[\"bottom\"] = \"20px\"\n        if \"right\" not in style:\n            style[\"right\"] = \"5px\"\n        if \"left\" in style:\n            del style[\"left\"]\n        if \"top\" in style:\n            del style[\"top\"]\n    elif position == \"bottomleft\":\n        if \"bottom\" not in style:\n            style[\"bottom\"] = \"5px\"\n        if \"left\" not in style:\n            style[\"left\"] = \"5px\"\n        if \"right\" in style:\n            del style[\"right\"]\n        if \"top\" in style:\n            del style[\"top\"]\n    elif position == \"topright\":\n        if \"top\" not in style:\n            style[\"top\"] = \"5px\"\n        if \"right\" not in style:\n            style[\"right\"] = \"5px\"\n        if \"left\" in style:\n            del style[\"left\"]\n        if \"bottom\" in style:\n            del style[\"bottom\"]\n    elif position == \"topleft\":\n        if \"top\" not in style:\n            style[\"top\"] = \"5px\"\n        if \"left\" not in style:\n            style[\"left\"] = \"5px\"\n        if \"right\" in style:\n            del style[\"right\"]\n        if \"bottom\" in style:\n            del style[\"bottom\"]\n\n    if \"position\" not in style:\n        style[\"position\"] = \"fixed\"\n    if \"z-index\" not in style:\n        style[\"z-index\"] = \"9999\"\n    if \"background-color\" not in style:\n        style[\"background-color\"] = \"rgba(255, 255, 255, 0.8)\"\n    if \"padding\" not in style:\n        style[\"padding\"] = \"10px\"\n    if \"border-radius\" not in style:\n        style[\"border-radius\"] = \"5px\"\n    if \"font-size\" not in style:\n        style[\"font-size\"] = \"14px\"\n\n    content = []\n\n    with open(legend_template) as f:\n        lines = f.readlines()\n\n    if draggable:\n        for index, line in enumerate(lines):\n            if index &lt; 36:\n                content.append(line)\n            elif index == 36:\n                line = lines[index].replace(\"Legend\", title)\n                content.append(line)\n            elif index &lt; 39:\n                content.append(line)\n            elif index == 39:\n                for i, color in enumerate(colors):\n                    item = f\"    &lt;li&gt;&lt;span style='background:{check_color(color)};opacity:{opacity};'&gt;&lt;/span&gt;{labels[i]}&lt;/li&gt;\\n\"\n                    content.append(item)\n            elif index &gt; 41:\n                content.append(line)\n        content = content[3:-1]\n\n    else:\n        for index, line in enumerate(lines):\n            if index &lt; 8:\n                content.append(line)\n            elif index == 8:\n                for key, value in style.items():\n                    content.append(\n                        \"              {}: {};\\n\".format(key.replace(\"_\", \"-\"), value)\n                    )\n            elif index &lt; 17:\n                pass\n            elif index &lt; 19:\n                content.append(line)\n            elif index == 19:\n                content.append(line.replace(\"Legend\", title))\n            elif index &lt; 22:\n                content.append(line)\n            elif index == 22:\n                for index, key in enumerate(labels):\n                    color = colors[index]\n                    if not color.startswith(\"#\"):\n                        color = \"#\" + color\n                    item = \"                    &lt;li&gt;&lt;span style='background:{};opacity:{};'&gt;&lt;/span&gt;{}&lt;/li&gt;\\n\".format(\n                        color, opacity, key\n                    )\n                    content.append(item)\n            elif index &lt; 33:\n                pass\n            else:\n                content.append(line)\n\n    legend_text = \"\".join(content)\n    if shape_type == \"circle\":\n        legend_text = legend_text.replace(\"width: 30px\", \"width: 16px\")\n        legend_text = legend_text.replace(\n            \"border: 1px solid #999;\",\n            \"border-radius: 50%;\\n      border: 1px solid #999;\",\n        )\n    elif shape_type == \"line\":\n        legend_text = legend_text.replace(\"height: 16px\", \"height: 3px\")\n\n    if output is not None:\n        with open(output, \"w\") as f:\n            f.write(legend_text)\n    else:\n        return legend_text\n</code></pre>"},{"location":"common/#beamgis.common.create_timelapse","title":"<code>create_timelapse(images, out_gif, ext='.tif', bands=None, size=None, bbox=None, fps=5, loop=0, add_progress_bar=True, progress_bar_color='blue', progress_bar_height=5, add_text=False, text_xy=None, text_sequence=None, font_type='arial.ttf', font_size=20, font_color='black', mp4=False, quiet=True, reduce_size=False, clean_up=True, **kwargs)</code>","text":"<p>Creates a timelapse gif from a list of images.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>list | str</code> <p>The list of images or input directory to create the gif from. For example, '/path/to/images/*.tif' or ['/path/to/image1.tif', '/path/to/image2.tif', ...]</p> required <code>out_gif</code> <code>str</code> <p>File path to the output gif.</p> required <code>ext</code> <code>str</code> <p>The extension of the images. Defaults to '.tif'.</p> <code>'.tif'</code> <code>bands</code> <code>list</code> <p>The bands to use for the gif. For example, [0, 1, 2] for RGB, and [0] for grayscale. Defaults to None.</p> <code>None</code> <code>size</code> <code>tuple</code> <p>The size of the gif. For example, (500, 500). Defaults to None, using the original size.</p> <code>None</code> <code>bbox</code> <code>list</code> <p>The bounding box of the gif. For example, [xmin, ymin, xmax, ymax]. Defaults to None, using the original bounding box.</p> <code>None</code> <code>fps</code> <code>int</code> <p>The frames per second of the gif. Defaults to 5.</p> <code>5</code> <code>loop</code> <code>int</code> <p>The number of times to loop the gif. Defaults to 0, looping forever.</p> <code>0</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar to the gif. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>The color of the progress bar, can be color name or hex code. Defaults to 'blue'.</p> <code>'blue'</code> <code>progress_bar_height</code> <code>int</code> <p>The height of the progress bar. Defaults to 5.</p> <code>5</code> <code>add_text</code> <code>bool</code> <p>Whether to add text to the gif. Defaults to False.</p> <code>False</code> <code>text_xy</code> <code>tuple</code> <p>The x, y coordinates of the text. For example, ('10%', '10%'). Defaults to None, using the bottom left corner.</p> <code>None</code> <code>text_sequence</code> <code>list</code> <p>The sequence of text to add to the gif. For example, ['year 1', 'year 2', ...].</p> <code>None</code> <code>font_type</code> <code>str</code> <p>The font type of the text, can be 'arial.ttf' or 'alibaba.otf', or any system font. Defaults to 'arial.ttf'.</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>The font size of the text. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>The color of the text, can be color name or hex code. Defaults to 'black'.</p> <code>'black'</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the gif to mp4. Defaults to False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Whether to print the progress. Defaults to False.</p> <code>True</code> <code>reduce_size</code> <code>bool</code> <p>Whether to reduce the size of the gif using ffmpeg. Defaults to False.</p> <code>False</code> <code>clean_up</code> <code>bool</code> <p>Whether to clean up the temporary files. Defaults to True.</p> <code>True</code> Source code in <code>beamgis/common.py</code> <pre><code>def create_timelapse(\n    images: Union[List, str],\n    out_gif: str,\n    ext: str = \".tif\",\n    bands: Optional[List] = None,\n    size: Optional[Tuple] = None,\n    bbox: Optional[List] = None,\n    fps: int = 5,\n    loop: int = 0,\n    add_progress_bar: bool = True,\n    progress_bar_color: str = \"blue\",\n    progress_bar_height: int = 5,\n    add_text: bool = False,\n    text_xy: Optional[Tuple] = None,\n    text_sequence: Optional[List] = None,\n    font_type: str = \"arial.ttf\",\n    font_size: int = 20,\n    font_color: str = \"black\",\n    mp4: bool = False,\n    quiet: bool = True,\n    reduce_size: bool = False,\n    clean_up: bool = True,\n    **kwargs,\n):\n    \"\"\"Creates a timelapse gif from a list of images.\n\n    Args:\n        images (list | str): The list of images or input directory to create the gif from.\n            For example, '/path/to/images/*.tif' or ['/path/to/image1.tif', '/path/to/image2.tif', ...]\n        out_gif (str): File path to the output gif.\n        ext (str, optional): The extension of the images. Defaults to '.tif'.\n        bands (list, optional): The bands to use for the gif. For example, [0, 1, 2] for RGB, and [0] for grayscale. Defaults to None.\n        size (tuple, optional): The size of the gif. For example, (500, 500). Defaults to None, using the original size.\n        bbox (list, optional): The bounding box of the gif. For example, [xmin, ymin, xmax, ymax]. Defaults to None, using the original bounding box.\n        fps (int, optional): The frames per second of the gif. Defaults to 5.\n        loop (int, optional): The number of times to loop the gif. Defaults to 0, looping forever.\n        add_progress_bar (bool, optional): Whether to add a progress bar to the gif. Defaults to True.\n        progress_bar_color (str, optional): The color of the progress bar, can be color name or hex code. Defaults to 'blue'.\n        progress_bar_height (int, optional): The height of the progress bar. Defaults to 5.\n        add_text (bool, optional): Whether to add text to the gif. Defaults to False.\n        text_xy (tuple, optional): The x, y coordinates of the text. For example, ('10%', '10%').\n            Defaults to None, using the bottom left corner.\n        text_sequence (list, optional): The sequence of text to add to the gif. For example, ['year 1', 'year 2', ...].\n        font_type (str, optional): The font type of the text, can be 'arial.ttf' or 'alibaba.otf', or any system font. Defaults to 'arial.ttf'.\n        font_size (int, optional): The font size of the text. Defaults to 20.\n        font_color (str, optional): The color of the text, can be color name or hex code. Defaults to 'black'.\n        mp4 (bool, optional): Whether to convert the gif to mp4. Defaults to False.\n        quiet (bool, optional): Whether to print the progress. Defaults to False.\n        reduce_size (bool, optional): Whether to reduce the size of the gif using ffmpeg. Defaults to False.\n        clean_up (bool, optional): Whether to clean up the temporary files. Defaults to True.\n\n    \"\"\"\n\n    import glob\n    import tempfile\n\n    if isinstance(images, str):\n        if not images.endswith(ext):\n            images = os.path.join(images, f\"*{ext}\")\n        images = list(glob.glob(images))\n\n    if not isinstance(images, list):\n        raise ValueError(\"images must be a list or a path to the image directory.\")\n\n    images.sort()\n\n    temp_dir = os.path.join(tempfile.gettempdir(), \"timelapse\")\n    if not os.path.exists(temp_dir):\n        os.makedirs(temp_dir)\n\n    if bbox is not None:\n        clip_dir = os.path.join(tempfile.gettempdir(), \"clip\")\n        if not os.path.exists(clip_dir):\n            os.makedirs(clip_dir)\n\n        if len(bbox) == 4:\n            bbox = bbox_to_geojson(bbox)\n\n    else:\n        clip_dir = None\n\n    output = widgets.Output()\n\n    if \"out_ext\" in kwargs:\n        out_ext = kwargs[\"out_ext\"].lower()\n    else:\n        out_ext = \".jpg\"\n\n    try:\n        for index, image in enumerate(images):\n            if bbox is not None:\n                clip_file = os.path.join(clip_dir, os.path.basename(image))\n                with output:\n                    clip_image(image, mask=bbox, output=clip_file, to_cog=False)\n                image = clip_file\n\n            if \"add_prefix\" in kwargs:\n                basename = (\n                    str(f\"{index + 1}\").zfill(len(str(len(images))))\n                    + \"-\"\n                    + os.path.basename(image).replace(ext, out_ext)\n                )\n            else:\n                basename = os.path.basename(image).replace(ext, out_ext)\n            if not quiet:\n                print(f\"Processing {index+1}/{len(images)}: {basename} ...\")\n\n            # ignore GDAL warnings\n            with output:\n                numpy_to_image(\n                    image, os.path.join(temp_dir, basename), bands=bands, size=size\n                )\n        make_gif(\n            temp_dir,\n            out_gif,\n            ext=out_ext,\n            fps=fps,\n            loop=loop,\n            mp4=mp4,\n            clean_up=clean_up,\n        )\n\n        if clip_dir is not None:\n            shutil.rmtree(clip_dir)\n\n        if add_text:\n            add_text_to_gif(\n                out_gif,\n                out_gif,\n                text_xy,\n                text_sequence,\n                font_type,\n                font_size,\n                font_color,\n                add_progress_bar,\n                progress_bar_color,\n                progress_bar_height,\n                1000 / fps,\n                loop,\n            )\n        elif add_progress_bar:\n            add_progress_bar_to_gif(\n                out_gif,\n                out_gif,\n                progress_bar_color,\n                progress_bar_height,\n                1000 / fps,\n                loop,\n            )\n\n        if reduce_size:\n            reduce_gif_size(out_gif)\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#beamgis.common.csv_points_to_shp","title":"<code>csv_points_to_shp(in_csv, out_shp, latitude='latitude', longitude='longitude')</code>","text":"<p>Converts a csv file containing points (latitude, longitude) into a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>File path or HTTP URL to the input csv file. For example, https://raw.githubusercontent.com/opengeos/data/main/world/world_cities.csv</p> required <code>out_shp</code> <code>str</code> <p>File path to the output shapefile.</p> required <code>latitude</code> <code>str</code> <p>Column name for the latitude column. Defaults to 'latitude'.</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>Column name for the longitude column. Defaults to 'longitude'.</p> <code>'longitude'</code> Source code in <code>beamgis/common.py</code> <pre><code>def csv_points_to_shp(in_csv, out_shp, latitude=\"latitude\", longitude=\"longitude\"):\n    \"\"\"Converts a csv file containing points (latitude, longitude) into a shapefile.\n\n    Args:\n        in_csv (str): File path or HTTP URL to the input csv file. For example, https://raw.githubusercontent.com/opengeos/data/main/world/world_cities.csv\n        out_shp (str): File path to the output shapefile.\n        latitude (str, optional): Column name for the latitude column. Defaults to 'latitude'.\n        longitude (str, optional): Column name for the longitude column. Defaults to 'longitude'.\n\n    \"\"\"\n\n    if in_csv.startswith(\"http\") and in_csv.endswith(\".csv\"):\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        out_name = os.path.basename(in_csv)\n\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n        download_from_url(in_csv, out_dir=out_dir)\n        in_csv = os.path.join(out_dir, out_name)\n\n    wbt = whitebox.WhiteboxTools()\n    in_csv = os.path.abspath(in_csv)\n    out_shp = os.path.abspath(out_shp)\n\n    if not os.path.exists(in_csv):\n        raise Exception(\"The provided csv file does not exist.\")\n\n    with open(in_csv, encoding=\"utf-8\") as csv_file:\n        reader = csv.DictReader(csv_file)\n        fields = reader.fieldnames\n        xfield = fields.index(longitude)\n        yfield = fields.index(latitude)\n\n    wbt.csv_points_to_vector(in_csv, out_shp, xfield=xfield, yfield=yfield, epsg=4326)\n</code></pre>"},{"location":"common/#beamgis.common.csv_to_df","title":"<code>csv_to_df(in_csv, **kwargs)</code>","text":"<p>Converts a CSV file to pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>File path to the input CSV.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pandas DataFrame</p> Source code in <code>beamgis/common.py</code> <pre><code>def csv_to_df(in_csv, **kwargs):\n    \"\"\"Converts a CSV file to pandas dataframe.\n\n    Args:\n        in_csv (str): File path to the input CSV.\n\n    Returns:\n        pd.DataFrame: pandas DataFrame\n    \"\"\"\n    import pandas as pd\n\n    try:\n        return pd.read_csv(in_csv, **kwargs)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.csv_to_gdf","title":"<code>csv_to_gdf(in_csv, latitude='latitude', longitude='longitude', geometry=None, crs='EPSG:4326', encoding='utf-8', **kwargs)</code>","text":"<p>Creates points for a CSV file and converts them to a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The file path to the input CSV file.</p> required <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>geometry</code> <code>str</code> <p>The name of the column containing geometry. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The coordinate reference system. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Returns:</p> Type Description <code>object</code> <p>GeoDataFrame.</p> Source code in <code>beamgis/common.py</code> <pre><code>def csv_to_gdf(\n    in_csv,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    geometry=None,\n    crs=\"EPSG:4326\",\n    encoding=\"utf-8\",\n    **kwargs,\n):\n    \"\"\"Creates points for a CSV file and converts them to a GeoDataFrame.\n\n    Args:\n        in_csv (str): The file path to the input CSV file.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        geometry (str, optional): The name of the column containing geometry. Defaults to None.\n        crs (str, optional): The coordinate reference system. Defaults to \"EPSG:4326\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n\n    Returns:\n        object: GeoDataFrame.\n    \"\"\"\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n    import pandas as pd\n    from shapely import wkt\n\n    out_dir = os.getcwd()\n\n    if geometry is None:\n        out_geojson = os.path.join(out_dir, random_string() + \".geojson\")\n        csv_to_geojson(in_csv, out_geojson, latitude, longitude, encoding=encoding)\n\n        gdf = gpd.read_file(out_geojson)\n        os.remove(out_geojson)\n    else:\n        df = pd.read_csv(in_csv, encoding=encoding)\n        df[\"geometry\"] = df[geometry].apply(wkt.loads)\n        gdf = gpd.GeoDataFrame(df, geometry=\"geometry\", crs=crs, **kwargs)\n    return gdf\n</code></pre>"},{"location":"common/#beamgis.common.csv_to_geojson","title":"<code>csv_to_geojson(in_csv, out_geojson=None, latitude='latitude', longitude='longitude', encoding='utf-8')</code>","text":"<p>Creates points for a CSV file and exports data as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The file path to the input CSV file.</p> required <code>out_geojson</code> <code>str</code> <p>The file path to the exported GeoJSON. Default to None.</p> <code>None</code> <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>beamgis/common.py</code> <pre><code>def csv_to_geojson(\n    in_csv,\n    out_geojson=None,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    encoding=\"utf-8\",\n):\n    \"\"\"Creates points for a CSV file and exports data as a GeoJSON.\n\n    Args:\n        in_csv (str): The file path to the input CSV file.\n        out_geojson (str): The file path to the exported GeoJSON. Default to None.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n\n    \"\"\"\n\n    import pandas as pd\n\n    in_csv = github_raw_url(in_csv)\n\n    if out_geojson is not None:\n        out_geojson = check_file_path(out_geojson)\n\n    df = pd.read_csv(in_csv)\n    geojson = df_to_geojson(\n        df, latitude=latitude, longitude=longitude, encoding=encoding\n    )\n\n    if out_geojson is None:\n        return geojson\n    else:\n        with open(out_geojson, \"w\", encoding=encoding) as f:\n            f.write(json.dumps(geojson))\n</code></pre>"},{"location":"common/#beamgis.common.csv_to_shp","title":"<code>csv_to_shp(in_csv, out_shp, latitude='latitude', longitude='longitude', encoding='utf-8')</code>","text":"<p>Converts a csv file with latlon info to a point shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The input csv file containing longitude and latitude columns.</p> required <code>out_shp</code> <code>str</code> <p>The file path to the output shapefile.</p> required <code>latitude</code> <code>str</code> <p>The column name of the latitude column. Defaults to 'latitude'.</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The column name of the longitude column. Defaults to 'longitude'.</p> <code>'longitude'</code> Source code in <code>beamgis/common.py</code> <pre><code>def csv_to_shp(\n    in_csv, out_shp, latitude=\"latitude\", longitude=\"longitude\", encoding=\"utf-8\"\n):\n    \"\"\"Converts a csv file with latlon info to a point shapefile.\n\n    Args:\n        in_csv (str): The input csv file containing longitude and latitude columns.\n        out_shp (str): The file path to the output shapefile.\n        latitude (str, optional): The column name of the latitude column. Defaults to 'latitude'.\n        longitude (str, optional): The column name of the longitude column. Defaults to 'longitude'.\n    \"\"\"\n    import shapefile as shp\n\n    if in_csv.startswith(\"http\") and in_csv.endswith(\".csv\"):\n        in_csv = github_raw_url(in_csv)\n        in_csv = download_file(in_csv, quiet=True, overwrite=True)\n\n    try:\n        points = shp.Writer(out_shp, shapeType=shp.POINT)\n        with open(in_csv, encoding=encoding) as csvfile:\n            csvreader = csv.DictReader(csvfile)\n            header = csvreader.fieldnames\n            [points.field(field) for field in header]\n            for row in csvreader:\n                points.point((float(row[longitude])), (float(row[latitude])))\n                points.record(*tuple([row[f] for f in header]))\n\n        out_prj = out_shp.replace(\".shp\", \".prj\")\n        with open(out_prj, \"w\") as f:\n            prj_str = 'GEOGCS[\"GCS_WGS_1984\",DATUM[\"D_WGS_1984\",SPHEROID[\"WGS_1984\",6378137,298.257223563]],PRIMEM[\"Greenwich\",0],UNIT[\"Degree\",0.0174532925199433]] '\n            f.write(prj_str)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.csv_to_vector","title":"<code>csv_to_vector(in_csv, output, latitude='latitude', longitude='longitude', geometry=None, crs='EPSG:4326', encoding='utf-8', **kwargs)</code>","text":"<p>Creates points for a CSV file and converts them to a vector dataset.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The file path to the input CSV file.</p> required <code>output</code> <code>str</code> <p>The file path to the output vector dataset.</p> required <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>geometry</code> <code>str</code> <p>The name of the column containing geometry. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The coordinate reference system. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to gdf.to_file().</p> <code>{}</code> Source code in <code>beamgis/common.py</code> <pre><code>def csv_to_vector(\n    in_csv,\n    output,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    geometry=None,\n    crs=\"EPSG:4326\",\n    encoding=\"utf-8\",\n    **kwargs,\n):\n    \"\"\"Creates points for a CSV file and converts them to a vector dataset.\n\n    Args:\n        in_csv (str): The file path to the input CSV file.\n        output (str): The file path to the output vector dataset.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        geometry (str, optional): The name of the column containing geometry. Defaults to None.\n        crs (str, optional): The coordinate reference system. Defaults to \"EPSG:4326\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n        **kwargs: Additional keyword arguments to pass to gdf.to_file().\n\n    \"\"\"\n    gdf = csv_to_gdf(in_csv, latitude, longitude, geometry, crs, encoding)\n    gdf.to_file(output, **kwargs)\n</code></pre>"},{"location":"common/#beamgis.common.d2s_tile","title":"<code>d2s_tile(url, titiler_endpoint=None, **kwargs)</code>","text":"<p>Generate a D2S tile URL with optional API key.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The base URL for the tile.</p> required <code>titiler_endpoint</code> <code>str</code> <p>The endpoint for the titiler service. Defaults to \"https://tt.d2s.org\".</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the cog_stats function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The modified URL with the API key if required, otherwise the original URL.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key is required but not set in the environment variables.</p> Source code in <code>beamgis/common.py</code> <pre><code>def d2s_tile(url: str, titiler_endpoint: str = None, **kwargs: Any) -&gt; str:\n    \"\"\"Generate a D2S tile URL with optional API key.\n\n    Args:\n        url (str): The base URL for the tile.\n        titiler_endpoint (str, optional): The endpoint for the titiler service.\n            Defaults to \"https://tt.d2s.org\".\n        **kwargs (Any): Additional keyword arguments to pass to the cog_stats function.\n\n    Returns:\n        str: The modified URL with the API key if required, otherwise the original URL.\n\n    Raises:\n        ValueError: If the API key is required but not set in the environment variables.\n    \"\"\"\n\n    if titiler_endpoint is None:\n        titiler_endpoint = os.environ.get(\"TITILER_ENDPOINT\", \"https://titiler.xyz\")\n\n    stats = cog_stats(url, titiler_endpoint=titiler_endpoint, **kwargs)\n    if \"detail\" in stats:\n        api_key = get_api_key(\"D2S_API_KEY\")\n        if api_key is None:\n            raise ValueError(\"Please set the D2S_API_KEY environment variable.\")\n        else:\n            return f\"{url}?API_KEY={api_key}\"\n    else:\n        return url\n</code></pre>"},{"location":"common/#beamgis.common.delete_shp","title":"<code>delete_shp(in_shp, verbose=False)</code>","text":"<p>Deletes a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>The input shapefile to delete.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print out descriptive text. Defaults to True.</p> <code>False</code> Source code in <code>beamgis/common.py</code> <pre><code>def delete_shp(in_shp, verbose=False):\n    \"\"\"Deletes a shapefile.\n\n    Args:\n        in_shp (str): The input shapefile to delete.\n        verbose (bool, optional): Whether to print out descriptive text. Defaults to True.\n    \"\"\"\n    from pathlib import Path\n\n    in_shp = os.path.abspath(in_shp)\n    in_dir = os.path.dirname(in_shp)\n    basename = os.path.basename(in_shp).replace(\".shp\", \"\")\n\n    files = Path(in_dir).rglob(basename + \".*\")\n\n    for file in files:\n        filepath = os.path.join(in_dir, str(file))\n        os.remove(filepath)\n        if verbose:\n            print(f\"Deleted {filepath}\")\n</code></pre>"},{"location":"common/#beamgis.common.df_to_gdf","title":"<code>df_to_gdf(df, geometry='geometry', src_crs='EPSG:4326', dst_crs=None, **kwargs)</code>","text":"<p>Converts a pandas DataFrame to a GeoPandas GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>The pandas DataFrame to convert.</p> required <code>geometry</code> <code>str</code> <p>The name of the geometry column in the DataFrame.</p> <code>'geometry'</code> <code>src_crs</code> <code>str</code> <p>The coordinate reference system (CRS) of the GeoDataFrame. Default is \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>dst_crs</code> <code>str</code> <p>The target CRS of the GeoDataFrame. Default is None</p> <code>None</code> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>The converted GeoPandas GeoDataFrame.</p> Source code in <code>beamgis/common.py</code> <pre><code>def df_to_gdf(df, geometry=\"geometry\", src_crs=\"EPSG:4326\", dst_crs=None, **kwargs):\n    \"\"\"\n    Converts a pandas DataFrame to a GeoPandas GeoDataFrame.\n\n    Args:\n        df (pandas.DataFrame): The pandas DataFrame to convert.\n        geometry (str): The name of the geometry column in the DataFrame.\n        src_crs (str): The coordinate reference system (CRS) of the GeoDataFrame. Default is \"EPSG:4326\".\n        dst_crs (str): The target CRS of the GeoDataFrame. Default is None\n\n    Returns:\n        geopandas.GeoDataFrame: The converted GeoPandas GeoDataFrame.\n    \"\"\"\n    import geopandas as gpd\n    from shapely import wkt\n\n    # Convert the geometry column to Shapely geometry objects\n    df[geometry] = df[geometry].apply(lambda x: wkt.loads(x))\n\n    # Convert the pandas DataFrame to a GeoPandas GeoDataFrame\n    gdf = gpd.GeoDataFrame(df, geometry=geometry, crs=src_crs, **kwargs)\n    if dst_crs is not None and dst_crs != src_crs:\n        gdf = gdf.to_crs(dst_crs)\n\n    return gdf\n</code></pre>"},{"location":"common/#beamgis.common.df_to_geojson","title":"<code>df_to_geojson(df, out_geojson=None, latitude='latitude', longitude='longitude', encoding='utf-8')</code>","text":"<p>Creates points for a Pandas DataFrame and exports data as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>The input Pandas DataFrame.</p> required <code>out_geojson</code> <code>str</code> <p>The file path to the exported GeoJSON. Default to None.</p> <code>None</code> <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>beamgis/common.py</code> <pre><code>def df_to_geojson(\n    df,\n    out_geojson=None,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    encoding=\"utf-8\",\n):\n    \"\"\"Creates points for a Pandas DataFrame and exports data as a GeoJSON.\n\n    Args:\n        df (pandas.DataFrame): The input Pandas DataFrame.\n        out_geojson (str): The file path to the exported GeoJSON. Default to None.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n\n    \"\"\"\n\n    import json\n    from geojson import Feature, FeatureCollection, Point\n\n    if out_geojson is not None:\n        out_dir = os.path.dirname(os.path.abspath(out_geojson))\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n    features = df.apply(\n        lambda row: Feature(\n            geometry=Point((float(row[longitude]), float(row[latitude]))),\n            properties=dict(row),\n        ),\n        axis=1,\n    ).tolist()\n\n    geojson = FeatureCollection(features=features)\n\n    if out_geojson is None:\n        return geojson\n    else:\n        with open(out_geojson, \"w\", encoding=encoding) as f:\n            f.write(json.dumps(geojson))\n</code></pre>"},{"location":"common/#beamgis.common.dict_to_json","title":"<code>dict_to_json(data, file_path, indent=4)</code>","text":"<p>Writes a dictionary to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A dictionary.</p> required <code>file_path</code> <code>str</code> <p>The path to the JSON file.</p> required <code>indent</code> <code>int</code> <p>The indentation of the JSON file. Defaults to 4.</p> <code>4</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If the input data is not a dictionary.</p> Source code in <code>beamgis/common.py</code> <pre><code>def dict_to_json(data, file_path, indent=4):\n    \"\"\"Writes a dictionary to a JSON file.\n\n    Args:\n        data (dict): A dictionary.\n        file_path (str): The path to the JSON file.\n        indent (int, optional): The indentation of the JSON file. Defaults to 4.\n\n    Raises:\n        TypeError: If the input data is not a dictionary.\n    \"\"\"\n    import json\n\n    file_path = check_file_path(file_path)\n\n    if isinstance(data, dict):\n        with open(file_path, \"w\") as f:\n            json.dump(data, f, indent=indent)\n    else:\n        raise TypeError(\"The provided data must be a dictionary.\")\n</code></pre>"},{"location":"common/#beamgis.common.disjoint","title":"<code>disjoint(input_features, selecting_features, output=None, **kwargs)</code>","text":"<p>Find the features in the input_features that do not intersect the selecting_features.</p> <p>Parameters:</p> Name Type Description Default <code>input_features</code> <code>str | GeoDataFrame</code> <p>The input features to select from. Can be a file path or a GeoDataFrame.</p> required <code>selecting_features</code> <code>str | GeoDataFrame</code> <p>The features in the Input Features parameter will be selected based on their relationship to the features from this layer.</p> required <code>output</code> <code>are</code> <p>The output path to save the GeoDataFrame in a vector format (e.g., shapefile). Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str | GeoDataFrame</code> <p>The path to the output file or the GeoDataFrame.</p> Source code in <code>beamgis/common.py</code> <pre><code>def disjoint(input_features, selecting_features, output=None, **kwargs):\n    \"\"\"Find the features in the input_features that do not intersect the selecting_features.\n\n    Args:\n        input_features (str | GeoDataFrame): The input features to select from. Can be a file path or a GeoDataFrame.\n        selecting_features (str | GeoDataFrame): The features in the Input Features parameter will be selected based\n            on their relationship to the features from this layer.\n        output (are, optional): The output path to save the GeoDataFrame in a vector format (e.g., shapefile). Defaults to None.\n\n    Returns:\n        str | GeoDataFrame: The path to the output file or the GeoDataFrame.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(input_features, str):\n        input_features = gpd.read_file(input_features, **kwargs)\n    elif not isinstance(input_features, gpd.GeoDataFrame):\n        raise TypeError(\"input_features must be a file path or a GeoDataFrame\")\n\n    if isinstance(selecting_features, str):\n        selecting_features = gpd.read_file(selecting_features, **kwargs)\n    elif not isinstance(selecting_features, gpd.GeoDataFrame):\n        raise TypeError(\"selecting_features must be a file path or a GeoDataFrame\")\n\n    selecting_features = selecting_features.to_crs(input_features.crs)\n\n    input_features[\"savedindex\"] = input_features.index\n    intersecting = selecting_features.sjoin(input_features, how=\"inner\")[\"savedindex\"]\n    results = input_features[~input_features.savedindex.isin(intersecting)].drop(\n        columns=[\"savedindex\"], axis=1\n    )\n\n    if output is not None:\n        results.to_file(output, **kwargs)\n    else:\n        return results\n</code></pre>"},{"location":"common/#beamgis.common.display_html","title":"<code>display_html(html, width='100%', height=500)</code>","text":"<p>Displays an HTML file or HTML string in a Jupyter Notebook.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>Union[str, bytes]</code> <p>Path to an HTML file or an HTML string.</p> required <code>width</code> <code>str</code> <p>Width of the displayed iframe. Default is '100%'.</p> <code>'100%'</code> <code>height</code> <code>int</code> <p>Height of the displayed iframe. Default is 500.</p> <code>500</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>beamgis/common.py</code> <pre><code>def display_html(\n    html: Union[str, bytes], width: str = \"100%\", height: int = 500\n) -&gt; None:\n    \"\"\"\n    Displays an HTML file or HTML string in a Jupyter Notebook.\n\n    Args:\n        html (Union[str, bytes]): Path to an HTML file or an HTML string.\n        width (str, optional): Width of the displayed iframe. Default is '100%'.\n        height (int, optional): Height of the displayed iframe. Default is 500.\n\n    Returns:\n        None\n    \"\"\"\n    from IPython.display import IFrame, display\n\n    if isinstance(html, str) and html.startswith(\"&lt;\"):\n        # If the input is an HTML string\n        html_content = html\n    elif isinstance(html, str):\n        # If the input is a file path\n        with open(html, \"r\") as file:\n            html_content = file.read()\n    elif isinstance(html, bytes):\n        # If the input is a byte string\n        html_content = html.decode(\"utf-8\")\n    else:\n        raise ValueError(\"Invalid input type. Expected a file path or an HTML string.\")\n\n    display(IFrame(src=html_content, width=width, height=height))\n</code></pre>"},{"location":"common/#beamgis.common.download_file","title":"<code>download_file(url=None, output=None, quiet=False, proxy=None, speed=None, use_cookies=True, verify=True, id=None, fuzzy=False, resume=False, unzip=True, overwrite=False, subfolder=False)</code>","text":"<p>Download a file from URL, including Google Drive shared URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Google Drive URL is also supported. Defaults to None.</p> <code>None</code> <code>output</code> <code>str</code> <p>Output filename. Default is basename of URL.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress terminal output. Default is False.</p> <code>False</code> <code>proxy</code> <code>str</code> <p>Proxy. Defaults to None.</p> <code>None</code> <code>speed</code> <code>float</code> <p>Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.</p> <code>None</code> <code>use_cookies</code> <code>bool</code> <p>Flag to use cookies. Defaults to True.</p> <code>True</code> <code>verify</code> <code>bool | str</code> <p>Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.</p> <code>True</code> <code>id</code> <code>str</code> <p>Google Drive's file ID. Defaults to None.</p> <code>None</code> <code>fuzzy</code> <code>bool</code> <p>Fuzzy extraction of Google Drive's file Id. Defaults to False.</p> <code>False</code> <code>resume</code> <code>bool</code> <p>Resume the download from existing tmp file if possible. Defaults to False.</p> <code>False</code> <code>unzip</code> <code>bool</code> <p>Unzip the file. Defaults to True.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the file if it already exists. Defaults to False.</p> <code>False</code> <code>subfolder</code> <code>bool</code> <p>Create a subfolder with the same name as the file. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The output file path.</p> Source code in <code>beamgis/common.py</code> <pre><code>def download_file(\n    url=None,\n    output=None,\n    quiet=False,\n    proxy=None,\n    speed=None,\n    use_cookies=True,\n    verify=True,\n    id=None,\n    fuzzy=False,\n    resume=False,\n    unzip=True,\n    overwrite=False,\n    subfolder=False,\n):\n    \"\"\"Download a file from URL, including Google Drive shared URL.\n\n    Args:\n        url (str, optional): Google Drive URL is also supported. Defaults to None.\n        output (str, optional): Output filename. Default is basename of URL.\n        quiet (bool, optional): Suppress terminal output. Default is False.\n        proxy (str, optional): Proxy. Defaults to None.\n        speed (float, optional): Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.\n        use_cookies (bool, optional): Flag to use cookies. Defaults to True.\n        verify (bool | str, optional): Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string,\n            in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.\n        id (str, optional): Google Drive's file ID. Defaults to None.\n        fuzzy (bool, optional): Fuzzy extraction of Google Drive's file Id. Defaults to False.\n        resume (bool, optional): Resume the download from existing tmp file if possible. Defaults to False.\n        unzip (bool, optional): Unzip the file. Defaults to True.\n        overwrite (bool, optional): Overwrite the file if it already exists. Defaults to False.\n        subfolder (bool, optional): Create a subfolder with the same name as the file. Defaults to False.\n\n    Returns:\n        str: The output file path.\n    \"\"\"\n    try:\n        import gdown\n    except ImportError:\n        print(\n            \"The gdown package is required for this function. Use `pip install gdown` to install it.\"\n        )\n        return\n\n    if output is None:\n        if isinstance(url, str) and url.startswith(\"http\"):\n            output = os.path.basename(url)\n\n    out_dir = os.path.abspath(os.path.dirname(output))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if isinstance(url, str):\n        if os.path.exists(os.path.abspath(output)) and (not overwrite):\n            print(\n                f\"{output} already exists. Skip downloading. Set overwrite=True to overwrite.\"\n            )\n            return os.path.abspath(output)\n        else:\n            url = github_raw_url(url)\n\n    if \"https://drive.google.com/file/d/\" in url:\n        fuzzy = True\n\n    output = gdown.download(\n        url, output, quiet, proxy, speed, use_cookies, verify, id, fuzzy, resume\n    )\n\n    if unzip:\n        if output.endswith(\".zip\"):\n            with zipfile.ZipFile(output, \"r\") as zip_ref:\n                if not quiet:\n                    print(\"Extracting files...\")\n                if subfolder:\n                    basename = os.path.splitext(os.path.basename(output))[0]\n\n                    output = os.path.join(out_dir, basename)\n                    if not os.path.exists(output):\n                        os.makedirs(output)\n                    zip_ref.extractall(output)\n                else:\n                    zip_ref.extractall(os.path.dirname(output))\n        elif output.endswith(\".tar.gz\") or output.endswith(\".tar\"):\n            if output.endswith(\".tar.gz\"):\n                mode = \"r:gz\"\n            else:\n                mode = \"r\"\n\n            with tarfile.open(output, mode) as tar_ref:\n                if not quiet:\n                    print(\"Extracting files...\")\n                if subfolder:\n                    basename = os.path.splitext(os.path.basename(output))[0]\n                    output = os.path.join(out_dir, basename)\n                    if not os.path.exists(output):\n                        os.makedirs(output)\n                    tar_ref.extractall(output)\n                else:\n                    tar_ref.extractall(os.path.dirname(output))\n\n    return os.path.abspath(output)\n</code></pre>"},{"location":"common/#beamgis.common.download_file_lite","title":"<code>download_file_lite(url, output=None, binary=False, overwrite=False, **kwargs)</code>  <code>async</code>","text":"<p>Download a file using Pyodide. This function is only available on JupyterLite. Call the function with await, such as await download_file_lite(url).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the file.</p> required <code>output</code> <code>str</code> <p>The local path to save the file. Defaults to None.</p> <code>None</code> <code>binary</code> <code>bool</code> <p>Whether the file is binary. Defaults to False.</p> <code>False</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the file if it exists. Defaults to False.</p> <code>False</code> Source code in <code>beamgis/common.py</code> <pre><code>async def download_file_lite(url, output=None, binary=False, overwrite=False, **kwargs):\n    \"\"\"Download a file using Pyodide. This function is only available on JupyterLite. Call the function with await, such as await download_file_lite(url).\n\n    Args:\n        url (str): The URL of the file.\n        output (str, optional): The local path to save the file. Defaults to None.\n        binary (bool, optional): Whether the file is binary. Defaults to False.\n        overwrite (bool, optional): Whether to overwrite the file if it exists. Defaults to False.\n    \"\"\"\n    import sys\n    import pyodide  # pylint: disable=E0401\n\n    if \"pyodide\" not in sys.modules:\n        raise ValueError(\"Pyodide is not available.\")\n\n    if output is None:\n        output = os.path.basename(url)\n\n    output = os.path.abspath(output)\n\n    ext = os.path.splitext(output)[1]\n\n    if ext in [\".png\", \"jpg\", \".tif\", \".tiff\", \"zip\", \"gz\", \"bz2\", \"xz\"]:\n        binary = True\n\n    if os.path.exists(output) and not overwrite:\n        print(f\"{output} already exists, skip downloading.\")\n        return output\n\n    if binary:\n        response = await pyodide.http.pyfetch(url)\n        with open(output, \"wb\") as f:\n            f.write(await response.bytes())\n\n    else:\n        obj = pyodide.http.open_url(url)\n        with open(output, \"w\") as fd:\n            shutil.copyfileobj(obj, fd)\n\n    return output\n</code></pre>"},{"location":"common/#beamgis.common.download_files","title":"<code>download_files(urls, out_dir=None, filenames=None, quiet=False, proxy=None, speed=None, use_cookies=True, verify=True, id=None, fuzzy=False, resume=False, unzip=True, overwrite=False, subfolder=False, multi_part=False)</code>","text":"<p>Download files from URLs, including Google Drive shared URL.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>list</code> <p>The list of urls to download. Google Drive URL is also supported.</p> required <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to None.</p> <code>None</code> <code>filenames</code> <code>list</code> <p>Output filename. Default is basename of URL.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress terminal output. Default is False.</p> <code>False</code> <code>proxy</code> <code>str</code> <p>Proxy. Defaults to None.</p> <code>None</code> <code>speed</code> <code>float</code> <p>Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.</p> <code>None</code> <code>use_cookies</code> <code>bool</code> <p>Flag to use cookies. Defaults to True.</p> <code>True</code> <code>verify</code> <code>bool | str</code> <p>Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.</p> <code>True</code> <code>id</code> <code>str</code> <p>Google Drive's file ID. Defaults to None.</p> <code>None</code> <code>fuzzy</code> <code>bool</code> <p>Fuzzy extraction of Google Drive's file Id. Defaults to False.</p> <code>False</code> <code>resume</code> <code>bool</code> <p>Resume the download from existing tmp file if possible. Defaults to False.</p> <code>False</code> <code>unzip</code> <code>bool</code> <p>Unzip the file. Defaults to True.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the file if it already exists. Defaults to False.</p> <code>False</code> <code>subfolder</code> <code>bool</code> <p>Create a subfolder with the same name as the file. Defaults to False.</p> <code>False</code> <code>multi_part</code> <code>bool</code> <p>If the file is a multi-part file. Defaults to False.</p> <code>False</code> <p>Examples:</p> <p>files = [\"sam_hq_vit_tiny.zip\", \"sam_hq_vit_tiny.z01\", \"sam_hq_vit_tiny.z02\", \"sam_hq_vit_tiny.z03\"] base_url = \"https://github.com/opengeos/datasets/releases/download/models/\" urls = [base_url + f for f in files] leafmap.download_files(urls, out_dir=\"models\", multi_part=True)</p> Source code in <code>beamgis/common.py</code> <pre><code>def download_files(\n    urls,\n    out_dir=None,\n    filenames=None,\n    quiet=False,\n    proxy=None,\n    speed=None,\n    use_cookies=True,\n    verify=True,\n    id=None,\n    fuzzy=False,\n    resume=False,\n    unzip=True,\n    overwrite=False,\n    subfolder=False,\n    multi_part=False,\n):\n    \"\"\"Download files from URLs, including Google Drive shared URL.\n\n    Args:\n        urls (list): The list of urls to download. Google Drive URL is also supported.\n        out_dir (str, optional): The output directory. Defaults to None.\n        filenames (list, optional): Output filename. Default is basename of URL.\n        quiet (bool, optional): Suppress terminal output. Default is False.\n        proxy (str, optional): Proxy. Defaults to None.\n        speed (float, optional): Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.\n        use_cookies (bool, optional): Flag to use cookies. Defaults to True.\n        verify (bool | str, optional): Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.\n        id (str, optional): Google Drive's file ID. Defaults to None.\n        fuzzy (bool, optional): Fuzzy extraction of Google Drive's file Id. Defaults to False.\n        resume (bool, optional): Resume the download from existing tmp file if possible. Defaults to False.\n        unzip (bool, optional): Unzip the file. Defaults to True.\n        overwrite (bool, optional): Overwrite the file if it already exists. Defaults to False.\n        subfolder (bool, optional): Create a subfolder with the same name as the file. Defaults to False.\n        multi_part (bool, optional): If the file is a multi-part file. Defaults to False.\n\n    Examples:\n\n        files = [\"sam_hq_vit_tiny.zip\", \"sam_hq_vit_tiny.z01\", \"sam_hq_vit_tiny.z02\", \"sam_hq_vit_tiny.z03\"]\n        base_url = \"https://github.com/opengeos/datasets/releases/download/models/\"\n        urls = [base_url + f for f in files]\n        leafmap.download_files(urls, out_dir=\"models\", multi_part=True)\n    \"\"\"\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if filenames is None:\n        filenames = [None] * len(urls)\n\n    filepaths = []\n    for url, output in zip(urls, filenames):\n        if output is None:\n            filename = os.path.join(out_dir, os.path.basename(url))\n        else:\n            filename = os.path.join(out_dir, output)\n\n        filepaths.append(filename)\n        if multi_part:\n            unzip = False\n\n        download_file(\n            url,\n            filename,\n            quiet,\n            proxy,\n            speed,\n            use_cookies,\n            verify,\n            id,\n            fuzzy,\n            resume,\n            unzip,\n            overwrite,\n            subfolder,\n        )\n\n    if multi_part:\n        archive = os.path.splitext(filename)[0] + \".zip\"\n        out_dir = os.path.dirname(filename)\n        extract_archive(archive, out_dir)\n\n        for file in filepaths:\n            os.remove(file)\n</code></pre>"},{"location":"common/#beamgis.common.download_folder","title":"<code>download_folder(url=None, id=None, output=None, quiet=False, proxy=None, speed=None, use_cookies=True, remaining_ok=False)</code>","text":"<p>Downloads the entire folder from URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the Google Drive folder. Must be of the format 'https://drive.google.com/drive/folders/{url}'. Defaults to None.</p> <code>None</code> <code>id</code> <code>str</code> <p>Google Drive's folder ID. Defaults to None.</p> <code>None</code> <code>output</code> <code>str</code> <p>String containing the path of the output folder. Defaults to current working directory.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress terminal output. Defaults to False.</p> <code>False</code> <code>proxy</code> <code>str</code> <p>Proxy. Defaults to None.</p> <code>None</code> <code>speed</code> <code>float</code> <p>Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.</p> <code>None</code> <code>use_cookies</code> <code>bool</code> <p>Flag to use cookies. Defaults to True.</p> <code>True</code> <code>resume</code> <code>bool</code> <p>Resume the download from existing tmp file if possible. Defaults to False.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of files downloaded, or None if failed.</p> Source code in <code>beamgis/common.py</code> <pre><code>def download_folder(\n    url=None,\n    id=None,\n    output=None,\n    quiet=False,\n    proxy=None,\n    speed=None,\n    use_cookies=True,\n    remaining_ok=False,\n):\n    \"\"\"Downloads the entire folder from URL.\n\n    Args:\n        url (str, optional): URL of the Google Drive folder. Must be of the format 'https://drive.google.com/drive/folders/{url}'. Defaults to None.\n        id (str, optional): Google Drive's folder ID. Defaults to None.\n        output (str, optional):  String containing the path of the output folder. Defaults to current working directory.\n        quiet (bool, optional): Suppress terminal output. Defaults to False.\n        proxy (str, optional): Proxy. Defaults to None.\n        speed (float, optional): Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.\n        use_cookies (bool, optional): Flag to use cookies. Defaults to True.\n        resume (bool, optional): Resume the download from existing tmp file if possible. Defaults to False.\n\n    Returns:\n        list: List of files downloaded, or None if failed.\n    \"\"\"\n\n    try:\n        import gdown\n    except ImportError:\n        print(\n            \"The gdown package is required for this function. Use `pip install gdown` to install it.\"\n        )\n        return\n\n    files = gdown.download_folder(\n        url, id, output, quiet, proxy, speed, use_cookies, remaining_ok\n    )\n    return files\n</code></pre>"},{"location":"common/#beamgis.common.download_from_url","title":"<code>download_from_url(url, out_file_name=None, out_dir='.', unzip=True, verbose=True)</code>","text":"<p>Download a file from a URL (e.g., https://github.com/opengeos/whitebox-python/raw/master/examples/testdata.zip)</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The HTTP URL to download.</p> required <code>out_file_name</code> <code>str</code> <p>The output file name to use. Defaults to None.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The output directory to use. Defaults to '.'.</p> <code>'.'</code> <code>unzip</code> <code>bool</code> <p>Whether to unzip the downloaded file if it is a zip file. Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Whether to display or not the output of the function</p> <code>True</code> Source code in <code>beamgis/common.py</code> <pre><code>def download_from_url(\n    url: str,\n    out_file_name: Optional[str] = None,\n    out_dir: Optional[str] = \".\",\n    unzip: Optional[bool] = True,\n    verbose: Optional[bool] = True,\n):\n    \"\"\"Download a file from a URL (e.g., https://github.com/opengeos/whitebox-python/raw/master/examples/testdata.zip)\n\n    Args:\n        url (str): The HTTP URL to download.\n        out_file_name (str, optional): The output file name to use. Defaults to None.\n        out_dir (str, optional): The output directory to use. Defaults to '.'.\n        unzip (bool, optional): Whether to unzip the downloaded file if it is a zip file. Defaults to True.\n        verbose (bool, optional): Whether to display or not the output of the function\n    \"\"\"\n    in_file_name = os.path.basename(url)\n    out_dir = check_dir(out_dir)\n\n    if out_file_name is None:\n        out_file_name = in_file_name\n    out_file_path = os.path.join(out_dir, out_file_name)\n\n    if verbose:\n        print(\"Downloading {} ...\".format(url))\n\n    try:\n        urllib.request.urlretrieve(url, out_file_path)\n    except Exception:\n        raise Exception(\"The URL is invalid. Please double check the URL.\")\n\n    final_path = out_file_path\n\n    if unzip:\n        # if it is a zip file\n        if \".zip\" in out_file_name:\n            if verbose:\n                print(\"Unzipping {} ...\".format(out_file_name))\n            with zipfile.ZipFile(out_file_path, \"r\") as zip_ref:\n                zip_ref.extractall(out_dir)\n            final_path = os.path.join(\n                os.path.abspath(out_dir), out_file_name.replace(\".zip\", \"\")\n            )\n\n        # if it is a tar file\n        if \".tar\" in out_file_name:\n            if verbose:\n                print(\"Unzipping {} ...\".format(out_file_name))\n            with tarfile.open(out_file_path, \"r\") as tar_ref:\n                with tarfile.open(out_file_path, \"r\") as tar_ref:\n\n                    def is_within_directory(directory, target):\n                        abs_directory = os.path.abspath(directory)\n                        abs_target = os.path.abspath(target)\n\n                        prefix = os.path.commonprefix([abs_directory, abs_target])\n\n                        return prefix == abs_directory\n\n                    def safe_extract(\n                        tar, path=\".\", members=None, *, numeric_owner=False\n                    ):\n                        for member in tar.getmembers():\n                            member_path = os.path.join(path, member.name)\n                            if not is_within_directory(path, member_path):\n                                raise Exception(\"Attempted Path Traversal in Tar File\")\n\n                        tar.extractall(path, members, numeric_owner=numeric_owner)\n\n                    safe_extract(tar_ref, out_dir)\n\n            final_path = os.path.join(\n                os.path.abspath(out_dir), out_file_name.replace(\".tart\", \"\")\n            )\n\n    if verbose:\n        print(\"Data downloaded to: {}\".format(final_path))\n</code></pre>"},{"location":"common/#beamgis.common.download_google_buildings","title":"<code>download_google_buildings(location, out_dir=None, merge_output=None, head=None, keep_geojson=False, overwrite=False, quiet=False, **kwargs)</code>","text":"<p>Download Google Open Building dataset for a specific location. Check the dataset links from     https://sites.research.google/open-buildings.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>The location name for which to download the dataset.</p> required <code>out_dir</code> <code>Optional[str]</code> <p>The output directory to save the downloaded files. If not provided, the current working directory is used.</p> <code>None</code> <code>merge_output</code> <code>Optional[str]</code> <p>Optional. The output file path for merging the downloaded files into a single GeoDataFrame.</p> <code>None</code> <code>head</code> <code>Optional[int]</code> <p>Optional. The number of files to download. If not provided, all files will be downloaded.</p> <code>None</code> <code>keep_geojson</code> <code>bool</code> <p>Optional. If True, the GeoJSON files will be kept after converting them to CSV files.</p> <code>False</code> <code>overwrite</code> <code>bool</code> <p>Optional. If True, overwrite the existing files.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Optional. If True, suppresses the download progress messages.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the <code>gpd.to_file</code> function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of file paths of the downloaded files.</p> Source code in <code>beamgis/common.py</code> <pre><code>def download_google_buildings(\n    location: str,\n    out_dir: Optional[str] = None,\n    merge_output: Optional[str] = None,\n    head: Optional[int] = None,\n    keep_geojson: bool = False,\n    overwrite: bool = False,\n    quiet: bool = False,\n    **kwargs,\n) -&gt; List[str]:\n    \"\"\"\n    Download Google Open Building dataset for a specific location. Check the dataset links from\n        https://sites.research.google/open-buildings.\n\n    Args:\n        location: The location name for which to download the dataset.\n        out_dir: The output directory to save the downloaded files. If not provided, the current working directory is used.\n        merge_output: Optional. The output file path for merging the downloaded files into a single GeoDataFrame.\n        head: Optional. The number of files to download. If not provided, all files will be downloaded.\n        keep_geojson: Optional. If True, the GeoJSON files will be kept after converting them to CSV files.\n        overwrite: Optional. If True, overwrite the existing files.\n        quiet: Optional. If True, suppresses the download progress messages.\n        **kwargs: Additional keyword arguments to be passed to the `gpd.to_file` function.\n\n    Returns:\n        A list of file paths of the downloaded files.\n\n    \"\"\"\n\n    import pandas as pd\n    import geopandas as gpd\n    from shapely import wkt\n\n    building_url = \"https://sites.research.google/open-buildings/tiles.geojson\"\n    country_url = (\n        \"https://naciscdn.org/naturalearth/110m/cultural/ne_110m_admin_0_countries.zip\"\n    )\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    building_gdf = gpd.read_file(building_url)\n    country_gdf = gpd.read_file(country_url)\n\n    country = country_gdf[country_gdf[\"NAME\"] == location]\n\n    if len(country) == 0:\n        country = country_gdf[country_gdf[\"NAME_LONG\"] == location]\n        if len(country) == 0:\n            raise ValueError(f\"Could not find {location} in the Natural Earth dataset.\")\n\n    gdf = building_gdf[building_gdf.intersects(country.geometry.iloc[0])]\n    gdf.sort_values(by=\"size_mb\", inplace=True)\n\n    print(f\"Found {len(gdf)} links for {location}.\")\n    if head is not None:\n        gdf = gdf.head(head)\n\n    if len(gdf) &gt; 0:\n        links = gdf[\"tile_url\"].tolist()\n        download_files(links, out_dir=out_dir, quiet=quiet, **kwargs)\n        filenames = [os.path.join(out_dir, os.path.basename(link)) for link in links]\n\n        gdfs = []\n        for filename in filenames:\n            # Read the CSV file into a pandas DataFrame\n            df = pd.read_csv(filename)\n\n            # Create a geometry column from the \"geometry\" column in the DataFrame\n            df[\"geometry\"] = df[\"geometry\"].apply(wkt.loads)\n\n            # Convert the pandas DataFrame to a GeoDataFrame\n            gdf = gpd.GeoDataFrame(df, geometry=\"geometry\")\n            gdf.crs = \"EPSG:4326\"\n            if keep_geojson:\n                gdf.to_file(\n                    filename.replace(\".csv.gz\", \".geojson\"), driver=\"GeoJSON\", **kwargs\n                )\n            gdfs.append(gdf)\n\n        if merge_output:\n            if os.path.exists(merge_output) and not overwrite:\n                print(f\"File {merge_output} already exists, skip merging...\")\n            else:\n                if not quiet:\n                    print(\"Merging GeoDataFrames ...\")\n                gdf = gpd.GeoDataFrame(\n                    pd.concat(gdfs, ignore_index=True), crs=\"EPSG:4326\"\n                )\n                gdf.to_file(merge_output, **kwargs)\n\n    else:\n        print(f\"No buildings found for {location}.\")\n</code></pre>"},{"location":"common/#beamgis.common.download_mapillary_image","title":"<code>download_mapillary_image(image_id, output=None, resolution='original', access_token=None, quiet=True, **kwargs)</code>","text":"<p>Downloads a Mapillary image.</p> <p>Parameters:</p> Name Type Description Default <code>image_id</code> <code>str</code> <p>The ID of the Mapillary image.</p> required <code>output</code> <code>str</code> <p>The output file path. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>str</code> <p>The resolution of the image. Can be 256, 1024, 2048, or original. Defaults to \"original\".</p> <code>'original'</code> <code>access_token</code> <code>str</code> <p>The access token for the Mapillary API. Defaults to None.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Whether to suppress output. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the download.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>beamgis/common.py</code> <pre><code>def download_mapillary_image(\n    image_id: str,\n    output: Optional[str] = None,\n    resolution: str = \"original\",\n    access_token: Optional[str] = None,\n    quiet: bool = True,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Downloads a Mapillary image.\n\n    Args:\n        image_id (str): The ID of the Mapillary image.\n        output (str, optional): The output file path. Defaults to None.\n        resolution (str): The resolution of the image. Can be 256, 1024, 2048, or original.\n            Defaults to \"original\".\n        access_token (str, optional): The access token for the Mapillary API. Defaults to None.\n        quiet (bool): Whether to suppress output. Defaults to True.\n        **kwargs: Additional keyword arguments for the download.\n\n    Returns:\n        None\n    \"\"\"\n\n    image_url = get_mapillary_image_url(\n        image_id, resolution=resolution, access_token=access_token\n    )\n    if output is None:\n\n        output = f\"{image_id}.jpg\"\n    download_file(image_url, output, quiet=quiet, **kwargs)\n</code></pre>"},{"location":"common/#beamgis.common.download_mapillary_images","title":"<code>download_mapillary_images(image_ids, output_dir=None, resolution='original', **kwargs)</code>","text":"<p>Downloads multiple Mapillary images.</p> <p>Parameters:</p> Name Type Description Default <code>image_ids</code> <code>List[str]</code> <p>A list of Mapillary image IDs.</p> required <code>output_dir</code> <code>str</code> <p>The directory to save the images. Defaults to the current working directory.</p> <code>None</code> <code>resolution</code> <code>str</code> <p>The resolution of the images. Defaults to \"original\".</p> <code>'original'</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the download.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>beamgis/common.py</code> <pre><code>def download_mapillary_images(\n    image_ids: List[str],\n    output_dir: Optional[str] = None,\n    resolution: str = \"original\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Downloads multiple Mapillary images.\n\n    Args:\n        image_ids (List[str]): A list of Mapillary image IDs.\n        output_dir (str, optional): The directory to save the images. Defaults\n            to the current working directory.\n        resolution (str): The resolution of the images. Defaults to \"original\".\n        **kwargs: Additional keyword arguments for the download.\n\n    Returns:\n        None\n    \"\"\"\n    if output_dir is None:\n        output_dir = os.getcwd()\n\n    for index, image_id in enumerate(image_ids):\n        output = os.path.join(output_dir, f\"{image_id}.jpg\")\n        print(f\"Downloading {index + 1}/{len(image_ids)}: {image_id}.jpg ...\")\n        download_mapillary_image(\n            image_id=image_id, output=output, resolution=resolution, **kwargs\n        )\n</code></pre>"},{"location":"common/#beamgis.common.download_ms_buildings","title":"<code>download_ms_buildings(location, out_dir=None, merge_output=None, head=None, quiet=False, **kwargs)</code>","text":"<p>Download Microsoft Buildings dataset for a specific location. Check the dataset links from     https://minedbuildings.blob.core.windows.net/global-buildings/dataset-links.csv.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>The location name for which to download the dataset.</p> required <code>out_dir</code> <code>Optional[str]</code> <p>The output directory to save the downloaded files. If not provided, the current working directory is used.</p> <code>None</code> <code>merge_output</code> <code>Optional[str]</code> <p>Optional. The output file path for merging the downloaded files into a single GeoDataFrame.</p> <code>None</code> <code>head</code> <p>Optional. The number of files to download. If not provided, all files will be downloaded.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Optional. If True, suppresses the download progress messages.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the <code>gpd.to_file</code> function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of file paths of the downloaded files.</p> Source code in <code>beamgis/common.py</code> <pre><code>def download_ms_buildings(\n    location: str,\n    out_dir: Optional[str] = None,\n    merge_output: Optional[str] = None,\n    head=None,\n    quiet: bool = False,\n    **kwargs,\n) -&gt; List[str]:\n    \"\"\"\n    Download Microsoft Buildings dataset for a specific location. Check the dataset links from\n        https://minedbuildings.blob.core.windows.net/global-buildings/dataset-links.csv.\n\n    Args:\n        location: The location name for which to download the dataset.\n        out_dir: The output directory to save the downloaded files. If not provided, the current working directory is used.\n        merge_output: Optional. The output file path for merging the downloaded files into a single GeoDataFrame.\n        head: Optional. The number of files to download. If not provided, all files will be downloaded.\n        quiet: Optional. If True, suppresses the download progress messages.\n        **kwargs: Additional keyword arguments to be passed to the `gpd.to_file` function.\n\n    Returns:\n        A list of file paths of the downloaded files.\n\n    \"\"\"\n\n    import pandas as pd\n    import geopandas as gpd\n    from shapely.geometry import shape\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    dataset_links = pd.read_csv(\n        \"https://minedbuildings.blob.core.windows.net/global-buildings/dataset-links.csv\"\n    )\n    country_links = dataset_links[dataset_links.Location == location]\n\n    if not quiet:\n        print(f\"Found {len(country_links)} links for {location}\")\n    if head is not None:\n        country_links = country_links.head(head)\n\n    filenames = []\n    i = 1\n\n    for _, row in country_links.iterrows():\n        if not quiet:\n            print(f\"Downloading {i} of {len(country_links)}: {row.QuadKey}.geojson\")\n        i += 1\n        filename = os.path.join(out_dir, f\"{row.QuadKey}.geojson\")\n        filenames.append(filename)\n        if os.path.exists(filename):\n            print(f\"File {filename} already exists, skipping...\")\n            continue\n        df = pd.read_json(row.Url, lines=True)\n        df[\"geometry\"] = df[\"geometry\"].apply(shape)\n        gdf = gpd.GeoDataFrame(df, crs=4326)\n        gdf.to_file(filename, driver=\"GeoJSON\", **kwargs)\n\n    if merge_output is not None:\n        if os.path.exists(merge_output):\n            print(f\"File {merge_output} already exists, skip merging...\")\n            return filenames\n        merge_vector(filenames, merge_output, quiet=quiet)\n\n    return filenames\n</code></pre>"},{"location":"common/#beamgis.common.download_ned","title":"<code>download_ned(region, out_dir=None, return_url=False, download_args={}, geopandas_args={}, query={})</code>","text":"<p>Download the US National Elevation Datasets (NED) for a region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str | list</code> <p>A filepath to a vector dataset or a list of bounds in the form of [minx, miny, maxx, maxy].</p> required <code>out_dir</code> <code>str</code> <p>The directory to download the files to. Defaults to None, which uses the current working directory.</p> <code>None</code> <code>return_url</code> <code>bool</code> <p>Whether to return the download URLs of the files. Defaults to False.</p> <code>False</code> <code>download_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the download_file function. Defaults to {}.</p> <code>{}</code> <code>geopandas_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the geopandas.read_file() function. Used for reading a region URL|filepath.</p> <code>{}</code> <code>query</code> <code>dict</code> <p>A dictionary of arguments to pass to the The_national_map_USGS.find_details() function. See https://apps.nationalmap.gov/tnmaccess/#/product for more information.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of the download URLs of the files if return_url is True.</p> Source code in <code>beamgis/common.py</code> <pre><code>def download_ned(\n    region,\n    out_dir=None,\n    return_url=False,\n    download_args={},\n    geopandas_args={},\n    query={},\n) -&gt; Union[None, List]:\n    \"\"\"Download the US National Elevation Datasets (NED) for a region.\n\n    Args:\n        region (str | list): A filepath to a vector dataset or a list of bounds in the form of [minx, miny, maxx, maxy].\n        out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n        return_url (bool, optional): Whether to return the download URLs of the files. Defaults to False.\n        download_args (dict, optional): A dictionary of arguments to pass to the download_file function. Defaults to {}.\n        geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n            Used for reading a region URL|filepath.\n        query (dict, optional): A dictionary of arguments to pass to the The_national_map_USGS.find_details() function.\n            See https://apps.nationalmap.gov/tnmaccess/#/product for more information.\n\n    Returns:\n        list: A list of the download URLs of the files if return_url is True.\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    if not query:\n        query = {\n            \"datasets\": \"National Elevation Dataset (NED) 1/3 arc-second\",\n            \"prodFormats\": \"GeoTIFF\",\n        }\n\n    TNM = The_national_map_USGS()\n    if return_url:\n        return TNM.find_tiles(region=region, geopandas_args=geopandas_args, API=query)\n    return TNM.download_tiles(\n        region=region,\n        out_dir=out_dir,\n        download_args=download_args,\n        geopandas_args=geopandas_args,\n        API=query,\n    )\n</code></pre>"},{"location":"common/#beamgis.common.download_nlcd","title":"<code>download_nlcd(years, out_dir=None, quiet=False, **kwargs)</code>","text":"<p>Downloads NLCD (National Land Cover Database) files for the specified years.</p> <p>Parameters:</p> Name Type Description Default <code>years</code> <code>List[int]</code> <p>A list of years for which to download the NLCD files.</p> required <code>out_dir</code> <code>str</code> <p>The directory where the downloaded files will be saved. Defaults to the current working directory.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>If True, suppresses download progress messages. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the download_file function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>beamgis/common.py</code> <pre><code>def download_nlcd(\n    years: List[int], out_dir: str = None, quiet: bool = False, **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Downloads NLCD (National Land Cover Database) files for the specified years.\n\n    Args:\n        years (List[int]): A list of years for which to download the NLCD files.\n        out_dir (str, optional): The directory where the downloaded files will be saved.\n            Defaults to the current working directory.\n        quiet (bool, optional): If True, suppresses download progress messages. Defaults to False.\n        **kwargs (Any): Additional keyword arguments to pass to the download_file function.\n\n    Returns:\n        None\n    \"\"\"\n\n    allow_years = list(range(1985, 2024, 1))\n    url = \"https://s3-us-west-2.amazonaws.com/mrlc/Annual_NLCD_LndCov_{}_CU_C1V0.tif\"\n    if out_dir is None:\n        out_dir = os.getcwd()\n    elif not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n    for year in years:\n        if year not in allow_years:\n            print(f\"Year {year} is not available. Skipping...\")\n            continue\n        year_url = url.format(year)\n        basename = os.path.basename(year_url)\n        filepath = os.path.join(out_dir, basename)\n        download_file(year_url, filepath, quiet=quiet, **kwargs)\n</code></pre>"},{"location":"common/#beamgis.common.download_tnm","title":"<code>download_tnm(region=None, out_dir=None, return_url=False, download_args={}, geopandas_args={}, API={})</code>","text":"<p>Download the US National Elevation Datasets (NED) for a region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str | list</code> <p>An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy]. Alternatively you could use API parameters such as polygon or bbox.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The directory to download the files to. Defaults to None, which uses the current working directory.</p> <code>None</code> <code>return_url</code> <code>bool</code> <p>Whether to return the download URLs of the files. Defaults to False.</p> <code>False</code> <code>download_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the download_file function. Defaults to {}.</p> <code>{}</code> <code>geopandas_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the geopandas.read_file() function. Used for reading a region URL|filepath.</p> <code>{}</code> <code>API</code> <code>dict</code> <p>A dictionary of arguments to pass to the The_national_map_USGS.find_details() function. Exposes most of the documented API. Defaults to {}</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of the download URLs of the files if return_url is True.</p> Source code in <code>beamgis/common.py</code> <pre><code>def download_tnm(\n    region=None,\n    out_dir=None,\n    return_url=False,\n    download_args={},\n    geopandas_args={},\n    API={},\n) -&gt; Union[None, List]:\n    \"\"\"Download the US National Elevation Datasets (NED) for a region.\n\n    Args:\n        region (str | list, optional): An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy].\n            Alternatively you could use API parameters such as polygon or bbox.\n        out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n        return_url (bool, optional): Whether to return the download URLs of the files. Defaults to False.\n        download_args (dict, optional): A dictionary of arguments to pass to the download_file function. Defaults to {}.\n        geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n            Used for reading a region URL|filepath.\n        API (dict, optional): A dictionary of arguments to pass to the The_national_map_USGS.find_details() function.\n            Exposes most of the documented API. Defaults to {}\n\n    Returns:\n        list: A list of the download URLs of the files if return_url is True.\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    TNM = The_national_map_USGS()\n    if return_url:\n        return TNM.find_tiles(region=region, geopandas_args=geopandas_args, API=API)\n    return TNM.download_tiles(\n        region=region,\n        out_dir=out_dir,\n        download_args=download_args,\n        geopandas_args=geopandas_args,\n        API=API,\n    )\n</code></pre>"},{"location":"common/#beamgis.common.edit_download_html","title":"<code>edit_download_html(htmlWidget, filename, title='Click here to download: ')</code>","text":"<p>Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578#issuecomment-617668058</p> <p>Parameters:</p> Name Type Description Default <code>htmlWidget</code> <code>object</code> <p>The HTML widget to display the URL.</p> required <code>filename</code> <code>str</code> <p>File path to download.</p> required <code>title</code> <code>str</code> <p>Download description. Defaults to \"Click here to download: \".</p> <code>'Click here to download: '</code> Source code in <code>beamgis/common.py</code> <pre><code>def edit_download_html(htmlWidget, filename, title=\"Click here to download: \"):\n    \"\"\"Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578#issuecomment-617668058\n\n    Args:\n        htmlWidget (object): The HTML widget to display the URL.\n        filename (str): File path to download.\n        title (str, optional): Download description. Defaults to \"Click here to download: \".\n    \"\"\"\n\n    # from IPython.display import HTML\n    # import ipywidgets as widgets\n    import base64\n\n    # Change widget html temporarily to a font-awesome spinner\n    htmlWidget.value = '&lt;i class=\"fa fa-spinner fa-spin fa-2x fa-fw\"&gt;&lt;/i&gt;&lt;span class=\"sr-only\"&gt;Loading...&lt;/span&gt;'\n\n    # Process raw data\n    data = open(filename, \"rb\").read()\n    b64 = base64.b64encode(data)\n    payload = b64.decode()\n\n    basename = os.path.basename(filename)\n\n    # Create and assign html to widget\n    html = '&lt;a download=\"{filename}\" href=\"data:text/csv;base64,{payload}\" target=\"_blank\"&gt;{title}&lt;/a&gt;'\n    htmlWidget.value = html.format(\n        payload=payload, title=title + basename, filename=basename\n    )\n</code></pre>"},{"location":"common/#beamgis.common.ee_tile_url","title":"<code>ee_tile_url(ee_object=None, vis_params={}, asset_id=None, ee_initialize=False, project_id=None, **kwargs)</code>","text":"<p>Adds a Google Earth Engine tile layer to the map based on the tile layer URL from     https://github.com/opengeos/ee-tile-layers/blob/main/datasets.tsv.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>The Earth Engine object to display.</p> <code>None</code> <code>vis_params</code> <code>dict</code> <p>Visualization parameters. For example, {'min': 0, 'max': 100}.</p> <code>{}</code> <code>asset_id</code> <code>str</code> <p>The ID of the Earth Engine asset.</p> <code>None</code> <code>ee_initialize</code> <code>bool</code> <p>Whether to initialize the Earth Engine</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>beamgis/common.py</code> <pre><code>def ee_tile_url(\n    ee_object=None,\n    vis_params={},\n    asset_id: str = None,\n    ee_initialize: bool = False,\n    project_id=None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Adds a Google Earth Engine tile layer to the map based on the tile layer URL from\n        https://github.com/opengeos/ee-tile-layers/blob/main/datasets.tsv.\n\n    Args:\n        ee_object (object): The Earth Engine object to display.\n        vis_params (dict): Visualization parameters. For example, {'min': 0, 'max': 100}.\n        asset_id (str): The ID of the Earth Engine asset.\n        ee_initialize (bool, optional): Whether to initialize the Earth Engine\n\n    Returns:\n        None\n    \"\"\"\n    import pandas as pd\n\n    if isinstance(asset_id, str):\n        df = pd.read_csv(\n            \"https://raw.githubusercontent.com/opengeos/ee-tile-layers/main/datasets.tsv\",\n            sep=\"\\t\",\n        )\n\n        asset_id = asset_id.strip()\n\n        if asset_id in df[\"id\"].values:\n            url = df.loc[df[\"id\"] == asset_id, \"url\"].values[0]\n            return url\n        else:\n            print(f\"The provided EE tile layer {asset_id} does not exist.\")\n            return None\n    elif ee_object is not None:\n        try:\n            import geemap\n            from geemap.ee_tile_layers import _get_tile_url_format\n\n            if ee_initialize:\n                geemap.ee_initialize(project=project_id, **kwargs)\n            url = _get_tile_url_format(ee_object, vis_params)\n            return url\n        except Exception as e:\n            print(e)\n            return None\n</code></pre>"},{"location":"common/#beamgis.common.evaluate_model","title":"<code>evaluate_model(df, y_col='y', y_pred_col='y_pred', metrics=None, drop_na=True, filter_nonzero=True)</code>","text":"<p>Evaluates the model performance on the given dataframe with customizable options.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A pandas DataFrame with columns for actual and predicted values.</p> required <code>y_col</code> <code>str</code> <p>Column name for the actual values.</p> <code>'y'</code> <code>y_pred_col</code> <code>str</code> <p>Column name for the predicted values.</p> <code>'y_pred'</code> <code>metrics</code> <code>list</code> <p>A list of metrics to calculate. Available options: - 'r2': R-squared - 'r': Pearson correlation coefficient - 'rmse': Root Mean Squared Error - 'mae': Mean Absolute Error - 'mape': Mean Absolute Percentage Error Defaults to all metrics if None.</p> <code>None</code> <code>drop_na</code> <code>bool</code> <p>Whether to drop rows with NaN in the actual values column.</p> <code>True</code> <code>filter_nonzero</code> <code>bool</code> <p>Whether to filter out rows where actual values are zero.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the selected performance metrics.</p> Source code in <code>beamgis/common.py</code> <pre><code>def evaluate_model(\n    df: pd.DataFrame,\n    y_col: str = \"y\",\n    y_pred_col: str = \"y_pred\",\n    metrics: list = None,\n    drop_na: bool = True,\n    filter_nonzero: bool = True,\n) -&gt; dict:\n    \"\"\"\n    Evaluates the model performance on the given dataframe with customizable options.\n\n    Args:\n        df: A pandas DataFrame with columns for actual and predicted values.\n        y_col: Column name for the actual values.\n        y_pred_col: Column name for the predicted values.\n        metrics: A list of metrics to calculate. Available options:\n            - 'r2': R-squared\n            - 'r': Pearson correlation coefficient\n            - 'rmse': Root Mean Squared Error\n            - 'mae': Mean Absolute Error\n            - 'mape': Mean Absolute Percentage Error\n            Defaults to all metrics if None.\n        drop_na: Whether to drop rows with NaN in the actual values column.\n        filter_nonzero: Whether to filter out rows where actual values are zero.\n\n    Returns:\n        A dictionary of the selected performance metrics.\n    \"\"\"\n\n    import math\n\n    try:\n        from sklearn import metrics as skmetrics\n    except ImportError:\n        raise ImportError(\n            \"The scikit-learn package is required for this function. Install it using 'pip install scikit-learn'.\"\n        )\n\n    # Default metrics if none are provided\n    if metrics is None:\n        metrics = [\"r2\", \"r\", \"rmse\", \"mae\", \"mape\"]\n\n    # Data preprocessing\n    if drop_na:\n        df = df.dropna(subset=[y_col])\n    if filter_nonzero:\n        df = df[df[y_col] != 0]\n\n    # Metric calculations\n    results = {}\n    if \"r2\" in metrics:\n        results[\"r2\"] = skmetrics.r2_score(df[y_col], df[y_pred_col])\n    if \"r\" in metrics:\n        results[\"r\"] = df[y_col].corr(df[y_pred_col])\n    if \"rmse\" in metrics:\n        results[\"rmse\"] = math.sqrt(\n            skmetrics.mean_squared_error(df[y_col], df[y_pred_col])\n        )\n    if \"mae\" in metrics:\n        results[\"mae\"] = skmetrics.mean_absolute_error(df[y_col], df[y_pred_col])\n    if \"mape\" in metrics:\n        results[\"mape\"] = skmetrics.mean_absolute_percentage_error(\n            df[y_col], df[y_pred_col]\n        )\n\n    return results\n</code></pre>"},{"location":"common/#beamgis.common.execute_maplibre_notebook_dir","title":"<code>execute_maplibre_notebook_dir(in_dir, out_dir, delete_html=True, replace_api_key=True, recursive=False, keep_notebook=False, index_html=True)</code>","text":"<p>Executes Jupyter notebooks found in a specified directory, optionally replacing API keys and deleting HTML outputs.</p> <p>Parameters:</p> Name Type Description Default <code>in_dir</code> <code>str</code> <p>The input directory containing Jupyter notebooks to be executed.</p> required <code>out_dir</code> <code>str</code> <p>The output directory where the executed notebooks and their HTML outputs will be saved.</p> required <code>delete_html</code> <code>bool</code> <p>If True, deletes any existing HTML files in the output directory before execution. Defaults to True.</p> <code>True</code> <code>replace_api_key</code> <code>bool</code> <p>If True, replaces the API key in the output HTML. Defaults to True. set \"MAPTILER_KEY\" and \"MAPTILER_KEY_PUBLIC\" to your MapTiler API key and public key, respectively.</p> <code>True</code> <code>recursive</code> <code>bool</code> <p>If True, searches for notebooks in the input directory recursively. Defaults to False.</p> <code>False</code> <code>keep_notebook</code> <code>bool</code> <p>If True, keeps the executed notebooks in the output directory. Defaults to False.</p> <code>False</code> <code>index_html</code> <code>bool</code> <p>If True, generates an index.html file in the output directory listing all files. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>beamgis/common.py</code> <pre><code>def execute_maplibre_notebook_dir(\n    in_dir: str,\n    out_dir: str,\n    delete_html: bool = True,\n    replace_api_key: bool = True,\n    recursive: bool = False,\n    keep_notebook: bool = False,\n    index_html: bool = True,\n) -&gt; None:\n    \"\"\"\n    Executes Jupyter notebooks found in a specified directory, optionally replacing API keys and deleting HTML outputs.\n\n    Args:\n        in_dir (str): The input directory containing Jupyter notebooks to be executed.\n        out_dir (str): The output directory where the executed notebooks and their HTML outputs will be saved.\n        delete_html (bool, optional): If True, deletes any existing HTML files in the output directory before execution. Defaults to True.\n        replace_api_key (bool, optional): If True, replaces the API key in the output HTML. Defaults to True.\n            set \"MAPTILER_KEY\" and \"MAPTILER_KEY_PUBLIC\" to your MapTiler API key and public key, respectively.\n        recursive (bool, optional): If True, searches for notebooks in the input directory recursively. Defaults to False.\n        keep_notebook (bool, optional): If True, keeps the executed notebooks in the output directory. Defaults to False.\n        index_html (bool, optional): If True, generates an index.html file in the output directory listing all files. Defaults to True.\n\n    Returns:\n        None\n    \"\"\"\n    import shutil\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if replace_api_key:\n        os.environ[\"MAPTILER_REPLACE_KEY\"] = \"True\"\n\n    if delete_html:\n        html_files = find_files(out_dir, \"*.html\", recursive=recursive)\n        for file in html_files:\n            os.remove(file)\n\n    files = find_files(in_dir, \"*.ipynb\", recursive=recursive)\n    for index, file in enumerate(files):\n        print(f\"Processing {index + 1}/{len(files)}: {file} ...\")\n        basename = os.path.basename(file)\n        out_file = os.path.join(out_dir, basename)\n        shutil.copy(file, out_file)\n\n        with open(out_file, \"r\") as f:\n            lines = f.readlines()\n\n        out_lines = []\n        for line in lines:\n            if line.strip() == '\"m\"':\n                title = os.path.splitext(basename)[0].replace(\"_\", \" \")\n                out_lines.append(line.replace(\"m\", f\"m.to_html(title='{title}')\"))\n            else:\n                out_lines.append(line)\n\n        with open(out_file, \"w\") as f:\n            f.writelines(out_lines)\n\n        out_html = os.path.basename(out_file).replace(\".ipynb\", \".html\")\n        os.environ[\"MAPLIBRE_OUTPUT\"] = out_html\n        execute_notebook(out_file)\n\n    if not keep_notebook:\n        all_files = find_files(out_dir, \"*\", recursive=recursive)\n        for file in all_files:\n            if not file.endswith(\".html\"):\n                os.remove(file)\n\n    if index_html:\n        generate_index_html(out_dir)\n</code></pre>"},{"location":"common/#beamgis.common.execute_notebook","title":"<code>execute_notebook(in_file)</code>","text":"<p>Executes a Jupyter notebook and save output cells</p> <p>Parameters:</p> Name Type Description Default <code>in_file</code> <code>str</code> <p>Input Jupyter notebook.</p> required Source code in <code>beamgis/common.py</code> <pre><code>def execute_notebook(in_file):\n    \"\"\"Executes a Jupyter notebook and save output cells\n\n    Args:\n        in_file (str): Input Jupyter notebook.\n    \"\"\"\n    # command = 'jupyter nbconvert --to notebook --execute ' + in_file + ' --inplace'\n    command = 'jupyter nbconvert --to notebook --execute \"{}\" --inplace'.format(in_file)\n    print(os.popen(command).read().rstrip())\n    # os.popen(command)\n</code></pre>"},{"location":"common/#beamgis.common.execute_notebook_dir","title":"<code>execute_notebook_dir(in_dir)</code>","text":"<p>Executes all Jupyter notebooks in the given directory recursively and save output cells.</p> <p>Parameters:</p> Name Type Description Default <code>in_dir</code> <code>str</code> <p>Input folder containing notebooks.</p> required Source code in <code>beamgis/common.py</code> <pre><code>def execute_notebook_dir(in_dir):\n    \"\"\"Executes all Jupyter notebooks in the given directory recursively and save output cells.\n\n    Args:\n        in_dir (str): Input folder containing notebooks.\n    \"\"\"\n    from pathlib import Path\n\n    in_dir = os.path.abspath(in_dir)\n\n    files = list(Path(in_dir).rglob(\"*.ipynb\"))\n    files.sort()\n    count = len(files)\n    if files is not None:\n        for index, file in enumerate(files):\n            in_file = str(file)\n            print(f\"Processing {index + 1}/{count}: {file} ...\")\n            execute_notebook(in_file)\n</code></pre>"},{"location":"common/#beamgis.common.explode","title":"<code>explode(coords)</code>","text":"<p>Explode a GeoJSON geometry's coordinates object and yield coordinate tuples. As long as the input is conforming, the type of the geometry doesn't matter.  From Fiona 1.4.8</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>list</code> <p>A list of coordinates.</p> required <p>Yields:</p> Type Description <code>[type]</code> <p>[description]</p> Source code in <code>beamgis/common.py</code> <pre><code>def explode(coords):\n    \"\"\"Explode a GeoJSON geometry's coordinates object and yield\n    coordinate tuples. As long as the input is conforming, the type of\n    the geometry doesn't matter.  From Fiona 1.4.8\n\n    Args:\n        coords (list): A list of coordinates.\n\n    Yields:\n        [type]: [description]\n    \"\"\"\n\n    for e in coords:\n        if isinstance(e, (float, int)):\n            yield coords\n            break\n        else:\n            for f in explode(e):\n                yield f\n</code></pre>"},{"location":"common/#beamgis.common.extract_archive","title":"<code>extract_archive(archive, outdir=None, **kwargs)</code>","text":"<p>Extracts a multipart archive.</p> <p>This function uses the patoolib library to extract a multipart archive. If the patoolib library is not installed, it attempts to install it. If the archive does not end with \".zip\", it appends \".zip\" to the archive name. If the extraction fails (for example, if the files already exist), it skips the extraction.</p> <p>Parameters:</p> Name Type Description Default <code>archive</code> <code>str</code> <p>The path to the archive file.</p> required <code>outdir</code> <code>str</code> <p>The directory where the archive should be extracted.</p> <code>None</code> <code>**kwargs</code> <p>Arbitrary keyword arguments for the patoolib.extract_archive function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Exceptions:</p> Type Description <code>Exception</code> <p>An exception is raised if the extraction fails for reasons other than the files already existing.</p> <p>Examples:</p> <p>files = [\"sam_hq_vit_tiny.zip\", \"sam_hq_vit_tiny.z01\", \"sam_hq_vit_tiny.z02\", \"sam_hq_vit_tiny.z03\"] base_url = \"https://github.com/opengeos/datasets/releases/download/models/\" urls = [base_url + f for f in files] leafmap.download_files(urls, out_dir=\"models\", multi_part=True)</p> Source code in <code>beamgis/common.py</code> <pre><code>def extract_archive(archive, outdir=None, **kwargs) -&gt; None:\n    \"\"\"\n    Extracts a multipart archive.\n\n    This function uses the patoolib library to extract a multipart archive.\n    If the patoolib library is not installed, it attempts to install it.\n    If the archive does not end with \".zip\", it appends \".zip\" to the archive name.\n    If the extraction fails (for example, if the files already exist), it skips the extraction.\n\n    Args:\n        archive (str): The path to the archive file.\n        outdir (str): The directory where the archive should be extracted.\n        **kwargs: Arbitrary keyword arguments for the patoolib.extract_archive function.\n\n    Returns:\n        None\n\n    Raises:\n        Exception: An exception is raised if the extraction fails for reasons other than the files already existing.\n\n    Example:\n\n        files = [\"sam_hq_vit_tiny.zip\", \"sam_hq_vit_tiny.z01\", \"sam_hq_vit_tiny.z02\", \"sam_hq_vit_tiny.z03\"]\n        base_url = \"https://github.com/opengeos/datasets/releases/download/models/\"\n        urls = [base_url + f for f in files]\n        leafmap.download_files(urls, out_dir=\"models\", multi_part=True)\n\n    \"\"\"\n    try:\n        import patoolib\n    except ImportError:\n        install_package(\"patool\")\n        import patoolib\n\n    if not archive.endswith(\".zip\"):\n        archive = archive + \".zip\"\n\n    if outdir is None:\n        outdir = os.path.dirname(archive)\n\n    try:\n        patoolib.extract_archive(archive, outdir=outdir, **kwargs)\n    except Exception as e:\n        print(\"The unzipped files might already exist. Skipping extraction.\")\n        return\n</code></pre>"},{"location":"common/#beamgis.common.extract_parquet_by_bbox","title":"<code>extract_parquet_by_bbox(input_parquet, bbox, output_file, geometry='geometry', driver='PARQUET')</code>","text":"<p>Extract buildings that intersect with a specific bounding box in San Diego.</p> <p>Uses DuckDB with spatial extension to query buildings that intersect with a bounding box and saves the results to a Parquet file.</p> <p>Parameters:</p> Name Type Description Default <code>input_parquet_pattern</code> <code>str</code> <p>Pattern for input Parquet files (e.g. '*.parquet')</p> required <code>output_parquet_path</code> <code>str</code> <p>Output file path for resulting Parquet file</p> required <p>Returns:</p> Type Description <code>None</code> <p>The function writes the results to the output_parquet_path</p> Source code in <code>beamgis/common.py</code> <pre><code>def extract_parquet_by_bbox(\n    input_parquet, bbox, output_file, geometry=\"geometry\", driver=\"PARQUET\"\n):\n    \"\"\"\n    Extract buildings that intersect with a specific bounding box in San Diego.\n\n    Uses DuckDB with spatial extension to query buildings that intersect with\n    a bounding box and saves the results to a Parquet file.\n\n    Args:\n        input_parquet_pattern (str): Pattern for input Parquet files (e.g. '*.parquet')\n        output_parquet_path (str): Output file path for resulting Parquet file\n\n    Returns:\n        None: The function writes the results to the output_parquet_path\n    \"\"\"\n    import duckdb\n\n    # Connect to DuckDB\n    conn = duckdb.connect()\n\n    # Install and load spatial extension\n    conn.execute(\"INSTALL spatial\")\n    conn.execute(\"LOAD spatial\")\n\n    if driver.upper() == \"PARQUET\":\n        fmt = \"FORMAT PARQUET\"\n    else:\n        fmt = f\"FORMAT GDAL, DRIVER '{driver}'\"\n\n    # Run the query\n    query = f\"\"\"\n    COPY (\n        WITH bbox AS (\n            SELECT ST_MakeEnvelope({bbox[0]}, {bbox[1]}, {bbox[2]}, {bbox[3]}) AS geom2\n        )\n\n        SELECT * FROM '{input_parquet}'\n        WHERE\n            ST_Intersects(\n                {geometry},\n                (SELECT geom2 FROM bbox)\n            )\n    ) TO '{output_file}' ({fmt})\n    \"\"\"\n\n    # Execute the query\n    conn.execute(query)\n\n    # Close the connection\n    conn.close()\n</code></pre>"},{"location":"common/#beamgis.common.filter_bounds","title":"<code>filter_bounds(data, bbox, within=False, align=True, **kwargs)</code>","text":"<p>Filters a GeoDataFrame or GeoSeries by a bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | GeoDataFrame</code> <p>The input data to filter. Can be a file path or a GeoDataFrame.</p> required <code>bbox</code> <code>list | GeoDataFrame</code> <p>The bounding box to filter by. Can be a list of 4 coordinates or a file path or a GeoDataFrame.</p> required <code>within</code> <code>bool</code> <p>Whether to filter by the bounding box or the bounding box's interior. Defaults to False.</p> <code>False</code> <code>align</code> <code>bool</code> <p>If True, automatically aligns GeoSeries based on their indices. If False, the order of elements is preserved.</p> <code>True</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>The filtered data.</p> Source code in <code>beamgis/common.py</code> <pre><code>def filter_bounds(data, bbox, within=False, align=True, **kwargs):\n    \"\"\"Filters a GeoDataFrame or GeoSeries by a bounding box.\n\n    Args:\n        data (str | GeoDataFrame): The input data to filter. Can be a file path or a GeoDataFrame.\n        bbox (list | GeoDataFrame): The bounding box to filter by. Can be a list of 4 coordinates or a file path or a GeoDataFrame.\n        within (bool, optional): Whether to filter by the bounding box or the bounding box's interior. Defaults to False.\n        align (bool, optional): If True, automatically aligns GeoSeries based on their indices. If False, the order of elements is preserved.\n\n    Returns:\n        GeoDataFrame: The filtered data.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        data = gpd.read_file(data, **kwargs)\n    elif not isinstance(data, (gpd.GeoDataFrame, gpd.GeoSeries)):\n        raise TypeError(\"data must be a file path or a GeoDataFrame or GeoSeries\")\n\n    if isinstance(bbox, list):\n        if len(bbox) != 4:\n            raise ValueError(\"bbox must be a list of 4 coordinates\")\n        bbox = bbox_to_gdf(bbox)\n    elif isinstance(bbox, str):\n        bbox = gpd.read_file(bbox, **kwargs)\n\n    if within:\n        result = data[data.within(bbox.unary_union, align=align)]\n    else:\n        result = data[data.intersects(bbox.unary_union, align=align)]\n\n    return result\n</code></pre>"},{"location":"common/#beamgis.common.filter_date","title":"<code>filter_date(data, start_date=None, end_date=None, date_field='date', date_args={}, **kwargs)</code>","text":"<p>Filters a DataFrame, GeoDataFrame or GeoSeries by a date range.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | DataFrame | GeoDataFrame</code> <p>The input data to filter. Can be a file path or a DataFrame or GeoDataFrame.</p> required <code>start_date</code> <code>str</code> <p>The start date, e.g., 2023-01-01. Defaults to None.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>The end date, e.g., 2023-12-31. Defaults to None.</p> <code>None</code> <code>date_field</code> <code>str</code> <p>The name of the date field. Defaults to \"date\".</p> <code>'date'</code> <code>date_args</code> <code>dict</code> <p>Additional arguments for pd.to_datetime. Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The filtered data.</p> Source code in <code>beamgis/common.py</code> <pre><code>def filter_date(\n    data, start_date=None, end_date=None, date_field=\"date\", date_args={}, **kwargs\n):\n    \"\"\"Filters a DataFrame, GeoDataFrame or GeoSeries by a date range.\n\n    Args:\n        data (str | DataFrame | GeoDataFrame): The input data to filter. Can be a file path or a DataFrame or GeoDataFrame.\n        start_date (str, optional): The start date, e.g., 2023-01-01. Defaults to None.\n        end_date (str, optional): The end date, e.g., 2023-12-31. Defaults to None.\n        date_field (str, optional): The name of the date field. Defaults to \"date\".\n        date_args (dict, optional): Additional arguments for pd.to_datetime. Defaults to {}.\n\n    Returns:\n        DataFrame: The filtered data.\n    \"\"\"\n\n    import datetime\n    import pandas as pd\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        data = gpd.read_file(data, **kwargs)\n    elif not isinstance(\n        data, (gpd.GeoDataFrame, gpd.GeoSeries, pd.DataFrame, pd.Series)\n    ):\n        raise TypeError(\"data must be a file path or a GeoDataFrame or GeoSeries\")\n\n    if date_field not in data.columns:\n        raise ValueError(f\"date_field must be one of {data.columns}\")\n\n    new_field = f\"{date_field}_temp\"\n    data[new_field] = pd.to_datetime(data[date_field], **date_args)\n\n    if end_date is None:\n        end_date = datetime.datetime.now().strftime(\"%Y-%m-%d\")\n\n    if start_date is None:\n        start_date = data[new_field].min()\n\n    mask = (data[new_field] &gt;= start_date) &amp; (data[new_field] &lt;= end_date)\n    result = data.loc[mask]\n    return result.drop(columns=[new_field], axis=1)\n</code></pre>"},{"location":"common/#beamgis.common.find_files","title":"<code>find_files(input_dir, ext=None, fullpath=True, recursive=True)</code>","text":"<p>Find files in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>str</code> <p>The input directory.</p> required <code>ext</code> <code>str</code> <p>The file extension to match. Defaults to None.</p> <code>None</code> <code>fullpath</code> <code>bool</code> <p>Whether to return the full path. Defaults to True.</p> <code>True</code> <code>recursive</code> <code>bool</code> <p>Whether to search recursively. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of matching files.</p> Source code in <code>beamgis/common.py</code> <pre><code>def find_files(input_dir, ext=None, fullpath=True, recursive=True):\n    \"\"\"Find files in a directory.\n\n    Args:\n        input_dir (str): The input directory.\n        ext (str, optional): The file extension to match. Defaults to None.\n        fullpath (bool, optional): Whether to return the full path. Defaults to True.\n        recursive (bool, optional): Whether to search recursively. Defaults to True.\n\n    Returns:\n        list: A list of matching files.\n    \"\"\"\n\n    from pathlib import Path\n\n    files = []\n\n    if ext is None:\n        ext = \"*\"\n    else:\n        ext = ext.replace(\".\", \"\")\n\n    ext = f\"*.{ext}\"\n\n    if recursive:\n        if fullpath:\n            files = [str(path.joinpath()) for path in Path(input_dir).rglob(ext)]\n        else:\n            files = [str(path.name) for path in Path(input_dir).rglob(ext)]\n    else:\n        if fullpath:\n            files = [str(path.joinpath()) for path in Path(input_dir).glob(ext)]\n        else:\n            files = [path.name for path in Path(input_dir).glob(ext)]\n\n    files.sort()\n    return files\n</code></pre>"},{"location":"common/#beamgis.common.gdb_layer_names","title":"<code>gdb_layer_names(gdb_path)</code>","text":"<p>Get a list of layer names in a File Geodatabase (GDB).</p> <p>Parameters:</p> Name Type Description Default <code>gdb_path</code> <code>str</code> <p>The path to the File Geodatabase (GDB).</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of layer names in the GDB.</p> Source code in <code>beamgis/common.py</code> <pre><code>def gdb_layer_names(gdb_path: str) -&gt; List[str]:\n    \"\"\"Get a list of layer names in a File Geodatabase (GDB).\n\n    Args:\n        gdb_path (str): The path to the File Geodatabase (GDB).\n\n    Returns:\n        List[str]: A list of layer names in the GDB.\n    \"\"\"\n\n    from osgeo import ogr\n\n    # Open the GDB\n    gdb_driver = ogr.GetDriverByName(\"OpenFileGDB\")\n    gdb_dataset = gdb_driver.Open(gdb_path, 0)\n\n    # Get the number of layers in the GDB\n    layer_count = gdb_dataset.GetLayerCount()\n    # Iterate over the layers\n    layer_names = []\n    for i in range(layer_count):\n        layer = gdb_dataset.GetLayerByIndex(i)\n        feature_class_name = layer.GetName()\n        layer_names.append(feature_class_name)\n\n    # Close the GDB dataset\n    gdb_dataset = None\n    return layer_names\n</code></pre>"},{"location":"common/#beamgis.common.gdb_to_vector","title":"<code>gdb_to_vector(gdb_path, out_dir, layers=None, filenames=None, gdal_driver='GPKG', file_extension=None, overwrite=False, quiet=False, **kwargs)</code>","text":"<p>Converts layers from a File Geodatabase (GDB) to a vector format.</p> <p>Parameters:</p> Name Type Description Default <code>gdb_path</code> <code>str</code> <p>The path to the File Geodatabase (GDB).</p> required <code>out_dir</code> <code>str</code> <p>The output directory to save the converted files.</p> required <code>layers</code> <code>Optional[List[str]]</code> <p>A list of layer names to convert. If None, all layers will be converted. Default is None.</p> <code>None</code> <code>filenames</code> <code>Optional[List[str]]</code> <p>A list of output file names. If None, the layer names will be used as the file names. Default is None.</p> <code>None</code> <code>gdal_driver</code> <code>str</code> <p>The GDAL driver name for the output vector format. Default is \"GPKG\".</p> <code>'GPKG'</code> <code>file_extension</code> <code>Optional[str]</code> <p>The file extension for the output files. If None, it will be determined automatically based on the gdal_driver. Default is None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the existing output files. Default is False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>If True, suppress the log output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>beamgis/common.py</code> <pre><code>def gdb_to_vector(\n    gdb_path: str,\n    out_dir: str,\n    layers: Optional[List[str]] = None,\n    filenames: Optional[List[str]] = None,\n    gdal_driver: str = \"GPKG\",\n    file_extension: Optional[str] = None,\n    overwrite: bool = False,\n    quiet=False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Converts layers from a File Geodatabase (GDB) to a vector format.\n\n    Args:\n        gdb_path (str): The path to the File Geodatabase (GDB).\n        out_dir (str): The output directory to save the converted files.\n        layers (Optional[List[str]]): A list of layer names to convert. If None, all layers will be converted. Default is None.\n        filenames (Optional[List[str]]): A list of output file names. If None, the layer names will be used as the file names. Default is None.\n        gdal_driver (str): The GDAL driver name for the output vector format. Default is \"GPKG\".\n        file_extension (Optional[str]): The file extension for the output files. If None, it will be determined automatically based on the gdal_driver. Default is None.\n        overwrite (bool): Whether to overwrite the existing output files. Default is False.\n        quiet (bool): If True, suppress the log output. Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    from osgeo import ogr\n\n    # Open the GDB\n    gdb_driver = ogr.GetDriverByName(\"OpenFileGDB\")\n    gdb_dataset = gdb_driver.Open(gdb_path, 0)\n\n    # Get the number of layers in the GDB\n    layer_count = gdb_dataset.GetLayerCount()\n\n    if isinstance(layers, str):\n        layers = [layers]\n\n    if isinstance(filenames, str):\n        filenames = [filenames]\n\n    if filenames is not None:\n        if len(filenames) != len(layers):\n            raise ValueError(\"The length of filenames must match the length of layers.\")\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    ii = 0\n    # Iterate over the layers\n    for i in range(layer_count):\n        layer = gdb_dataset.GetLayerByIndex(i)\n        feature_class_name = layer.GetName()\n\n        if layers is not None:\n            if feature_class_name not in layers:\n                continue\n\n        if file_extension is None:\n            file_extension = get_gdal_file_extension(gdal_driver)\n\n        # Create the output file path\n        if filenames is not None:\n            output_file = os.path.join(out_dir, filenames[ii] + \".\" + file_extension)\n            ii += 1\n        else:\n            output_file = os.path.join(\n                out_dir, feature_class_name + \".\" + file_extension\n            )\n\n        if os.path.exists(output_file) and not overwrite:\n            print(f\"File {output_file} already exists. Skipping...\")\n            continue\n        else:\n            if not quiet:\n                print(f\"Converting layer {feature_class_name} to {output_file}...\")\n\n        # Create the output driver\n        output_driver = ogr.GetDriverByName(gdal_driver)\n        output_dataset = output_driver.CreateDataSource(output_file)\n\n        # Copy the input layer to the output format\n        output_dataset.CopyLayer(layer, feature_class_name)\n\n        output_dataset = None\n\n    # Close the GDB dataset\n    gdb_dataset = None\n</code></pre>"},{"location":"common/#beamgis.common.gdf_bounds","title":"<code>gdf_bounds(gdf, return_geom=False)</code>","text":"<p>Returns the bounding box of a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>return_geom</code> <code>bool</code> <p>Whether to return the bounding box as a GeoDataFrame. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list | gpd.GeoDataFrame</code> <p>A bounding box in the form of a list (minx, miny, maxx, maxy) or GeoDataFrame.</p> Source code in <code>beamgis/common.py</code> <pre><code>def gdf_bounds(gdf, return_geom=False):\n    \"\"\"Returns the bounding box of a GeoDataFrame.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        return_geom (bool, optional): Whether to return the bounding box as a GeoDataFrame. Defaults to False.\n\n    Returns:\n        list | gpd.GeoDataFrame: A bounding box in the form of a list (minx, miny, maxx, maxy) or GeoDataFrame.\n    \"\"\"\n    bounds = gdf.total_bounds\n    if return_geom:\n        return bbox_to_gdf(bbox=bounds)\n    else:\n        return bounds\n</code></pre>"},{"location":"common/#beamgis.common.gdf_centroid","title":"<code>gdf_centroid(gdf, return_geom=False)</code>","text":"<p>Returns the centroid of a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>return_geom</code> <code>bool</code> <p>Whether to return the bounding box as a GeoDataFrame. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list | gpd.GeoDataFrame</code> <p>A bounding box in the form of a list (lon, lat) or GeoDataFrame.</p> Source code in <code>beamgis/common.py</code> <pre><code>def gdf_centroid(gdf, return_geom=False):\n    \"\"\"Returns the centroid of a GeoDataFrame.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        return_geom (bool, optional): Whether to return the bounding box as a GeoDataFrame. Defaults to False.\n\n    Returns:\n        list | gpd.GeoDataFrame: A bounding box in the form of a list (lon, lat) or GeoDataFrame.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    centroid = gdf_bounds(gdf, return_geom=True).centroid\n    if return_geom:\n        return centroid\n    else:\n        return centroid.x[0], centroid.y[0]\n</code></pre>"},{"location":"common/#beamgis.common.gdf_geom_type","title":"<code>gdf_geom_type(gdf, first_only=True)</code>","text":"<p>Returns the geometry type of a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>first_only</code> <code>bool</code> <p>Whether to return the geometry type of the f irst feature in the GeoDataFrame. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The geometry type of the GeoDataFrame, such as Point, LineString,     Polygon, MultiPoint, MultiLineString, MultiPolygon.     For more info, see https://shapely.readthedocs.io/en/stable/manual.html</p> Source code in <code>beamgis/common.py</code> <pre><code>def gdf_geom_type(gdf, first_only=True):\n    \"\"\"Returns the geometry type of a GeoDataFrame.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        first_only (bool, optional): Whether to return the geometry type of the f\n            irst feature in the GeoDataFrame. Defaults to True.\n\n    Returns:\n        str: The geometry type of the GeoDataFrame, such as Point, LineString,\n            Polygon, MultiPoint, MultiLineString, MultiPolygon.\n            For more info, see https://shapely.readthedocs.io/en/stable/manual.html\n    \"\"\"\n    import geopandas as gpd\n\n    if first_only:\n        return gdf.geometry.type[0]\n    else:\n        return gdf.geometry.type\n</code></pre>"},{"location":"common/#beamgis.common.gdf_to_bokeh","title":"<code>gdf_to_bokeh(gdf)</code>","text":"<p>Function to convert a GeoPandas GeoDataFrame to a Bokeh ColumnDataSource object.</p> <p>:param: (GeoDataFrame) gdf: GeoPandas GeoDataFrame with polygon(s) under                             the column name 'geometry.'</p> <p>:return: ColumnDataSource for Bokeh.</p> Source code in <code>beamgis/common.py</code> <pre><code>def gdf_to_bokeh(gdf):\n    \"\"\"\n    Function to convert a GeoPandas GeoDataFrame to a Bokeh\n    ColumnDataSource object.\n\n    :param: (GeoDataFrame) gdf: GeoPandas GeoDataFrame with polygon(s) under\n                                the column name 'geometry.'\n\n    :return: ColumnDataSource for Bokeh.\n    \"\"\"\n    from bokeh.plotting import ColumnDataSource\n\n    shape_type = gdf_geom_type(gdf)\n\n    gdf_new = gdf.drop(\"geometry\", axis=1).copy()\n    gdf_new[\"x\"] = gdf.apply(\n        get_geometry_coords,\n        geom=\"geometry\",\n        coord_type=\"x\",\n        shape_type=shape_type,\n        mercator=True,\n        axis=1,\n    )\n\n    gdf_new[\"y\"] = gdf.apply(\n        get_geometry_coords,\n        geom=\"geometry\",\n        coord_type=\"y\",\n        shape_type=shape_type,\n        mercator=True,\n        axis=1,\n    )\n\n    return ColumnDataSource(gdf_new)\n</code></pre>"},{"location":"common/#beamgis.common.gdf_to_df","title":"<code>gdf_to_df(gdf, drop_geom=True)</code>","text":"<p>Converts a GeoDataFrame to a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>drop_geom</code> <code>bool</code> <p>Whether to drop the geometry column. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A pandas DataFrame containing the GeoDataFrame.</p> Source code in <code>beamgis/common.py</code> <pre><code>def gdf_to_df(gdf, drop_geom=True):\n    \"\"\"Converts a GeoDataFrame to a pandas DataFrame.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        drop_geom (bool, optional): Whether to drop the geometry column. Defaults to True.\n\n    Returns:\n        pd.DataFrame: A pandas DataFrame containing the GeoDataFrame.\n    \"\"\"\n    import pandas as pd\n\n    if drop_geom:\n        df = pd.DataFrame(gdf.drop(columns=[\"geometry\"]))\n    else:\n        df = pd.DataFrame(gdf)\n\n    return df\n</code></pre>"},{"location":"common/#beamgis.common.gdf_to_geojson","title":"<code>gdf_to_geojson(gdf, out_geojson=None, epsg=None, tuple_to_list=False, encoding='utf-8')</code>","text":"<p>Converts a GeoDataFame to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> required <code>out_geojson</code> <code>str</code> <p>File path to he output GeoJSON. Defaults to None.</p> <code>None</code> <code>epsg</code> <code>str</code> <p>An EPSG string, e.g., \"4326\". Defaults to None.</p> <code>None</code> <code>tuple_to_list</code> <code>bool</code> <p>Whether to convert tuples to lists. Defaults to False.</p> <code>False</code> <code>encoding</code> <code>str</code> <p>The encoding to use for the GeoJSON. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>When the output file extension is incorrect.</p> <code>Exception</code> <p>When the conversion fails.</p> <p>Returns:</p> Type Description <code>dict</code> <p>When the out_json is None returns a dict.</p> Source code in <code>beamgis/common.py</code> <pre><code>def gdf_to_geojson(\n    gdf, out_geojson=None, epsg=None, tuple_to_list=False, encoding=\"utf-8\"\n):\n    \"\"\"Converts a GeoDataFame to GeoJSON.\n\n    Args:\n        gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n        out_geojson (str, optional): File path to he output GeoJSON. Defaults to None.\n        epsg (str, optional): An EPSG string, e.g., \"4326\". Defaults to None.\n        tuple_to_list (bool, optional): Whether to convert tuples to lists. Defaults to False.\n        encoding (str, optional): The encoding to use for the GeoJSON. Defaults to \"utf-8\".\n\n    Raises:\n        TypeError: When the output file extension is incorrect.\n        Exception: When the conversion fails.\n\n    Returns:\n        dict: When the out_json is None returns a dict.\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    def listit(t):\n        return list(map(listit, t)) if isinstance(t, (list, tuple)) else t\n\n    try:\n        if epsg is not None:\n            if gdf.crs is not None and gdf.crs.to_epsg() != epsg:\n                gdf = gdf.to_crs(epsg=epsg)\n        geojson = gdf.__geo_interface__\n\n        if tuple_to_list:\n            for feature in geojson[\"features\"]:\n                feature[\"geometry\"][\"coordinates\"] = listit(\n                    feature[\"geometry\"][\"coordinates\"]\n                )\n\n        if out_geojson is None:\n            return geojson\n        else:\n            ext = os.path.splitext(out_geojson)[1]\n            if ext.lower() not in [\".json\", \".geojson\"]:\n                raise TypeError(\n                    \"The output file extension must be either .json or .geojson\"\n                )\n            out_dir = os.path.dirname(out_geojson)\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n\n            gdf.to_file(out_geojson, driver=\"GeoJSON\", encoding=encoding)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.gedi_download_file","title":"<code>gedi_download_file(url, filename=None, username=None, password=None)</code>","text":"<p>Downloads a file from the given URL and saves it to the specified filename. If no filename is provided, the name of the file from the URL will be used.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the file to download. e.g., https://daac.ornl.gov/daacdata/gedi/GEDI_L4A_AGB_Density_V2_1/data/GEDI04_A_2019298202754_O04921_01_T02899_02_002_02_V002.h5</p> required <code>filename</code> <code>str</code> <p>The name of the file to save the downloaded content to. Defaults to None.</p> <code>None</code> <code>username</code> <code>str</code> <p>Username for authentication. Can also be set using the EARTHDATA_USERNAME environment variable. Defaults to None. Create an account at https://urs.earthdata.nasa.gov</p> <code>None</code> <code>password</code> <code>str</code> <p>Password for authentication. Can also be set using the EARTHDATA_PASSWORD environment variable. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>beamgis/common.py</code> <pre><code>def gedi_download_file(\n    url: str, filename: str = None, username: str = None, password: str = None\n) -&gt; None:\n    \"\"\"\n    Downloads a file from the given URL and saves it to the specified filename.\n    If no filename is provided, the name of the file from the URL will be used.\n\n    Args:\n        url (str): The URL of the file to download.\n            e.g., https://daac.ornl.gov/daacdata/gedi/GEDI_L4A_AGB_Density_V2_1/data/GEDI04_A_2019298202754_O04921_01_T02899_02_002_02_V002.h5\n        filename (str, optional): The name of the file to save the downloaded content to. Defaults to None.\n        username (str, optional): Username for authentication. Can also be set using the EARTHDATA_USERNAME environment variable. Defaults to None.\n            Create an account at https://urs.earthdata.nasa.gov\n        password (str, optional): Password for authentication. Can also be set using the EARTHDATA_PASSWORD environment variable. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    import requests\n    from tqdm import tqdm\n    from urllib.parse import urlparse\n\n    if username is None:\n        username = os.environ.get(\"EARTHDATA_USERNAME\", None)\n    if password is None:\n        password = os.environ.get(\"EARTHDATA_PASSWORD\", None)\n\n    if username is None or password is None:\n        raise ValueError(\n            \"Username and password must be provided. Create an account at https://urs.earthdata.nasa.gov.\"\n        )\n\n    with requests.Session() as session:\n        r1 = session.request(\"get\", url, stream=True)\n        r = session.get(r1.url, auth=(username, password), stream=True)\n        print(r.status_code)\n\n        if r.status_code == 200:\n            total_size = int(r.headers.get(\"content-length\", 0))\n            block_size = 1024  # 1 KB\n\n            # Use the filename from the URL if not provided\n            if not filename:\n                parsed_url = urlparse(url)\n                filename = parsed_url.path.split(\"/\")[-1]\n\n            progress_bar = tqdm(total=total_size, unit=\"B\", unit_scale=True)\n\n            with open(filename, \"wb\") as file:\n                for data in r.iter_content(block_size):\n                    progress_bar.update(len(data))\n                    file.write(data)\n\n            progress_bar.close()\n</code></pre>"},{"location":"common/#beamgis.common.gedi_download_files","title":"<code>gedi_download_files(urls, outdir=None, filenames=None, username=None, password=None, overwrite=False)</code>","text":"<p>Downloads files from the given URLs and saves them to the specified directory. If no directory is provided, the current directory will be used. If no filenames are provided, the names of the files from the URLs will be used.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>List[str]</code> <p>The URLs of the files to download. e.g., [\"https://example.com/file1.txt\", \"https://example.com/file2.txt\"]</p> required <code>outdir</code> <code>str</code> <p>The directory to save the downloaded files to. Defaults to None.</p> <code>None</code> <code>filenames</code> <code>str</code> <p>The names of the files to save the downloaded content to. Defaults to None.</p> <code>None</code> <code>username</code> <code>str</code> <p>Username for authentication. Can also be set using the EARTHDATA_USERNAME environment variable. Defaults to None. Create an account at https://urs.earthdata.nasa.gov</p> <code>None</code> <code>password</code> <code>str</code> <p>Password for authentication. Can also be set using the EARTHDATA_PASSWORD environment variable. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the existing output files. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>beamgis/common.py</code> <pre><code>def gedi_download_files(\n    urls: List[str],\n    outdir: str = None,\n    filenames: str = None,\n    username: str = None,\n    password: str = None,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    Downloads files from the given URLs and saves them to the specified directory.\n    If no directory is provided, the current directory will be used.\n    If no filenames are provided, the names of the files from the URLs will be used.\n\n    Args:\n        urls (List[str]): The URLs of the files to download.\n            e.g., [\"https://example.com/file1.txt\", \"https://example.com/file2.txt\"]\n        outdir (str, optional): The directory to save the downloaded files to. Defaults to None.\n        filenames (str, optional): The names of the files to save the downloaded content to. Defaults to None.\n        username (str, optional): Username for authentication. Can also be set using the EARTHDATA_USERNAME environment variable. Defaults to None.\n            Create an account at https://urs.earthdata.nasa.gov\n        password (str, optional): Password for authentication. Can also be set using the EARTHDATA_PASSWORD environment variable. Defaults to None.\n        overwrite (bool): Whether to overwrite the existing output files. Default is False.\n\n    Returns:\n        None\n    \"\"\"\n\n    import requests\n    from tqdm import tqdm\n    from urllib.parse import urlparse\n    import geopandas as gpd\n\n    if isinstance(urls, gpd.GeoDataFrame):\n        urls = urls[\"granule_url\"].tolist()\n\n    session = requests.Session()\n\n    if username is None:\n        username = os.environ.get(\"EARTHDATA_USERNAME\", None)\n    if password is None:\n        password = os.environ.get(\"EARTHDATA_PASSWORD\", None)\n\n    if username is None or password is None:\n        print(\"Username and password must be provided.\")\n        return\n\n    if outdir is None:\n        outdir = os.getcwd()\n\n    if not os.path.exists(outdir):\n        os.makedirs(outdir)\n\n    for index, url in enumerate(urls):\n        print(f\"Downloading file {index+1} of {len(urls)}...\")\n\n        if url is None:\n            continue\n\n        # Use the filename from the URL if not provided\n        if not filenames:\n            parsed_url = urlparse(url)\n            filename = parsed_url.path.split(\"/\")[-1]\n        else:\n            filename = filenames.pop(0)\n\n        filepath = os.path.join(outdir, filename)\n        if os.path.exists(filepath) and not overwrite:\n            print(f\"File {filepath} already exists. Skipping...\")\n            continue\n\n        r1 = session.request(\"get\", url, stream=True)\n        r = session.get(r1.url, auth=(username, password), stream=True)\n\n        if r.status_code == 200:\n            total_size = int(r.headers.get(\"content-length\", 0))\n            block_size = 1024  # 1 KB\n\n            progress_bar = tqdm(total=total_size, unit=\"B\", unit_scale=True)\n\n            with open(filepath, \"wb\") as file:\n                for data in r.iter_content(block_size):\n                    progress_bar.update(len(data))\n                    file.write(data)\n\n            progress_bar.close()\n\n    session.close()\n</code></pre>"},{"location":"common/#beamgis.common.gedi_search","title":"<code>gedi_search(roi, start_date=None, end_date=None, add_roi=False, return_type='gdf', output=None, sort_filesize=False, **kwargs)</code>","text":"<p>Searches for GEDI data using the Common Metadata Repository (CMR) API. The source code for this function is adapted from https://github.com/ornldaac/gedi_tutorials. Credits to ORNL DAAC and Rupesh Shrestha.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <p>A list, tuple, or file path representing the bounding box coordinates in the format (min_lon, min_lat, max_lon, max_lat), or a GeoDataFrame containing the region of interest geometry.</p> required <code>start_date</code> <code>Optional[str]</code> <p>The start date of the temporal range to search for data in the format 'YYYY-MM-DD'.</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>The end date of the temporal range to search for data in the format 'YYYY-MM-DD'.</p> <code>None</code> <code>add_roi</code> <code>bool</code> <p>A boolean value indicating whether to include the region of interest as a granule in the search results. Default is False.</p> <code>False</code> <code>return_type</code> <code>str</code> <p>The type of the search results to return. Must be one of 'df' (DataFrame), 'gdf' (GeoDataFrame), or 'csv' (CSV file). Default is 'gdf'.</p> <code>'gdf'</code> <code>output</code> <code>Optional[str]</code> <p>The file path to save the CSV output when return_type is 'csv'. Optional and only applicable when return_type is 'csv'.</p> <code>None</code> <code>sort_filesize</code> <code>bool</code> <p>A boolean value indicating whether to sort the search results.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the CMR API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[pandas.core.frame.DataFrame]</code> <p>The search results as a pandas DataFrame (return_type='df'), geopandas GeoDataFrame (return_type='gdf'), or a CSV file (return_type='csv').</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If roi is not a list, tuple, or file path.</p> Source code in <code>beamgis/common.py</code> <pre><code>def gedi_search(\n    roi,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    add_roi: bool = False,\n    return_type: str = \"gdf\",\n    output: Optional[str] = None,\n    sort_filesize: bool = False,\n    **kwargs,\n) -&gt; Union[pd.DataFrame, None]:\n    \"\"\"\n    Searches for GEDI data using the Common Metadata Repository (CMR) API.\n    The source code for this function is adapted from https://github.com/ornldaac/gedi_tutorials.\n    Credits to ORNL DAAC and Rupesh Shrestha.\n\n    Args:\n        roi: A list, tuple, or file path representing the bounding box coordinates\n            in the format (min_lon, min_lat, max_lon, max_lat), or a GeoDataFrame\n            containing the region of interest geometry.\n        start_date: The start date of the temporal range to search for data\n            in the format 'YYYY-MM-DD'.\n        end_date: The end date of the temporal range to search for data\n            in the format 'YYYY-MM-DD'.\n        add_roi: A boolean value indicating whether to include the region of interest\n            as a granule in the search results. Default is False.\n        return_type: The type of the search results to return. Must be one of 'df'\n            (DataFrame), 'gdf' (GeoDataFrame), or 'csv' (CSV file). Default is 'gdf'.\n        output: The file path to save the CSV output when return_type is 'csv'.\n            Optional and only applicable when return_type is 'csv'.\n        sort_filesize: A boolean value indicating whether to sort the search results.\n        **kwargs: Additional keyword arguments to be passed to the CMR API.\n\n    Returns:\n        The search results as a pandas DataFrame (return_type='df'), geopandas GeoDataFrame\n        (return_type='gdf'), or a CSV file (return_type='csv').\n\n    Raises:\n        ValueError: If roi is not a list, tuple, or file path.\n\n    \"\"\"\n\n    import requests\n    import datetime as dt\n    import pandas as pd\n    import geopandas as gpd\n    from shapely.geometry import MultiPolygon, Polygon, box\n    from shapely.ops import orient\n\n    # CMR API base url\n    cmrurl = \"https://cmr.earthdata.nasa.gov/search/\"\n\n    doi = \"10.3334/ORNLDAAC/2056\"  # GEDI L4A DOI\n\n    # Construct the DOI search URL\n    doisearch = cmrurl + \"collections.json?doi=\" + doi\n\n    # Send a request to the CMR API to get the concept ID\n    response = requests.get(doisearch)\n    response.raise_for_status()\n    concept_id = response.json()[\"feed\"][\"entry\"][0][\"id\"]\n\n    # CMR formatted start and end times\n    if start_date is not None and end_date is not None:\n        dt_format = \"%Y-%m-%dT%H:%M:%SZ\"\n        start_date = dt.datetime.strptime(start_date, \"%Y-%m-%d\")\n        end_date = dt.datetime.strptime(end_date, \"%Y-%m-%d\")\n        temporal_str = (\n            start_date.strftime(dt_format) + \",\" + end_date.strftime(dt_format)\n        )\n    else:\n        temporal_str = None\n\n    # CMR formatted bounding box\n    if isinstance(roi, list) or isinstance(roi, tuple):\n        bound_str = \",\".join(map(str, roi))\n    elif isinstance(roi, str):\n        roi = gpd.read_file(roi)\n        roi.geometry = roi.geometry.apply(orient, args=(1,))  # make counter-clockwise\n    elif isinstance(roi, gpd.GeoDataFrame):\n        roi.geometry = roi.geometry.apply(orient, args=(1,))  # make counter-clockwise\n    else:\n        raise ValueError(\"roi must be a list, tuple, or a file path.\")\n\n    page_num = 1\n    page_size = 2000  # CMR page size limit\n\n    granule_arr = []\n\n    while True:\n        # Define CMR search parameters\n        cmr_param = {\n            \"collection_concept_id\": concept_id,\n            \"page_size\": page_size,\n            \"page_num\": page_num,\n        }\n\n        if temporal_str is not None:\n            cmr_param[\"temporal\"] = temporal_str\n\n        if kwargs:\n            cmr_param.update(kwargs)\n\n        granulesearch = cmrurl + \"granules.json\"\n\n        if isinstance(roi, list) or isinstance(roi, tuple):\n            cmr_param[\"bounding_box[]\"] = bound_str\n            response = requests.get(granulesearch, params=cmr_param)\n            response.raise_for_status()\n        else:\n            cmr_param[\"simplify-shapefile\"] = \"true\"\n            geojson = {\n                \"shapefile\": (\n                    \"region.geojson\",\n                    roi.geometry.to_json(),\n                    \"application/geo+json\",\n                )\n            }\n            response = requests.post(granulesearch, data=cmr_param, files=geojson)\n\n        # Send a request to the CMR API to get the granules\n        granules = response.json()[\"feed\"][\"entry\"]\n\n        if granules:\n            for index, g in enumerate(granules):\n                granule_url = \"\"\n                granule_poly = \"\"\n\n                # Read file size\n                granule_size = float(g[\"granule_size\"])\n\n                # Read bounding geometries\n                if \"polygons\" in g:\n                    polygons = g[\"polygons\"]\n                    multipolygons = []\n                    for poly in polygons:\n                        i = iter(poly[0].split(\" \"))\n                        ltln = list(map(\" \".join, zip(i, i)))\n                        multipolygons.append(\n                            Polygon(\n                                [\n                                    [float(p.split(\" \")[1]), float(p.split(\" \")[0])]\n                                    for p in ltln\n                                ]\n                            )\n                        )\n                    granule_poly = MultiPolygon(multipolygons)\n\n                # Get URL to HDF5 files\n                for links in g[\"links\"]:\n                    if (\n                        \"title\" in links\n                        and links[\"title\"].startswith(\"Download\")\n                        and links[\"title\"].endswith(\".h5\")\n                    ):\n                        granule_url = links[\"href\"]\n\n                granule_id = g[\"id\"]\n                title = g[\"title\"]\n                time_start = g[\"time_start\"]\n                time_end = g[\"time_end\"]\n\n                granule_arr.append(\n                    [\n                        granule_id,\n                        title,\n                        time_start,\n                        time_end,\n                        granule_size,\n                        granule_url,\n                        granule_poly,\n                    ]\n                )\n\n            page_num += 1\n        else:\n            break\n\n    # Add bound as the last row into the dataframe\n    if add_roi:\n        if isinstance(roi, list) or isinstance(roi, tuple):\n            b = list(roi)\n            granule_arr.append(\n                [\"roi\", None, None, None, 0, None, box(b[0], b[1], b[2], b[3])]\n            )\n        else:\n            granule_arr.append([\"roi\", None, None, None, 0, None, roi.geometry.item()])\n\n    # Create a pandas dataframe\n    columns = [\n        \"id\",\n        \"title\",\n        \"time_start\",\n        \"time_end\",\n        \"granule_size\",\n        \"granule_url\",\n        \"granule_poly\",\n    ]\n    l4adf = pd.DataFrame(granule_arr, columns=columns)\n\n    # Drop granules with empty geometry\n    l4adf = l4adf[l4adf[\"granule_poly\"] != \"\"]\n\n    if sort_filesize:\n        l4adf = l4adf.sort_values(by=[\"granule_size\"], ascending=True)\n\n    if return_type == \"df\":\n        return l4adf\n    elif return_type == \"gdf\":\n        gdf = gpd.GeoDataFrame(l4adf, geometry=\"granule_poly\")\n        gdf.crs = \"EPSG:4326\"\n        return gdf\n    elif return_type == \"csv\":\n        columns.remove(\"granule_poly\")\n        return l4adf.to_csv(output, index=False, columns=columns)\n    else:\n        raise ValueError(\"return_type must be one of 'df', 'gdf', or 'csv'.\")\n</code></pre>"},{"location":"common/#beamgis.common.gedi_subset","title":"<code>gedi_subset(spatial=None, start_date=None, end_date=None, out_dir=None, collection=None, variables=['all'], max_results=None, username=None, password=None, overwrite=False, **kwargs)</code>","text":"<p>Subsets GEDI data using the Harmony API.</p> <p>Parameters:</p> Name Type Description Default <code>spatial</code> <code>Union[str, gpd.GeoDataFrame, List[float]]</code> <p>Spatial extent for subsetting. Can be a file path to a shapefile, a GeoDataFrame, or a list of bounding box coordinates [minx, miny, maxx, maxy]. Defaults to None.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>Start date for subsetting in 'YYYY-MM-DD' format. Defaults to None.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>End date for subsetting in 'YYYY-MM-DD' format. Defaults to None.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>Output directory to save the subsetted files. Defaults to None, which will use the current working directory.</p> <code>None</code> <code>collection</code> <code>Collection</code> <p>GEDI data collection. If not provided, the default collection with DOI '10.3334/ORNLDAAC/2056' will be used. Defaults to None.</p> <code>None</code> <code>variables</code> <code>List[str]</code> <p>List of variable names to subset. Defaults to ['all'], which subsets all available variables.</p> <code>['all']</code> <code>max_results</code> <code>int</code> <p>Maximum number of results to return. Defaults to None, which returns all results.</p> <code>None</code> <code>username</code> <code>str</code> <p>Earthdata username. Defaults to None, which will attempt to read from the 'EARTHDATA_USERNAME' environment variable.</p> <code>None</code> <code>password</code> <code>str</code> <p>Earthdata password. Defaults to None, which will attempt to read from the 'EARTHDATA_PASSWORD' environment variable.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing files in the output directory. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the Harmony API request.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the 'harmony' package is not installed.</p> <code>ValueError</code> <p>If the 'spatial', 'start_date', or 'end_date' arguments are not valid.</p> <p>Returns:</p> Type Description <code>None</code> <p>This function does not return any value.</p> Source code in <code>beamgis/common.py</code> <pre><code>def gedi_subset(\n    spatial=None,\n    start_date=None,\n    end_date=None,\n    out_dir=None,\n    collection=None,\n    variables=[\"all\"],\n    max_results=None,\n    username=None,\n    password=None,\n    overwrite=False,\n    **kwargs,\n):\n    \"\"\"\n    Subsets GEDI data using the Harmony API.\n\n    Args:\n        spatial (Union[str, gpd.GeoDataFrame, List[float]], optional): Spatial extent for subsetting.\n            Can be a file path to a shapefile, a GeoDataFrame, or a list of bounding box coordinates [minx, miny, maxx, maxy].\n            Defaults to None.\n        start_date (str, optional): Start date for subsetting in 'YYYY-MM-DD' format.\n            Defaults to None.\n        end_date (str, optional): End date for subsetting in 'YYYY-MM-DD' format.\n            Defaults to None.\n        out_dir (str, optional): Output directory to save the subsetted files.\n            Defaults to None, which will use the current working directory.\n        collection (Collection, optional): GEDI data collection. If not provided,\n            the default collection with DOI '10.3334/ORNLDAAC/2056' will be used.\n            Defaults to None.\n        variables (List[str], optional): List of variable names to subset.\n            Defaults to ['all'], which subsets all available variables.\n        max_results (int, optional): Maximum number of results to return.\n            Defaults to None, which returns all results.\n        username (str, optional): Earthdata username.\n            Defaults to None, which will attempt to read from the 'EARTHDATA_USERNAME' environment variable.\n        password (str, optional): Earthdata password.\n            Defaults to None, which will attempt to read from the 'EARTHDATA_PASSWORD' environment variable.\n        overwrite (bool, optional): Whether to overwrite existing files in the output directory.\n            Defaults to False.\n        **kwargs: Additional keyword arguments to pass to the Harmony API request.\n\n    Raises:\n        ImportError: If the 'harmony' package is not installed.\n        ValueError: If the 'spatial', 'start_date', or 'end_date' arguments are not valid.\n\n    Returns:\n        None: This function does not return any value.\n    \"\"\"\n\n    try:\n        import harmony  # pylint: disable=E0401\n    except ImportError:\n        install_package(\"harmony-py\")\n\n    import requests as re\n    import geopandas as gpd\n    from datetime import datetime\n    from harmony import (\n        BBox,\n        Client,\n        Collection,\n        Environment,\n        Request,\n    )  # pylint: disable=E0401\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if collection is None:\n        # GEDI L4A DOI\n        doi = \"10.3334/ORNLDAAC/2056\"\n\n        # CMR API base url\n        doisearch = f\"https://cmr.earthdata.nasa.gov/search/collections.json?doi={doi}\"\n        concept_id = re.get(doisearch).json()[\"feed\"][\"entry\"][0][\"id\"]\n        concept_id\n        collection = Collection(id=concept_id)\n\n    if username is None:\n        username = os.environ.get(\"EARTHDATA_USERNAME\", None)\n    if password is None:\n        password = os.environ.get(\"EARTHDATA_PASSWORD\", None)\n\n    if username is None or password is None:\n        raise ValueError(\"username and password must be provided.\")\n\n    harmony_client = Client(auth=(username, password))\n\n    if isinstance(spatial, str):\n        spatial = gpd.read_file(spatial)\n\n    if isinstance(spatial, gpd.GeoDataFrame):\n        spatial = spatial.total_bounds.tolist()\n\n    if isinstance(spatial, list) and len(spatial) == 4:\n        bounding_box = BBox(spatial[0], spatial[1], spatial[2], spatial[3])\n    else:\n        raise ValueError(\n            \"spatial must be a list of bounding box coordinates or a GeoDataFrame, or a file path.\"\n        )\n\n    if isinstance(start_date, str):\n        start_date = datetime.strptime(start_date, \"%Y-%m-%d\")\n\n    if isinstance(end_date, str):\n        end_date = datetime.strptime(end_date, \"%Y-%m-%d\")\n\n    if start_date is None or end_date is None:\n        print(\"start_date and end_date must be provided.\")\n        temporal_range = None\n    else:\n        temporal_range = {\"start\": start_date, \"end\": end_date}\n\n    request = Request(\n        collection=collection,\n        variables=variables,\n        temporal=temporal_range,\n        spatial=bounding_box,\n        ignore_errors=True,\n        max_results=max_results,\n        **kwargs,\n    )\n\n    # submit harmony request, will return job id\n    subset_job_id = harmony_client.submit(request)\n\n    print(f\"Processing job: {subset_job_id}\")\n\n    print(f\"Waiting for the job to finish\")\n    results = harmony_client.result_json(subset_job_id, show_progress=True)\n\n    print(f\"Downloading subset files...\")\n    futures = harmony_client.download_all(\n        subset_job_id, directory=out_dir, overwrite=overwrite\n    )\n    for f in futures:\n        # all subsetted files have this suffix\n        if f.result().endswith(\"subsetted.h5\"):\n            print(f\"Downloaded: {f.result()}\")\n\n    print(f\"Done downloading files.\")\n</code></pre>"},{"location":"common/#beamgis.common.generate_index_html","title":"<code>generate_index_html(directory, output='index.html')</code>","text":"<p>Generates an HTML file named 'index.html' in the specified directory, listing all files in that directory as clickable links.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>The path to the directory for which to generate the index.html file.</p> required <code>output</code> <code>str</code> <p>The name of the output HTML file. Defaults to \"index.html\".</p> <code>'index.html'</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>beamgis/common.py</code> <pre><code>def generate_index_html(directory: str, output: str = \"index.html\") -&gt; None:\n    \"\"\"\n    Generates an HTML file named 'index.html' in the specified directory, listing\n    all files in that directory as clickable links.\n\n    Args:\n        directory (str): The path to the directory for which to generate the index.html file.\n        output (str, optional): The name of the output HTML file. Defaults to \"index.html\".\n\n    Returns:\n        None\n    \"\"\"\n    # Get a list of files in the directory\n    files = sorted(\n        [f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]\n    )\n\n    # Start the HTML content\n    html_content = \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Index of {directory}&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Index of {directory}&lt;/h1&gt;\n    &lt;ul&gt;\n\"\"\".format(\n        directory=directory\n    )\n\n    # Add each file to the HTML list\n    for file in files:\n        html_content += '        &lt;li&gt;&lt;a href=\"{file}\"&gt;{file}&lt;/a&gt;&lt;/li&gt;\\n'.format(\n            file=file\n        )\n\n    # Close the HTML content\n    html_content += \"\"\"    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n\n    # Write the HTML content to index.html in the specified directory\n    with open(os.path.join(directory, output), \"w\") as f:\n        f.write(html_content)\n</code></pre>"},{"location":"common/#beamgis.common.geojson_bounds","title":"<code>geojson_bounds(geojson)</code>","text":"<p>Calculate the bounds of a GeoJSON object.</p> <p>This function uses the shapely library to calculate the bounds of a GeoJSON object. If the shapely library is not installed, it will print a message and return None.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>A dictionary representing a GeoJSON object.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of bounds (minx, miny, maxx, maxy) if shapely is installed, None otherwise.</p> Source code in <code>beamgis/common.py</code> <pre><code>def geojson_bounds(geojson: dict) -&gt; Optional[list]:\n    \"\"\"\n    Calculate the bounds of a GeoJSON object.\n\n    This function uses the shapely library to calculate the bounds of a GeoJSON object.\n    If the shapely library is not installed, it will print a message and return None.\n\n    Args:\n        geojson (dict): A dictionary representing a GeoJSON object.\n\n    Returns:\n        list: A list of bounds (minx, miny, maxx, maxy) if shapely is installed, None otherwise.\n    \"\"\"\n    try:\n        import shapely\n    except ImportError:\n        print(\"shapely is not installed\")\n        return\n\n    if isinstance(geojson, str):\n        geojson = json.loads(geojson)\n\n    return list(shapely.bounds(shapely.from_geojson(json.dumps(geojson))))\n</code></pre>"},{"location":"common/#beamgis.common.geojson_to_df","title":"<code>geojson_to_df(in_geojson, encoding='utf-8', drop_geometry=True)</code>","text":"<p>Converts a GeoJSON object to a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The input GeoJSON file or dict.</p> required <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON object. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <code>drop_geometry</code> <code>bool</code> <p>Whether to drop the geometry column. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the input GeoJSON file could not be found.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A pandas DataFrame containing the GeoJSON object.</p> Source code in <code>beamgis/common.py</code> <pre><code>def geojson_to_df(in_geojson, encoding=\"utf-8\", drop_geometry=True):\n    \"\"\"Converts a GeoJSON object to a pandas DataFrame.\n\n    Args:\n        in_geojson (str | dict): The input GeoJSON file or dict.\n        encoding (str, optional): The encoding of the GeoJSON object. Defaults to \"utf-8\".\n        drop_geometry (bool, optional): Whether to drop the geometry column. Defaults to True.\n\n    Raises:\n        FileNotFoundError: If the input GeoJSON file could not be found.\n\n    Returns:\n        pd.DataFrame: A pandas DataFrame containing the GeoJSON object.\n    \"\"\"\n\n    import json\n    import pandas as pd\n    from urllib.request import urlopen\n\n    if isinstance(in_geojson, str):\n        if in_geojson.startswith(\"http\"):\n            with urlopen(in_geojson) as f:\n                data = json.load(f)\n        else:\n            in_geojson = os.path.abspath(in_geojson)\n            if not os.path.exists(in_geojson):\n                raise FileNotFoundError(\"The provided GeoJSON file could not be found.\")\n\n            with open(in_geojson, encoding=encoding) as f:\n                data = json.load(f)\n\n    elif isinstance(in_geojson, dict):\n        data = in_geojson\n\n    df = pd.json_normalize(data[\"features\"])\n    df.columns = [col.replace(\"properties.\", \"\") for col in df.columns]\n    if drop_geometry:\n        df = df[df.columns.drop(list(df.filter(regex=\"geometry\")))]\n    return df\n</code></pre>"},{"location":"common/#beamgis.common.geojson_to_gdf","title":"<code>geojson_to_gdf(in_geojson, encoding='utf-8', **kwargs)</code>","text":"<p>Converts a GeoJSON object to a geopandas GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The input GeoJSON file or GeoJSON object as a dict.</p> required <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON object. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>A geopandas GeoDataFrame containing the GeoJSON object.</p> Source code in <code>beamgis/common.py</code> <pre><code>def geojson_to_gdf(in_geojson, encoding=\"utf-8\", **kwargs):\n    \"\"\"Converts a GeoJSON object to a geopandas GeoDataFrame.\n\n    Args:\n        in_geojson (str | dict): The input GeoJSON file or GeoJSON object as a dict.\n        encoding (str, optional): The encoding of the GeoJSON object. Defaults to \"utf-8\".\n\n    Returns:\n        geopandas.GeoDataFrame: A geopandas GeoDataFrame containing the GeoJSON object.\n    \"\"\"\n\n    import geopandas as gpd\n\n    if isinstance(in_geojson, dict):\n        out_file = temp_file_path(extension=\"geojson\")\n        with open(out_file, \"w\") as f:\n            json.dump(in_geojson, f)\n            in_geojson = out_file\n\n    gdf = gpd.read_file(in_geojson, encoding=encoding, **kwargs)\n    return gdf\n</code></pre>"},{"location":"common/#beamgis.common.geojson_to_gpkg","title":"<code>geojson_to_gpkg(in_geojson, out_gpkg, **kwargs)</code>","text":"<p>Converts a GeoJSON object to GeoPackage.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The input GeoJSON file or dict.</p> required <code>out_gpkg</code> <code>str</code> <p>The output GeoPackage path.</p> required Source code in <code>beamgis/common.py</code> <pre><code>def geojson_to_gpkg(in_geojson, out_gpkg, **kwargs):\n    \"\"\"Converts a GeoJSON object to GeoPackage.\n\n    Args:\n        in_geojson (str | dict): The input GeoJSON file or dict.\n        out_gpkg (str): The output GeoPackage path.\n    \"\"\"\n    import geopandas as gpd\n    import json\n\n    ext = os.path.splitext(out_gpkg)[1]\n    if ext.lower() != \".gpkg\":\n        out_gpkg = out_gpkg + \".gpkg\"\n    out_gpkg = check_file_path(out_gpkg)\n\n    if isinstance(in_geojson, dict):\n        out_file = temp_file_path(extension=\"geojson\")\n        with open(out_file, \"w\") as f:\n            json.dump(in_geojson, f)\n            in_geojson = out_file\n\n    gdf = gpd.read_file(in_geojson, **kwargs)\n    name = os.path.splitext(os.path.basename(out_gpkg))[0]\n    gdf.to_file(out_gpkg, layer=name, driver=\"GPKG\")\n</code></pre>"},{"location":"common/#beamgis.common.geojson_to_mbtiles","title":"<code>geojson_to_mbtiles(input_file, output_file, layer_name=None, options=None, quiet=False)</code>","text":"<p>Converts vector data to .mbtiles using Tippecanoe.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the input vector data file (e.g., .geojson).</p> required <code>output_file</code> <code>str</code> <p>Path to the output .mbtiles file.</p> required <code>layer_name</code> <code>Optional[str]</code> <p>Optional name for the layer. Defaults to None.</p> <code>None</code> <code>options</code> <code>Optional[List[str]]</code> <p>List of additional arguments for tippecanoe. For example '-zg' for auto maxzoom. Defaults to None.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>If True, suppress the log output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Output from the Tippecanoe command, or None if there was an error or if Tippecanoe is not installed.</p> <p>Exceptions:</p> Type Description <code>subprocess.CalledProcessError</code> <p>If there's an error executing the tippecanoe command.</p> Source code in <code>beamgis/common.py</code> <pre><code>def geojson_to_mbtiles(\n    input_file: str,\n    output_file: str,\n    layer_name: Optional[str] = None,\n    options: Optional[List[str]] = None,\n    quiet: bool = False,\n) -&gt; Optional[str]:\n    \"\"\"\n    Converts vector data to .mbtiles using Tippecanoe.\n\n    Args:\n        input_file (str): Path to the input vector data file (e.g., .geojson).\n        output_file (str): Path to the output .mbtiles file.\n        layer_name (Optional[str]): Optional name for the layer. Defaults to None.\n        options (Optional[List[str]]): List of additional arguments for tippecanoe. For example '-zg' for auto maxzoom. Defaults to None.\n        quiet (bool): If True, suppress the log output. Defaults to False.\n\n    Returns:\n        Optional[str]: Output from the Tippecanoe command, or None if there was an error or if Tippecanoe is not installed.\n\n    Raises:\n        subprocess.CalledProcessError: If there's an error executing the tippecanoe command.\n    \"\"\"\n\n    import subprocess\n    import shutil\n\n    # Check if tippecanoe exists\n    if shutil.which(\"tippecanoe\") is None:\n        print(\"Error: tippecanoe is not installed.\")\n        print(\"You can install it using conda with the following command:\")\n        print(\"conda install -c conda-forge tippecanoe\")\n        return None\n\n    command = [\"tippecanoe\", \"-o\", output_file]\n\n    # Add layer name specification if provided\n    if layer_name:\n        command.extend([\"-L\", f\"{layer_name}:{input_file}\"])\n    else:\n        command.append(input_file)\n\n    # Append additional arguments if provided\n    if options:\n        command.extend(options)\n\n    try:\n        process = subprocess.Popen(\n            command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True\n        )\n\n        if not quiet:\n            for line in process.stdout:\n                print(line, end=\"\")\n\n        exit_code = process.wait()\n        if exit_code != 0:\n            raise subprocess.CalledProcessError(exit_code, command)\n\n    except subprocess.CalledProcessError as e:\n        print(f\"\\nError executing tippecanoe: {e}\")\n        return None\n\n    return \"Tippecanoe process completed successfully.\"\n</code></pre>"},{"location":"common/#beamgis.common.geojson_to_pmtiles","title":"<code>geojson_to_pmtiles(input_file, output_file=None, layer_name=None, projection='EPSG:4326', overwrite=False, options=None, quiet=False)</code>","text":"<p>Converts vector data to PMTiles using Tippecanoe.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the input vector data file (e.g., .geojson).</p> required <code>output_file</code> <code>str</code> <p>Path to the output .mbtiles file.</p> <code>None</code> <code>layer_name</code> <code>Optional[str]</code> <p>Optional name for the layer. Defaults to None.</p> <code>None</code> <code>projection</code> <code>Optional[str]</code> <p>Projection for the output PMTiles file. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite the existing output file. Defaults to False.</p> <code>False</code> <code>options</code> <code>Optional[List[str]]</code> <p>List of additional arguments for tippecanoe. Defaults to None. To reduce the size of the output file, use '-zg' or '-z max-zoom'.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>If True, suppress the log output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Output from the Tippecanoe command, or None if there was an error or if Tippecanoe is not installed.</p> <p>Exceptions:</p> Type Description <code>subprocess.CalledProcessError</code> <p>If there's an error executing the tippecanoe command.</p> Source code in <code>beamgis/common.py</code> <pre><code>def geojson_to_pmtiles(\n    input_file: str,\n    output_file: Optional[str] = None,\n    layer_name: Optional[str] = None,\n    projection: Optional[str] = \"EPSG:4326\",\n    overwrite: bool = False,\n    options: Optional[List[str]] = None,\n    quiet: bool = False,\n) -&gt; Optional[str]:\n    \"\"\"\n    Converts vector data to PMTiles using Tippecanoe.\n\n    Args:\n        input_file (str): Path to the input vector data file (e.g., .geojson).\n        output_file (str): Path to the output .mbtiles file.\n        layer_name (Optional[str]): Optional name for the layer. Defaults to None.\n        projection (Optional[str]): Projection for the output PMTiles file. Defaults to \"EPSG:4326\".\n        overwrite (bool): If True, overwrite the existing output file. Defaults to False.\n        options (Optional[List[str]]): List of additional arguments for tippecanoe. Defaults to None.\n            To reduce the size of the output file, use '-zg' or '-z max-zoom'.\n        quiet (bool): If True, suppress the log output. Defaults to False.\n\n    Returns:\n        Optional[str]: Output from the Tippecanoe command, or None if there was an error or if Tippecanoe is not installed.\n\n    Raises:\n        subprocess.CalledProcessError: If there's an error executing the tippecanoe command.\n    \"\"\"\n\n    import subprocess\n    import shutil\n\n    # Check if tippecanoe exists\n    if shutil.which(\"tippecanoe\") is None:\n        print(\"Error: tippecanoe is not installed.\")\n        print(\"You can install it using conda with the following command:\")\n        print(\"conda install -c conda-forge tippecanoe\")\n        return None\n\n    if output_file is None:\n        output_file = os.path.splitext(input_file)[0] + \".pmtiles\"\n\n    if not output_file.endswith(\".pmtiles\"):\n        raise ValueError(\"Error: output file must be a .pmtiles file.\")\n\n    command = [\"tippecanoe\", \"-o\", output_file]\n\n    # Add layer name specification if provided\n    if layer_name:\n        command.extend([\"-L\", f\"{layer_name}:{input_file}\"])\n    else:\n        command.append(input_file)\n\n    command.extend([\"--projection\", projection])\n\n    if options is None:\n        options = []\n\n    if overwrite:\n        command.append(\"--force\")\n\n    # Append additional arguments if provided\n    if options:\n        command.extend(options)\n\n    try:\n        process = subprocess.Popen(\n            command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True\n        )\n\n        if not quiet:\n            for line in process.stdout:\n                print(line, end=\"\")\n\n        exit_code = process.wait()\n        if exit_code != 0:\n            raise subprocess.CalledProcessError(exit_code, command)\n\n    except subprocess.CalledProcessError as e:\n        print(f\"\\nError executing tippecanoe: {e}\")\n        return None\n\n    return \"Tippecanoe process completed successfully.\"\n</code></pre>"},{"location":"common/#beamgis.common.geojson_to_shp","title":"<code>geojson_to_shp(in_geojson, out_shp, **kwargs)</code>","text":"<p>Converts a GeoJSON object to GeoPandas GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The input GeoJSON file or dict.</p> required <code>out_shp</code> <code>str</code> <p>The output shapefile path.</p> required Source code in <code>beamgis/common.py</code> <pre><code>def geojson_to_shp(in_geojson, out_shp, **kwargs):\n    \"\"\"Converts a GeoJSON object to GeoPandas GeoDataFrame.\n\n    Args:\n        in_geojson (str | dict): The input GeoJSON file or dict.\n        out_shp (str): The output shapefile path.\n    \"\"\"\n    import geopandas as gpd\n    import json\n\n    ext = os.path.splitext(out_shp)[1]\n    if ext != \".shp\":\n        out_shp = out_shp + \".shp\"\n    out_shp = check_file_path(out_shp)\n\n    if isinstance(in_geojson, dict):\n        out_file = temp_file_path(extension=\"geojson\")\n        with open(out_file, \"w\") as f:\n            json.dump(in_geojson, f)\n            in_geojson = out_file\n\n    gdf = gpd.read_file(in_geojson, **kwargs)\n    gdf.to_file(out_shp)\n</code></pre>"},{"location":"common/#beamgis.common.geojsonl_to_parquet_batch","title":"<code>geojsonl_to_parquet_batch(input_dir, output_dir, batch_size=50, file_ext='.json', filename_predix='batch_', **kwargs)</code>","text":"<p>Convert JSON Lines files to multiple GeoParquet files, with each GeoParquet file containing data from a specified number of JSON Lines files.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>str</code> <p>Directory containing JSON Lines files to convert</p> required <code>output_dir</code> <code>str</code> <p>Directory for output GeoParquet files</p> required <code>batch_size</code> <code>int</code> <p>Number of JSON Lines files to combine in each GeoParquet file.                         Defaults to 50.</p> <code>50</code> <code>file_ext</code> <code>str</code> <p>File extension of the input files. Defaults to \".json\".</p> <code>'.json'</code> <code>filename_predix</code> <code>str</code> <p>Prefix for the output GeoParquet files. Defaults to \"batch_\".</p> <code>'batch_'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the <code>to_parquet</code> function of GeoDataFrame.</p> <code>{}</code> Source code in <code>beamgis/common.py</code> <pre><code>def geojsonl_to_parquet_batch(\n    input_dir,\n    output_dir,\n    batch_size=50,\n    file_ext=\".json\",\n    filename_predix=\"batch_\",\n    **kwargs,\n):\n    \"\"\"\n    Convert JSON Lines files to multiple GeoParquet files, with each GeoParquet file\n    containing data from a specified number of JSON Lines files.\n\n    Args:\n        input_dir (str): Directory containing JSON Lines files to convert\n        output_dir (str): Directory for output GeoParquet files\n        batch_size (int, optional): Number of JSON Lines files to combine in each GeoParquet file.\n                                    Defaults to 50.\n        file_ext (str, optional): File extension of the input files. Defaults to \".json\".\n        filename_predix (str, optional): Prefix for the output GeoParquet files. Defaults to \"batch_\".\n        **kwargs: Additional keyword arguments to pass to the `to_parquet` function of GeoDataFrame.\n\n    \"\"\"\n    import geopandas as gpd\n    from shapely.geometry import shape\n    import glob\n    import math\n\n    if not os.path.exists(input_dir):\n        raise FileNotFoundError(f\"Input directory not found: {input_dir}\")\n\n    # Get all JSON files\n    json_files = glob.glob(os.path.join(input_dir, f\"*.{file_ext.lstrip('.')}\"))\n\n    if not json_files:\n        raise ValueError(f\"No JSON files found in {input_dir}\")\n\n    # Create output directory if it doesn't exist\n    os.makedirs(output_dir, exist_ok=True)\n\n    # Calculate number of output files\n    num_files = len(json_files)\n    num_batches = math.ceil(num_files / batch_size)\n\n    print(\n        f\"Processing {num_files} JSON Lines files into {num_batches} GeoParquet files\"\n    )\n\n    # Track statistics\n    processed_files = 0\n    processed_records = 0\n    failed_files = 0\n    successful_parquets = 0\n\n    # Process files in batches\n    for batch_num in range(num_batches):\n        print(f\"\\nProcessing batch {batch_num+1}/{num_batches}\")\n\n        # Generate output filename\n        output_file = os.path.join(\n            output_dir, f\"{filename_predix}{batch_num+1:04d}.parquet\"\n        )\n        if os.path.exists(output_file):\n            print(f\"Output file already exists: {output_file}\")\n            continue\n\n        start_idx = batch_num * batch_size\n        end_idx = min(start_idx + batch_size, num_files)\n        batch_files = json_files[start_idx:end_idx]\n\n        records = []\n\n        for file_path in batch_files:\n            try:\n                file_records = 0\n\n                # Process the file line by line (JSON Lines format)\n                with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                    for line in f:\n                        if line.strip():  # Skip empty lines\n                            try:\n                                data = json.loads(line)\n\n                                # Create a record with properties and geometry\n                                record = {}\n\n                                # Extract all properties except geometry\n                                for key, value in data.items():\n                                    if key != \"geometry\":\n                                        record[key] = value\n\n                                # Handle geometry\n                                if \"geometry\" in data:\n                                    # Convert the geometry to a Shapely object\n                                    record[\"geometry\"] = shape(data[\"geometry\"])\n                                else:\n                                    continue  # Skip records without geometry\n\n                                records.append(record)\n                                file_records += 1\n                            except json.JSONDecodeError as e:\n                                print(\n                                    f\"Error decoding JSON in file {file_path}: {str(e)}\"\n                                )\n                                continue  # Skip invalid JSON lines\n                            except Exception as e:\n                                print(\n                                    f\"Error processing record in file {file_path}: {str(e)}\"\n                                )\n                                continue  # Skip problematic records\n\n                # print(f\"Processed {file_records} records from {file_path}\")\n                processed_records += file_records\n                processed_files += 1\n\n            except Exception as e:\n                print(f\"Error processing file {file_path}: {str(e)}\")\n                failed_files += 1\n\n        if not records:\n            print(f\"No valid records found in batch {batch_num+1}\")\n            continue\n\n        # Create a GeoDataFrame with the correct CRS\n        gdf = gpd.GeoDataFrame(records, geometry=\"geometry\", crs=\"EPSG:4326\")\n\n        # Write to GeoParquet\n        gdf.to_parquet(output_file, index=False, **kwargs)\n        successful_parquets += 1\n\n        # Print summary for this batch\n        print(f\"Created GeoParquet file {batch_num+1}/{num_batches}: {output_file}\")\n        print(f\"  - Number of features: {len(gdf)}\")\n        print(f\"  - Columns: {list(gdf.columns)}\")\n        if len(gdf) &gt; 0:\n            print(\n                f\"  - First record attributes: {[k for k in gdf.iloc[0].keys() if k != 'geometry']}\"\n            )\n\n    # Print final summary\n    print(f\"\\nSummary:\")\n    print(f\"Total files processed: {processed_files} of {num_files}\")\n    print(f\"Failed files: {failed_files}\")\n    print(f\"Total records processed: {processed_records}\")\n    print(f\"GeoParquet files created: {successful_parquets}\")\n</code></pre>"},{"location":"common/#beamgis.common.geom_type","title":"<code>geom_type(in_geojson, encoding='utf-8')</code>","text":"<p>Returns the geometry type of a GeoJSON object.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>dict</code> <p>A GeoJSON object.</p> required <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON object. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Returns:</p> Type Description <code>str</code> <p>The geometry type of the GeoJSON object, such as Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon.     For more info, see https://shapely.readthedocs.io/en/stable/manual.html</p> Source code in <code>beamgis/common.py</code> <pre><code>def geom_type(in_geojson, encoding=\"utf-8\"):\n    \"\"\"Returns the geometry type of a GeoJSON object.\n\n    Args:\n        in_geojson (dict): A GeoJSON object.\n        encoding (str, optional): The encoding of the GeoJSON object. Defaults to \"utf-8\".\n\n    Returns:\n        str: The geometry type of the GeoJSON object, such as Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon.\n            For more info, see https://shapely.readthedocs.io/en/stable/manual.html\n    \"\"\"\n    import json\n\n    try:\n        if isinstance(in_geojson, str):\n            if in_geojson.startswith(\"http\"):\n                data = requests.get(in_geojson).json()\n            else:\n                in_geojson = os.path.abspath(in_geojson)\n                if not os.path.exists(in_geojson):\n                    raise FileNotFoundError(\n                        \"The provided GeoJSON file could not be found.\"\n                    )\n\n                with open(in_geojson, encoding=encoding) as f:\n                    data = json.load(f)\n        elif isinstance(in_geojson, dict):\n            data = in_geojson\n        else:\n            raise TypeError(\"The input geojson must be a type of str or dict.\")\n\n        return data[\"features\"][0][\"geometry\"][\"type\"]\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.geometry_bounds","title":"<code>geometry_bounds(geometry, decimals=4)</code>","text":"<p>Returns the bounds of a geometry.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>dict</code> <p>A GeoJSON geometry.</p> required <code>decimals</code> <code>int</code> <p>The number of decimal places to round the bounds to. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of bounds in the form of [minx, miny, maxx, maxy].</p> Source code in <code>beamgis/common.py</code> <pre><code>def geometry_bounds(geometry, decimals=4):\n    \"\"\"Returns the bounds of a geometry.\n\n    Args:\n        geometry (dict): A GeoJSON geometry.\n        decimals (int, optional): The number of decimal places to round the bounds to. Defaults to 4.\n\n    Returns:\n        list: A list of bounds in the form of [minx, miny, maxx, maxy].\n    \"\"\"\n    if isinstance(geometry, dict):\n        if \"geometry\" in geometry:\n            coords = geometry[\"geometry\"][\"coordinates\"][0]\n        else:\n            coords = geometry[\"coordinates\"][0]\n\n    else:\n        raise ValueError(\"geometry must be a GeoJSON-like dictionary.\")\n\n    x = [p[0] for p in coords]\n    y = [p[1] for p in coords]\n    west = round(min(x), decimals)\n    east = round(max(x), decimals)\n    south = round(min(y), decimals)\n    north = round(max(y), decimals)\n    return [west, south, east, north]\n</code></pre>"},{"location":"common/#beamgis.common.get_3dep_dem","title":"<code>get_3dep_dem(geometry, resolution=30, src_crs=None, output=None, dst_crs='EPSG:5070', to_cog=False, overwrite=False, **kwargs)</code>","text":"<p>Get DEM data at any resolution from 3DEP.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>Polygon | MultiPolygon | tuple</code> <p>It can be a polygon or a bounding box of form (xmin, ymin, xmax, ymax).</p> required <code>resolution</code> <code>int</code> <p>arget DEM source resolution in meters. Defaults to 30.</p> <code>30</code> <code>src_crs</code> <code>str</code> <p>The spatial reference system of the input geometry. Defaults to \"EPSG:4326\".</p> <code>None</code> <code>output</code> <code>str</code> <p>The output GeoTIFF file. Defaults to None.</p> <code>None</code> <code>dst_crs</code> <code>str</code> <p>The spatial reference system of the output GeoTIFF file. Defaults to \"EPSG:5070\".</p> <code>'EPSG:5070'</code> <code>to_cog</code> <code>bool</code> <p>Convert to Cloud Optimized GeoTIFF. Defaults to False.</p> <code>False</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the output file if it exists. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>xarray.DataArray</code> <p>DEM at the specified resolution in meters and CRS.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_3dep_dem(\n    geometry,\n    resolution=30,\n    src_crs=None,\n    output=None,\n    dst_crs=\"EPSG:5070\",\n    to_cog=False,\n    overwrite=False,\n    **kwargs,\n):\n    \"\"\"Get DEM data at any resolution from 3DEP.\n\n    Args:\n        geometry (Polygon | MultiPolygon | tuple): It can be a polygon or a bounding\n            box of form (xmin, ymin, xmax, ymax).\n        resolution (int): arget DEM source resolution in meters. Defaults to 30.\n        src_crs (str, optional): The spatial reference system of the input geometry. Defaults to \"EPSG:4326\".\n        output (str, optional): The output GeoTIFF file. Defaults to None.\n        dst_crs (str, optional): The spatial reference system of the output GeoTIFF file. Defaults to \"EPSG:5070\".\n        to_cog (bool, optional): Convert to Cloud Optimized GeoTIFF. Defaults to False.\n        overwrite (bool, optional): Whether to overwrite the output file if it exists. Defaults to False.\n\n    Returns:\n        xarray.DataArray: DEM at the specified resolution in meters and CRS.\n    \"\"\"\n\n    try:\n        import py3dep\n    except ImportError:\n        print(\"py3dep is not installed. Installing py3dep...\")\n        install_package(\"py3dep\")\n        import py3dep\n\n    import geopandas as gpd\n\n    if output is not None and os.path.exists(output) and not overwrite:\n        print(f\"File {output} already exists. Set overwrite=True to overwrite it\")\n        return\n\n    if isinstance(geometry, gpd.GeoDataFrame):\n        if src_crs is None:\n            src_crs = geometry.crs\n        geometry = geometry.geometry.unary_union\n\n    if src_crs is None:\n        src_crs = \"EPSG:4326\"\n\n    dem = py3dep.get_dem(geometry, resolution=resolution, crs=src_crs)\n    dem = dem.rio.reproject(dst_crs)\n\n    if output is not None:\n        if not output.endswith(\".tif\"):\n            output += \".tif\"\n        dem.rio.to_raster(output, **kwargs)\n\n        if to_cog:\n            try:\n                image_to_cog(output, output)\n            except Exception as e:\n                print(e)\n\n    return dem\n</code></pre>"},{"location":"common/#beamgis.common.get_api_key","title":"<code>get_api_key(name=None, key=None)</code>","text":"<p>Retrieves an API key. If a key is provided, it is returned directly. If a name is provided, the function attempts to retrieve the key from user data (if running in Google Colab) or from environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the key to retrieve. Defaults to None.</p> <code>None</code> <code>key</code> <code>Optional[str]</code> <p>The key to return directly. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The retrieved key, or None if no key was found.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_api_key(name: Optional[str] = None, key: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"\n    Retrieves an API key. If a key is provided, it is returned directly. If a\n    name is provided, the function attempts to retrieve the key from user data\n    (if running in Google Colab) or from environment variables.\n\n    Args:\n        name (Optional[str], optional): The name of the key to retrieve. Defaults to None.\n        key (Optional[str], optional): The key to return directly. Defaults to None.\n\n    Returns:\n        Optional[str]: The retrieved key, or None if no key was found.\n    \"\"\"\n    if key is not None:\n        return key\n    if name is not None:\n        try:\n            if _in_colab_shell():\n                from google.colab import userdata  # pylint: disable=E0611\n\n                return userdata.get(name)\n        except Exception:\n            pass\n        return os.environ.get(name)\n    return None\n</code></pre>"},{"location":"common/#beamgis.common.get_bounds","title":"<code>get_bounds(geometry, north_up=True, transform=None)</code>","text":"<p>Bounding box of a GeoJSON geometry, GeometryCollection, or FeatureCollection. left, bottom, right, top not xmin, ymin, xmax, ymax If not north_up, y will be switched to guarantee the above. Source code adapted from https://github.com/mapbox/rasterio/blob/master/rasterio/features.py#L361</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>dict</code> <p>A GeoJSON dict.</p> required <code>north_up</code> <code>bool</code> <p>. Defaults to True.</p> <code>True</code> <code>transform</code> <code>[type]</code> <p>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of coordinates representing [left, bottom, right, top]</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_bounds(geometry, north_up=True, transform=None):\n    \"\"\"Bounding box of a GeoJSON geometry, GeometryCollection, or FeatureCollection.\n    left, bottom, right, top\n    *not* xmin, ymin, xmax, ymax\n    If not north_up, y will be switched to guarantee the above.\n    Source code adapted from https://github.com/mapbox/rasterio/blob/master/rasterio/features.py#L361\n\n    Args:\n        geometry (dict): A GeoJSON dict.\n        north_up (bool, optional): . Defaults to True.\n        transform ([type], optional): . Defaults to None.\n\n    Returns:\n        list: A list of coordinates representing [left, bottom, right, top]\n    \"\"\"\n\n    if \"bbox\" in geometry:\n        return tuple(geometry[\"bbox\"])\n\n    geometry = geometry.get(\"geometry\") or geometry\n\n    # geometry must be a geometry, GeometryCollection, or FeatureCollection\n    if not (\n        \"coordinates\" in geometry or \"geometries\" in geometry or \"features\" in geometry\n    ):\n        raise ValueError(\n            \"geometry must be a GeoJSON-like geometry, GeometryCollection, \"\n            \"or FeatureCollection\"\n        )\n\n    if \"features\" in geometry:\n        # Input is a FeatureCollection\n        xmins = []\n        ymins = []\n        xmaxs = []\n        ymaxs = []\n        for feature in geometry[\"features\"]:\n            xmin, ymin, xmax, ymax = get_bounds(feature[\"geometry\"])\n            xmins.append(xmin)\n            ymins.append(ymin)\n            xmaxs.append(xmax)\n            ymaxs.append(ymax)\n        if north_up:\n            return min(xmins), min(ymins), max(xmaxs), max(ymaxs)\n        else:\n            return min(xmins), max(ymaxs), max(xmaxs), min(ymins)\n\n    elif \"geometries\" in geometry:\n        # Input is a geometry collection\n        xmins = []\n        ymins = []\n        xmaxs = []\n        ymaxs = []\n        for geometry in geometry[\"geometries\"]:\n            xmin, ymin, xmax, ymax = get_bounds(geometry)\n            xmins.append(xmin)\n            ymins.append(ymin)\n            xmaxs.append(xmax)\n            ymaxs.append(ymax)\n        if north_up:\n            return min(xmins), min(ymins), max(xmaxs), max(ymaxs)\n        else:\n            return min(xmins), max(ymaxs), max(xmaxs), min(ymins)\n\n    elif \"coordinates\" in geometry:\n        # Input is a singular geometry object\n        if transform is not None:\n            xyz = list(explode(geometry[\"coordinates\"]))\n            xyz_px = [transform * point for point in xyz]\n            xyz = tuple(zip(*xyz_px))\n            return min(xyz[0]), max(xyz[1]), max(xyz[0]), min(xyz[1])\n        else:\n            xyz = tuple(zip(*list(explode(geometry[\"coordinates\"]))))\n            if north_up:\n                return min(xyz[0]), min(xyz[1]), max(xyz[0]), max(xyz[1])\n            else:\n                return min(xyz[0]), max(xyz[1]), max(xyz[0]), min(xyz[1])\n\n    # all valid inputs returned above, so whatever falls through is an error\n    raise ValueError(\n        \"geometry must be a GeoJSON-like geometry, GeometryCollection, \"\n        \"or FeatureCollection\"\n    )\n</code></pre>"},{"location":"common/#beamgis.common.get_census_dict","title":"<code>get_census_dict(reset=False)</code>","text":"<p>Returns a dictionary of Census data.</p> <p>Parameters:</p> Name Type Description Default <code>reset</code> <code>bool</code> <p>Reset the dictionary. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of Census data.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_census_dict(reset=False):\n    \"\"\"Returns a dictionary of Census data.\n\n    Args:\n        reset (bool, optional): Reset the dictionary. Defaults to False.\n\n    Returns:\n        dict: A dictionary of Census data.\n    \"\"\"\n    import json\n    import importlib.resources\n\n    pkg_dir = os.path.dirname(importlib.resources.files(\"leafmap\") / \"leafmap.py\")\n    census_data = os.path.join(pkg_dir, \"data/census_data.json\")\n\n    if reset:\n        try:\n            from owslib.wms import WebMapService\n        except ImportError:\n            raise ImportError(\"Please install owslib using 'pip install owslib'.\")\n\n        census_dict = {}\n\n        names = [\n            \"Current\",\n            \"ACS 2021\",\n            \"ACS 2019\",\n            \"ACS 2018\",\n            \"ACS 2017\",\n            \"ACS 2016\",\n            \"ACS 2015\",\n            \"ACS 2014\",\n            \"ACS 2013\",\n            \"ACS 2012\",\n            \"ECON 2012\",\n            \"Census 2020\",\n            \"Census 2010\",\n            \"Physical Features\",\n            \"Decennial Census 2020\",\n            \"Decennial Census 2010\",\n            \"Decennial Census 2000\",\n            \"Decennial Physical Features\",\n        ]\n\n        links = {}\n\n        print(\"Retrieving data. Please wait ...\")\n        for name in names:\n            if \"Decennial\" not in name:\n                links[name] = (\n                    f\"https://tigerweb.geo.census.gov/arcgis/services/TIGERweb/tigerWMS_{name.replace(' ', '')}/MapServer/WMSServer\"\n                )\n            else:\n                links[name] = (\n                    f\"https://tigerweb.geo.census.gov/arcgis/services/Census2020/tigerWMS_{name.replace('Decennial', '').replace(' ', '')}/MapServer/WMSServer\"\n                )\n\n            wms = WebMapService(links[name], timeout=300)\n            layers = list(wms.contents)\n            layers.sort()\n            census_dict[name] = {\n                \"url\": links[name],\n                \"layers\": layers,\n                # \"title\": wms.identification.title,\n                # \"abstract\": wms.identification.abstract,\n            }\n\n        with open(census_data, \"w\") as f:\n            json.dump(census_dict, f, indent=4)\n\n    else:\n        with open(census_data, \"r\") as f:\n            census_dict = json.load(f)\n\n    return census_dict\n</code></pre>"},{"location":"common/#beamgis.common.get_center","title":"<code>get_center(geometry, north_up=True, transform=None)</code>","text":"<p>Get the centroid of a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>dict</code> <p>A GeoJSON dict.</p> required <code>north_up</code> <code>bool</code> <p>. Defaults to True.</p> <code>True</code> <code>transform</code> <code>[type]</code> <p>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>[lon, lat]</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_center(geometry, north_up=True, transform=None):\n    \"\"\"Get the centroid of a GeoJSON.\n\n    Args:\n        geometry (dict): A GeoJSON dict.\n        north_up (bool, optional): . Defaults to True.\n        transform ([type], optional): . Defaults to None.\n\n    Returns:\n        list: [lon, lat]\n    \"\"\"\n    bounds = get_bounds(geometry, north_up, transform)\n    center = ((bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2)  # (lat, lon)\n    return center\n</code></pre>"},{"location":"common/#beamgis.common.get_direct_url","title":"<code>get_direct_url(url)</code>","text":"<p>Get the direct URL for a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to get the direct URL for.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The direct URL.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_direct_url(url):\n    \"\"\"Get the direct URL for a given URL.\n\n    Args:\n        url (str): The URL to get the direct URL for.\n\n    Returns:\n        str: The direct URL.\n    \"\"\"\n\n    if not isinstance(url, str):\n        raise ValueError(\"url must be a string.\")\n\n    if not url.startswith(\"http\"):\n        raise ValueError(\"url must start with http.\")\n\n    r = requests.head(url, allow_redirects=True)\n    return r.url\n</code></pre>"},{"location":"common/#beamgis.common.get_gdal_drivers","title":"<code>get_gdal_drivers()</code>","text":"<p>Get a list of available driver names in the GDAL library.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of available driver names.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_gdal_drivers() -&gt; List[str]:\n    \"\"\"Get a list of available driver names in the GDAL library.\n\n    Returns:\n        List[str]: A list of available driver names.\n    \"\"\"\n    from osgeo import ogr\n\n    driver_list = []\n\n    # Iterate over all registered drivers\n    for i in range(ogr.GetDriverCount()):\n        driver = ogr.GetDriver(i)\n        driver_name = driver.GetName()\n        driver_list.append(driver_name)\n\n    return driver_list\n</code></pre>"},{"location":"common/#beamgis.common.get_gdal_file_extension","title":"<code>get_gdal_file_extension(driver_name)</code>","text":"<p>Get the file extension corresponding to a driver name in the GDAL library.</p> <p>Parameters:</p> Name Type Description Default <code>driver_name</code> <code>str</code> <p>The name of the driver.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The file extension corresponding to the driver name, or None if the driver is not found or does not have a specific file extension.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_gdal_file_extension(driver_name: str) -&gt; Optional[str]:\n    \"\"\"Get the file extension corresponding to a driver name in the GDAL library.\n\n    Args:\n        driver_name (str): The name of the driver.\n\n    Returns:\n        Optional[str]: The file extension corresponding to the driver name, or None if the driver is not found or does not have a specific file extension.\n    \"\"\"\n    from osgeo import ogr\n\n    driver = ogr.GetDriverByName(driver_name)\n    if driver is None:\n        drivers = get_gdal_drivers()\n        raise ValueError(\n            f\"Driver {driver_name} not found. Available drivers: {drivers}\"\n        )\n\n    metadata = driver.GetMetadata()\n    if \"DMD_EXTENSION\" in metadata:\n        file_extension = driver.GetMetadataItem(\"DMD_EXTENSION\")\n    else:\n        file_extensions = driver.GetMetadataItem(\"DMD_EXTENSIONS\")\n        if file_extensions == \"json geojson\":\n            file_extension = \"geojson\"\n        else:\n            file_extension = file_extensions.split()[0].lower()\n\n    return file_extension\n</code></pre>"},{"location":"common/#beamgis.common.get_geometry_coords","title":"<code>get_geometry_coords(row, geom, coord_type, shape_type, mercator=False)</code>","text":"<p>Returns the coordinates ('x' or 'y') of edges of a Polygon exterior.</p> <p>:param: (GeoPandas Series) row : The row of each of the GeoPandas DataFrame. :param: (str) geom : The column name. :param: (str) coord_type : Whether it's 'x' or 'y' coordinate. :param: (str) shape_type</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_geometry_coords(row, geom, coord_type, shape_type, mercator=False):\n    \"\"\"\n    Returns the coordinates ('x' or 'y') of edges of a Polygon exterior.\n\n    :param: (GeoPandas Series) row : The row of each of the GeoPandas DataFrame.\n    :param: (str) geom : The column name.\n    :param: (str) coord_type : Whether it's 'x' or 'y' coordinate.\n    :param: (str) shape_type\n    \"\"\"\n\n    # Parse the exterior of the coordinate\n    if shape_type.lower() in [\"polygon\", \"multipolygon\"]:\n        exterior = row[geom].geoms[0].exterior\n        if coord_type == \"x\":\n            # Get the x coordinates of the exterior\n            coords = list(exterior.coords.xy[0])\n            if mercator:\n                coords = [lnglat_to_meters(x, 0)[0] for x in coords]\n            return coords\n\n        elif coord_type == \"y\":\n            # Get the y coordinates of the exterior\n            coords = list(exterior.coords.xy[1])\n            if mercator:\n                coords = [lnglat_to_meters(0, y)[1] for y in coords]\n            return coords\n\n    elif shape_type.lower() in [\"linestring\", \"multilinestring\"]:\n        if coord_type == \"x\":\n            coords = list(row[geom].coords.xy[0])\n            if mercator:\n                coords = [lnglat_to_meters(x, 0)[0] for x in coords]\n            return coords\n        elif coord_type == \"y\":\n            coords = list(row[geom].coords.xy[1])\n            if mercator:\n                coords = [lnglat_to_meters(0, y)[1] for y in coords]\n            return coords\n\n    elif shape_type.lower() in [\"point\", \"multipoint\"]:\n        exterior = row[geom]\n\n        if coord_type == \"x\":\n            # Get the x coordinates of the exterior\n            coords = exterior.coords.xy[0][0]\n            if mercator:\n                coords = lnglat_to_meters(coords, 0)[0]\n            return coords\n\n        elif coord_type == \"y\":\n            # Get the y coordinates of the exterior\n            coords = exterior.coords.xy[1][0]\n            if mercator:\n                coords = lnglat_to_meters(0, coords)[1]\n            return coords\n</code></pre>"},{"location":"common/#beamgis.common.get_geometry_type","title":"<code>get_geometry_type(in_geojson)</code>","text":"<p>Get the geometry type of a GeoJSON file.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The path to the GeoJSON file or a GeoJSON dictionary.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The geometry type. Can be one of \"Point\", \"LineString\", \"Polygon\", \"MultiPoint\",     \"MultiLineString\", \"MultiPolygon\", \"GeometryCollection\", or \"Unknown\".</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_geometry_type(in_geojson: Union[str, Dict]) -&gt; str:\n    \"\"\"Get the geometry type of a GeoJSON file.\n\n    Args:\n        in_geojson (str | dict): The path to the GeoJSON file or a GeoJSON dictionary.\n\n    Returns:\n        str: The geometry type. Can be one of \"Point\", \"LineString\", \"Polygon\", \"MultiPoint\",\n            \"MultiLineString\", \"MultiPolygon\", \"GeometryCollection\", or \"Unknown\".\n    \"\"\"\n\n    import geojson\n\n    try:\n        if isinstance(in_geojson, str):  # If input is a file path\n            with open(in_geojson, \"r\") as geojson_file:\n                geojson_data = geojson.load(geojson_file)\n        elif isinstance(in_geojson, dict):  # If input is a GeoJSON dictionary\n            geojson_data = in_geojson\n        else:\n            return \"Invalid input type. Expected file path or dictionary.\"\n\n        if \"type\" in geojson_data:\n            if geojson_data[\"type\"] == \"FeatureCollection\":\n                features = geojson_data.get(\"features\", [])\n                if features:\n                    first_feature = features[0]\n                    geometry = first_feature.get(\"geometry\")\n                    if geometry and \"type\" in geometry:\n                        return geometry[\"type\"]\n                    else:\n                        return \"No geometry type found in the first feature.\"\n                else:\n                    return \"No features found in the FeatureCollection.\"\n            elif geojson_data[\"type\"] == \"Feature\":\n                geometry = geojson_data.get(\"geometry\")\n                if geometry and \"type\" in geometry:\n                    return geometry[\"type\"]\n                else:\n                    return \"No geometry type found in the Feature.\"\n            else:\n                return \"Unsupported GeoJSON type.\"\n        else:\n            return \"No 'type' field found in the GeoJSON data.\"\n    except Exception as e:\n        raise e\n</code></pre>"},{"location":"common/#beamgis.common.get_google_map","title":"<code>get_google_map(map_type='HYBRID', show=True, api_key=None, backend='ipyleaflet', **kwargs)</code>","text":"<p>Gets Google basemap tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>map_type</code> <code>str</code> <p>Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\". Defaults to 'HYBRID'.</p> <code>'HYBRID'</code> <code>show</code> <code>bool</code> <p>Whether to add the layer to the map. Defaults to True.</p> <code>True</code> <code>api_key</code> <code>str</code> <p>The Google Maps API key. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to ipyleaflet.TileLayer().</p> <code>{}</code> Source code in <code>beamgis/common.py</code> <pre><code>def get_google_map(\n    map_type=\"HYBRID\", show=True, api_key=None, backend=\"ipyleaflet\", **kwargs\n):\n    \"\"\"Gets Google basemap tile layer.\n\n    Args:\n        map_type (str, optional): Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\". Defaults to 'HYBRID'.\n        show (bool, optional): Whether to add the layer to the map. Defaults to True.\n        api_key (str, optional): The Google Maps API key. Defaults to None.\n        **kwargs: Additional arguments to pass to ipyleaflet.TileLayer().\n    \"\"\"\n\n    allow_types = [\"ROADMAP\", \"SATELLITE\", \"HYBRID\", \"TERRAIN\"]\n    if map_type not in allow_types:\n        print(\"map_type must be one of the following: {}\".format(allow_types))\n        return\n\n    if api_key is None:\n        api_key = os.environ.get(\"GOOGLE_MAPS_API_KEY\", \"YOUR-API-KEY\")\n\n    if api_key == \"\":\n        MAP_TILES = {\n            \"ROADMAP\": {\n                \"url\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}\",\n                \"attribution\": \"Esri\",\n                \"name\": \"Esri.WorldStreetMap\",\n            },\n            \"SATELLITE\": {\n                \"url\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n                \"attribution\": \"Esri\",\n                \"name\": \"Esri.WorldImagery\",\n            },\n            \"TERRAIN\": {\n                \"url\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}\",\n                \"attribution\": \"Esri\",\n                \"name\": \"Esri.WorldTopoMap\",\n            },\n            \"HYBRID\": {\n                \"url\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n                \"attribution\": \"Esri\",\n                \"name\": \"Esri.WorldImagery\",\n            },\n        }\n\n        print(\n            \"Google Maps API key is required to use Google Maps. You can generate one from https://bit.ly/3sw0THG and use geemap.set_api_key(), defaulting to Esri basemaps.\"\n        )\n\n    else:\n        MAP_TILES = {\n            \"ROADMAP\": {\n                \"url\": f\"https://mt1.google.com/vt/lyrs=m&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}&amp;key={api_key}\",\n                \"attribution\": \"Google\",\n                \"name\": \"Google Maps\",\n            },\n            \"SATELLITE\": {\n                \"url\": f\"https://mt1.google.com/vt/lyrs=s&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}&amp;key={api_key}\",\n                \"attribution\": \"Google\",\n                \"name\": \"Google Satellite\",\n            },\n            \"TERRAIN\": {\n                \"url\": f\"https://mt1.google.com/vt/lyrs=p&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}&amp;key={api_key}\",\n                \"attribution\": \"Google\",\n                \"name\": \"Google Terrain\",\n            },\n            \"HYBRID\": {\n                \"url\": f\"https://mt1.google.com/vt/lyrs=y&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}&amp;key={api_key}\",\n                \"attribution\": \"Google\",\n                \"name\": \"Google Hybrid\",\n            },\n        }\n\n    if \"max_zoom\" not in kwargs:\n        kwargs[\"max_zoom\"] = 24\n\n    if backend == \"ipyleaflet\":\n        import ipyleaflet\n\n        layer = ipyleaflet.TileLayer(\n            url=MAP_TILES[map_type][\"url\"],\n            name=MAP_TILES[map_type][\"name\"],\n            attribution=MAP_TILES[map_type][\"attribution\"],\n            visible=show,\n            **kwargs,\n        )\n    elif backend == \"folium\":\n        import folium\n\n        layer = folium.TileLayer(\n            tiles=MAP_TILES[map_type][\"url\"],\n            name=MAP_TILES[map_type][\"name\"],\n            attr=MAP_TILES[map_type][\"attribution\"],\n            overlay=True,\n            control=True,\n            show=show,\n            **kwargs,\n        )\n    else:\n        raise ValueError(\"backend must be either 'ipyleaflet' or 'folium'\")\n\n    return layer\n</code></pre>"},{"location":"common/#beamgis.common.get_image_colormap","title":"<code>get_image_colormap(image, index=1)</code>","text":"<p>Retrieve the colormap from an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str, rasterio.io.DatasetReader, rioxarray.DataArray</code> <p>The input image. It can be: - A file path to a raster image (string). - A rasterio dataset. - A rioxarray DataArray.</p> required <code>index</code> <code>int</code> <p>The band index to retrieve the colormap from (default is 1).</p> <code>1</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representing the colormap (value: (R, G, B, A)), or None if no colormap is found.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the input image type is unsupported.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_image_colormap(image, index=1):\n    \"\"\"\n    Retrieve the colormap from an image.\n\n    Args:\n        image (str, rasterio.io.DatasetReader, rioxarray.DataArray):\n            The input image. It can be:\n            - A file path to a raster image (string).\n            - A rasterio dataset.\n            - A rioxarray DataArray.\n        index (int): The band index to retrieve the colormap from (default is 1).\n\n    Returns:\n        dict: A dictionary representing the colormap (value: (R, G, B, A)), or None if no colormap is found.\n\n    Raises:\n        ValueError: If the input image type is unsupported.\n    \"\"\"\n    import rasterio\n    import rioxarray\n    import xarray as xr\n\n    dataset = None\n\n    if isinstance(image, str):  # File path\n        with rasterio.open(image) as ds:\n            return ds.colormap(index) if ds.count &gt; 0 else None\n    elif isinstance(image, rasterio.io.DatasetReader):  # rasterio dataset\n        dataset = image\n    elif isinstance(image, xr.DataArray) or isinstance(image, xr.Dataset):\n        source = image.encoding.get(\"source\")\n        if source:\n            with rasterio.open(source) as ds:\n                return ds.colormap(index) if ds.count &gt; 0 else None\n        else:\n            raise ValueError(\n                \"Cannot extract colormap: DataArray does not have a source.\"\n            )\n    else:\n        raise ValueError(\n            \"Unsupported input type. Provide a file path, rasterio dataset, or rioxarray DataArray.\"\n        )\n\n    if dataset:\n        return dataset.colormap(index) if dataset.count &gt; 0 else None\n</code></pre>"},{"location":"common/#beamgis.common.get_local_tile_layer","title":"<code>get_local_tile_layer(source, port='default', debug=False, indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, attribution=None, tile_format='ipyleaflet', layer_name='Local COG', client_args={'cors_all': False}, return_client=False, quiet=False, **kwargs)</code>","text":"<p>Generate an ipyleaflet/folium TileLayer from a local raster dataset or remote Cloud Optimized GeoTIFF (COG).     If you are using this function in JupyterHub on a remote server and the raster does not render properly, try     running the following two lines before calling this function:</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.</p> required <code>port</code> <code>str</code> <p>The port to use for the server. Defaults to \"default\".</p> <code>'default'</code> <code>debug</code> <code>bool</code> <p>If True, the server will be started in debug mode. Defaults to False.</p> <code>False</code> <code>indexes</code> <code>int</code> <p>The band(s) to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>tile_format</code> <code>str</code> <p>The tile layer format. Can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>'Local COG'</code> <code>client_args</code> <code>dict</code> <p>Additional arguments to pass to the TileClient. Defaults to {}.</p> <code>{'cors_all': False}</code> <code>return_client</code> <code>bool</code> <p>If True, the tile client will be returned. Defaults to False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>If True, the error messages will be suppressed. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ipyleaflet.TileLayer | folium.TileLayer</code> <p>An ipyleaflet.TileLayer or folium.TileLayer.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_local_tile_layer(\n    source,\n    port=\"default\",\n    debug=False,\n    indexes=None,\n    colormap=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    tile_format=\"ipyleaflet\",\n    layer_name=\"Local COG\",\n    client_args={\"cors_all\": False},\n    return_client=False,\n    quiet=False,\n    **kwargs,\n):\n    \"\"\"Generate an ipyleaflet/folium TileLayer from a local raster dataset or remote Cloud Optimized GeoTIFF (COG).\n        If you are using this function in JupyterHub on a remote server and the raster does not render properly, try\n        running the following two lines before calling this function:\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n    Args:\n        source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n        port (str, optional): The port to use for the server. Defaults to \"default\".\n        debug (bool, optional): If True, the server will be started in debug mode. Defaults to False.\n        indexes (int, optional): The band(s) to use. Band indexing starts at 1. Defaults to None.\n        colormap (str, optional): The name of the colormap from `matplotlib` to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.\n        vmin (float, optional): The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        tile_format (str, optional): The tile layer format. Can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n        layer_name (str, optional): The layer name to use. Defaults to None.\n        client_args (dict, optional): Additional arguments to pass to the TileClient. Defaults to {}.\n        return_client (bool, optional): If True, the tile client will be returned. Defaults to False.\n        quiet (bool, optional): If True, the error messages will be suppressed. Defaults to False.\n\n    Returns:\n        ipyleaflet.TileLayer | folium.TileLayer: An ipyleaflet.TileLayer or folium.TileLayer.\n    \"\"\"\n    import rasterio\n\n    check_package(\n        \"localtileserver\", URL=\"https://github.com/banesullivan/localtileserver\"\n    )\n\n    # Handle legacy localtileserver kwargs\n    if \"cmap\" in kwargs:\n        warnings.warn(\n            \"`cmap` is a deprecated keyword argument for get_local_tile_layer. Please use `colormap`.\"\n        )\n    if \"palette\" in kwargs:\n        warnings.warn(\n            \"`palette` is a deprecated keyword argument for get_local_tile_layer. Please use `colormap`.\"\n        )\n    if \"band\" in kwargs or \"bands\" in kwargs:\n        warnings.warn(\n            \"`band` and `bands` are deprecated keyword arguments for get_local_tile_layer. Please use `indexes`.\"\n        )\n    if \"projection\" in kwargs:\n        warnings.warn(\n            \"`projection` is a deprecated keyword argument for get_local_tile_layer and will be ignored.\"\n        )\n    if \"style\" in kwargs:\n        warnings.warn(\n            \"`style` is a deprecated keyword argument for get_local_tile_layer and will be ignored.\"\n        )\n\n    if \"max_zoom\" not in kwargs:\n        kwargs[\"max_zoom\"] = 30\n    if \"max_native_zoom\" not in kwargs:\n        kwargs[\"max_native_zoom\"] = 30\n    if \"cmap\" in kwargs:\n        colormap = kwargs.pop(\"cmap\")\n    if \"palette\" in kwargs:\n        colormap = kwargs.pop(\"palette\")\n    if \"band\" in kwargs:\n        indexes = kwargs.pop(\"band\")\n    if \"bands\" in kwargs:\n        indexes = kwargs.pop(\"bands\")\n\n    # Make it compatible with binder and JupyterHub\n    if os.environ.get(\"JUPYTERHUB_SERVICE_PREFIX\") is not None:\n        os.environ[\"LOCALTILESERVER_CLIENT_PREFIX\"] = (\n            f\"{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}\"\n        )\n\n    if is_studio_lab():\n        os.environ[\"LOCALTILESERVER_CLIENT_PREFIX\"] = (\n            f\"studiolab/default/jupyter/proxy/{{port}}\"\n        )\n    elif is_on_aws():\n        os.environ[\"LOCALTILESERVER_CLIENT_PREFIX\"] = \"proxy/{port}\"\n    elif \"prefix\" in kwargs:\n        os.environ[\"LOCALTILESERVER_CLIENT_PREFIX\"] = kwargs[\"prefix\"]\n        kwargs.pop(\"prefix\")\n\n    from localtileserver import (\n        get_leaflet_tile_layer,\n        get_folium_tile_layer,\n        TileClient,\n    )\n\n    # if \"show_loading\" not in kwargs:\n    #     kwargs[\"show_loading\"] = False\n\n    if isinstance(source, str):\n        if not source.startswith(\"http\"):\n            if source.startswith(\"~\"):\n                source = os.path.expanduser(source)\n            # else:\n            #     source = os.path.abspath(source)\n            # if not os.path.exists(source):\n            #     raise ValueError(\"The source path does not exist.\")\n        else:\n            source = github_raw_url(source)\n    elif isinstance(source, TileClient) or isinstance(\n        source, rasterio.io.DatasetReader\n    ):\n        pass\n\n    else:\n        raise ValueError(\"The source must either be a string or TileClient\")\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    if layer_name is None:\n        if source.startswith(\"http\"):\n            layer_name = \"RemoteTile_\" + random_string(3)\n        else:\n            layer_name = \"LocalTile_\" + random_string(3)\n\n    if nodata is None:\n        nodata = get_api_key(\"NODATA\")\n        if isinstance(nodata, str):\n            nodata = float(nodata)\n\n    if isinstance(colormap, str):\n        colormap = colormap.lower()\n\n    if quiet:\n        output = widgets.Output()\n        with output:\n            if tile_format == \"ipyleaflet\":\n                tile_layer = get_leaflet_tile_layer(\n                    source,\n                    port=port,\n                    debug=debug,\n                    indexes=indexes,\n                    colormap=colormap,\n                    vmin=vmin,\n                    vmax=vmax,\n                    nodata=nodata,\n                    attribution=attribution,\n                    name=layer_name,\n                    **kwargs,\n                )\n            else:\n                tile_layer = get_folium_tile_layer(\n                    source,\n                    port=port,\n                    debug=debug,\n                    indexes=indexes,\n                    colormap=colormap,\n                    vmin=vmin,\n                    vmax=vmax,\n                    nodata=nodata,\n                    attr=attribution,\n                    overlay=True,\n                    name=layer_name,\n                    **kwargs,\n                )\n    else:\n        if tile_format == \"ipyleaflet\":\n            tile_layer = get_leaflet_tile_layer(\n                source,\n                port=port,\n                debug=debug,\n                indexes=indexes,\n                colormap=colormap,\n                vmin=vmin,\n                vmax=vmax,\n                nodata=nodata,\n                attribution=attribution,\n                name=layer_name,\n                **kwargs,\n            )\n        else:\n            tile_layer = get_folium_tile_layer(\n                source,\n                port=port,\n                debug=debug,\n                indexes=indexes,\n                colormap=colormap,\n                vmin=vmin,\n                vmax=vmax,\n                nodata=nodata,\n                attr=attribution,\n                overlay=True,\n                name=layer_name,\n                **kwargs,\n            )\n\n    if return_client:\n        return tile_layer, tile_layer.tile_server\n    else:\n        return tile_layer\n</code></pre>"},{"location":"common/#beamgis.common.get_mapillary_image_url","title":"<code>get_mapillary_image_url(image_id, resolution='original', access_token=None, **kwargs)</code>","text":"<p>Retrieves the URL of a Mapillary image.</p> <p>Parameters:</p> Name Type Description Default <code>image_id</code> <code>str</code> <p>The ID of the Mapillary image.</p> required <code>resolution</code> <code>str</code> <p>The resolution of the image. Can be 256, 1024, 2048, or original. Defaults to \"original\".</p> <code>'original'</code> <code>access_token</code> <code>str</code> <p>The access token for the Mapillary API. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the request.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If no access token is provided.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The URL of the Mapillary image, or None if an error occurs.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_mapillary_image_url(\n    image_id: str,\n    resolution: str = \"original\",\n    access_token: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Optional[str]:\n    \"\"\"\n    Retrieves the URL of a Mapillary image.\n\n    Args:\n        image_id (str): The ID of the Mapillary image.\n        resolution (str): The resolution of the image. Can be 256, 1024, 2048, or original.\n            Defaults to \"original\".\n        access_token (str, optional): The access token for the Mapillary API. Defaults to None.\n        **kwargs: Additional keyword arguments for the request.\n\n    Raises:\n        ValueError: If no access token is provided.\n\n    Returns:\n        Optional[str]: The URL of the Mapillary image, or None if an error occurs.\n    \"\"\"\n    if access_token is None:\n        access_token = get_api_key(\"MAPILLARY_API_KEY\")\n\n    if access_token is None:\n        raise ValueError(\n            \"Mapillary API access token is required. Set it using the 'access_token' parameter.\"\n        )\n\n        # API URL\n    url = f\"https://graph.mapillary.com/{image_id}\"\n\n    # Fields to retrieve\n    fields = f\"thumb_{resolution}_url\"\n\n    # Request parameters\n    params = {\"fields\": fields, \"access_token\": access_token}\n\n    # Fetch the data\n    response = requests.get(url, params=params, **kwargs)\n\n    # Check the response\n    if response.status_code == 200:\n        data = response.json()\n        image_url = data.get(fields)\n        return image_url\n    else:\n        print(f\"Error {response.status_code}: {response.text}\")\n        return None\n</code></pre>"},{"location":"common/#beamgis.common.get_mapillary_image_widget","title":"<code>get_mapillary_image_widget(image_id, style='photo', width=800, height=600, frame_border=0, **kwargs)</code>","text":"<p>Creates an iframe widget to display a Mapillary image.</p> <p>Parameters:</p> Name Type Description Default <code>image_id</code> <code>str</code> <p>The ID of the Mapillary image.</p> required <code>style</code> <code>str</code> <p>The style of the image. Can be \"photo\", \"classic\", \"split\". Defaults to \"photo\".</p> <code>'photo'</code> <code>width</code> <code>int</code> <p>The width of the iframe. Defaults to 800.</p> <code>800</code> <code>height</code> <code>int</code> <p>The height of the iframe. Defaults to 600.</p> <code>600</code> <code>frame_border</code> <code>int</code> <p>The frame border of the iframe. Defaults to 0.</p> <code>0</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the widget.</p> <code>{}</code> <p>Returns:</p> Type Description <code>widgets.HTML</code> <p>An iframe widget displaying the Mapillary image.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_mapillary_image_widget(\n    image_id: str,\n    style: str = \"photo\",\n    width: int = 800,\n    height: int = 600,\n    frame_border: int = 0,\n    **kwargs: Any,\n) -&gt; widgets.HTML:\n    \"\"\"\n    Creates an iframe widget to display a Mapillary image.\n\n    Args:\n        image_id (str): The ID of the Mapillary image.\n        style (str): The style of the image. Can be \"photo\", \"classic\", \"split\". Defaults to \"photo\".\n        width (int): The width of the iframe. Defaults to 800.\n        height (int): The height of the iframe. Defaults to 600.\n        frame_border (int): The frame border of the iframe. Defaults to 0.\n        **kwargs: Additional keyword arguments for the widget.\n\n    Returns:\n        widgets.HTML: An iframe widget displaying the Mapillary image.\n    \"\"\"\n\n    content = f\"\"\"\n    &lt;iframe\n        src=\"https://www.mapillary.com/embed?image_key={image_id}&amp;style={style}\"\n        height=\"{height}\"\n        width=\"{width}\"\n        frameborder=\"{frame_border}\"&gt;\n    &lt;/iframe&gt;\n    \"\"\"\n\n    # Create an iframe widget\n    iframe = widgets.HTML(value=content, placeholder=\"Mapillary Image\", **kwargs)\n\n    return iframe\n</code></pre>"},{"location":"common/#beamgis.common.get_max_pixel_coords","title":"<code>get_max_pixel_coords(geotiff_path, band_idx=1, roi=None, dst_crs='EPSG:4326', output=None, return_gdf=True, **kwargs)</code>","text":"<p>Find the geographic coordinates of the maximum pixel value in a GeoTIFF.</p> <p>Parameters:</p> Name Type Description Default <code>geotiff_path</code> <code>str</code> <p>Path to the GeoTIFF file.</p> required <code>band_idx</code> <code>int</code> <p>Band index to use (default is 1).</p> <code>1</code> <code>roi</code> <code>str</code> <p>Path to a vector dataset containing the region of interest (default is None).</p> <code>None</code> <code>dst_crs</code> <code>str</code> <p>Desired output coordinate system in EPSG format (e.g., \"EPSG:4326\").</p> <code>'EPSG:4326'</code> <code>output</code> <code>str</code> <p>Path to save the output GeoDataFrame (default is None).</p> <code>None</code> <code>return_gdf</code> <code>bool</code> <p>Whether to return a GeoDataFrame (default is True).</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>Maximum pixel value and its geographic coordinates in the specified CRS.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_max_pixel_coords(\n    geotiff_path,\n    band_idx=1,\n    roi=None,\n    dst_crs=\"EPSG:4326\",\n    output=None,\n    return_gdf=True,\n    **kwargs,\n):\n    \"\"\"\n    Find the geographic coordinates of the maximum pixel value in a GeoTIFF.\n\n    Args:\n        geotiff_path (str): Path to the GeoTIFF file.\n        band_idx (int): Band index to use (default is 1).\n        roi (str): Path to a vector dataset containing the region of interest (default is None).\n        dst_crs (str): Desired output coordinate system in EPSG format (e.g., \"EPSG:4326\").\n        output (str): Path to save the output GeoDataFrame (default is None).\n        return_gdf (bool): Whether to return a GeoDataFrame (default is True).\n\n    Returns:\n        dict: Maximum pixel value and its geographic coordinates in the specified CRS.\n    \"\"\"\n    import rasterio\n    import numpy as np\n    import geopandas as gpd\n    from rasterio.warp import transform\n    from rasterio.mask import mask\n    from rasterio.warp import transform, transform_geom\n\n    with rasterio.open(geotiff_path) as dataset:\n        # If ROI is provided, handle potential CRS differences\n        if roi:\n            if isinstance(roi, str):\n                gdf = gpd.read_file(roi)\n            elif isinstance(roi, gpd.GeoDataFrame):\n                gdf = roi\n            elif isinstance(roi, dict):\n                gdf = gpd.GeoDataFrame.from_features([roi])\n            else:\n                raise ValueError(\n                    \"Invalid ROI input. Must be a file path or a GeoDataFrame.\"\n                )\n            roi_geojson = gdf.__geo_interface__\n\n            # Reproject ROI to match the raster's CRS if necessary\n            roi_crs = gdf.crs\n            if roi_crs is None:\n                roi_crs = \"EPSG:4326\"\n            if roi_crs != dataset.crs.to_string():\n                roi_geojson[\"features\"][0][\"geometry\"] = transform_geom(\n                    roi_crs,\n                    dataset.crs.to_string(),\n                    roi_geojson[\"features\"][0][\"geometry\"],\n                )\n\n            # Mask the raster using the transformed ROI geometry\n            clipped_band, clipped_transform = mask(\n                dataset, [roi_geojson[\"features\"][0][\"geometry\"]], crop=True\n            )\n            band = clipped_band[\n                band_idx - 1\n            ]  # Mask returns a 3D array (bands, rows, cols), so select the first band\n            transform_to_use = clipped_transform\n        else:\n            # Use the entire raster\n            band = dataset.read(band_idx)\n            transform_to_use = dataset.transform\n\n        # Find the maximum value and its index\n        max_value = band.max()\n        max_index = np.unravel_index(band.argmax(), band.shape)\n\n        # Convert pixel coordinates to the raster's CRS coordinates\n        original_coords = transform_to_use * (max_index[1], max_index[0])\n\n        # Transform coordinates to the desired CRS\n        src_crs = dataset.crs\n        x, y = transform(src_crs, dst_crs, [original_coords[0]], [original_coords[1]])\n\n        if return_gdf:\n            x_coords = [x[0]]\n            y_coords = [y[0]]\n            # Create a DataFrame\n            df = pd.DataFrame({\"x\": x_coords, \"y\": y_coords})\n\n            # Convert the DataFrame to a GeoDataFrame\n            gdf = gpd.GeoDataFrame(\n                df, geometry=gpd.points_from_xy(df.x, df.y), crs=dst_crs\n            )\n\n            if output:\n                gdf.to_file(output, **kwargs)\n\n        else:\n            return {\"max_value\": max_value, \"coordinates\": (x[0], y[0]), \"crs\": dst_crs}\n</code></pre>"},{"location":"common/#beamgis.common.get_nhd","title":"<code>get_nhd(geometry, geo_crs=4326, xy=True, buffer=0.001, dataset='wbd08', predicate='intersects', sort_attr=None, **kwargs)</code>","text":"<p>Fetches National Hydrography Dataset (NHD) data based on the provided geometry.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>Union[gpd.GeoDataFrame, str, List[float], Tuple[float, float, float, float]]</code> <p>The geometry to query the NHD data. It can be a GeoDataFrame, a file path, or coordinates.</p> required <code>geo_crs</code> <code>int</code> <p>The coordinate reference system (CRS) of the geometry (default is 4326).</p> <code>4326</code> <code>xy</code> <code>bool</code> <p>Whether to use x, y coordinates (default is True).</p> <code>True</code> <code>buffer</code> <code>float</code> <p>The buffer distance around the centroid point (default is 0.001 degrees).</p> <code>0.001</code> <code>dataset</code> <code>str</code> <p>The NHD dataset to query (default is \"wbd08\").</p> <code>'wbd08'</code> <code>predicate</code> <code>str</code> <p>The spatial predicate to use for the query (default is \"intersects\").</p> <code>'intersects'</code> <code>sort_attr</code> <code>Optional[str]</code> <p>The attribute to sort the results by (default is None).</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the WaterData.bygeom method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[gpd.GeoDataFrame]</code> <p>The fetched NHD data as a GeoDataFrame, or None if an error occurs.</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the pynhd package is not installed.</p> <code>ValueError</code> <p>If the geometry type is unsupported.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_nhd(\n    geometry: Union[\n        \"gpd.GeoDataFrame\", str, List[float], Tuple[float, float, float, float]\n    ],\n    geo_crs: int = 4326,\n    xy: bool = True,\n    buffer: float = 0.001,\n    dataset: str = \"wbd08\",\n    predicate: str = \"intersects\",\n    sort_attr: Optional[str] = None,\n    **kwargs,\n) -&gt; Optional[\"gpd.GeoDataFrame\"]:\n    \"\"\"\n    Fetches National Hydrography Dataset (NHD) data based on the provided geometry.\n\n    Args:\n        geometry (Union[gpd.GeoDataFrame, str, List[float], Tuple[float, float, float, float]]):\n            The geometry to query the NHD data. It can be a GeoDataFrame, a file path, or coordinates.\n        geo_crs (int): The coordinate reference system (CRS) of the geometry (default is 4326).\n        xy (bool): Whether to use x, y coordinates (default is True).\n        buffer (float): The buffer distance around the centroid point (default is 0.001 degrees).\n        dataset (str): The NHD dataset to query (default is \"wbd08\").\n        predicate (str): The spatial predicate to use for the query (default is \"intersects\").\n        sort_attr (Optional[str]): The attribute to sort the results by (default is None).\n        **kwargs: Additional keyword arguments to pass to the WaterData.bygeom method.\n\n    Returns:\n        Optional[gpd.GeoDataFrame]: The fetched NHD data as a GeoDataFrame, or None if an error occurs.\n\n    Raises:\n        ImportError: If the pynhd package is not installed.\n        ValueError: If the geometry type is unsupported.\n    \"\"\"\n    try:\n        import pynhd\n    except ImportError:\n        print(\"The pynhd package is required for this function. Installing...\")\n        install_package(\"pynhd\")\n\n    import geopandas as gpd\n    from pynhd import WaterData\n\n    if isinstance(geometry, (list, tuple)):\n        crs = f\"EPSG:{geo_crs}\"\n        geometry = construct_bbox(*geometry, buffer=buffer, crs=crs, return_gdf=False)\n    elif isinstance(geometry, gpd.GeoDataFrame):\n        geometry = geometry.unary_union\n    elif isinstance(geometry, str):\n        geometry = gpd.read_file(geometry).unary_union\n\n    water_data = WaterData(dataset)\n\n    try:\n        gdf = water_data.bygeom(geometry, geo_crs, xy, predicate, sort_attr, **kwargs)\n    except Exception as e:\n        print(e)\n        gdf = None\n\n    return gdf\n</code></pre>"},{"location":"common/#beamgis.common.get_nhd_basins","title":"<code>get_nhd_basins(feature_ids, fsource='nwissite', split_catchment=False, simplified=True, **kwargs)</code>","text":"<p>Get NHD basins for a list of station IDs.</p> <p>Parameters:</p> Name Type Description Default <code>feature_ids</code> <code>str | list</code> <p>Target feature ID(s).</p> required <code>fsource</code> <code>str</code> <p>The name of feature(s) source, defaults to <code>nwissite</code>. The valid sources are: * 'comid' for NHDPlus comid. * 'ca_gages' for Streamgage catalog for CA SB19 * 'gfv11_pois' for USGS Geospatial Fabric V1.1 Points of Interest * 'huc12pp' for HUC12 Pour Points * 'nmwdi-st' for New Mexico Water Data Initiative Sites * 'nwisgw' for NWIS Groundwater Sites * 'nwissite' for NWIS Surface Water Sites * 'ref_gage' for geoconnex.us reference gauges * 'vigil' for Vigil Network Data * 'wade' for Water Data Exchange 2.0 Sites * 'WQP' for Water Quality Portal</p> <code>'nwissite'</code> <code>split_catchment</code> <code>bool</code> <p>If True, split basins at their outlet locations</p> <code>False</code> <code>simplified</code> <code>bool</code> <p>If True, return a simplified version of basin geometries. Default to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If pynhd is not installed.</p> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>NLDI indexed basins in EPSG:4326. If some IDs don't return any features     a list of missing ID(s) are returned as well.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_nhd_basins(\n    feature_ids,\n    fsource=\"nwissite\",\n    split_catchment=False,\n    simplified=True,\n    **kwargs,\n):\n    \"\"\"Get NHD basins for a list of station IDs.\n\n    Args:\n        feature_ids (str | list): Target feature ID(s).\n        fsource (str, optional): The name of feature(s) source, defaults to ``nwissite``.\n            The valid sources are:\n            * 'comid' for NHDPlus comid.\n            * 'ca_gages' for Streamgage catalog for CA SB19\n            * 'gfv11_pois' for USGS Geospatial Fabric V1.1 Points of Interest\n            * 'huc12pp' for HUC12 Pour Points\n            * 'nmwdi-st' for New Mexico Water Data Initiative Sites\n            * 'nwisgw' for NWIS Groundwater Sites\n            * 'nwissite' for NWIS Surface Water Sites\n            * 'ref_gage' for geoconnex.us reference gauges\n            * 'vigil' for Vigil Network Data\n            * 'wade' for Water Data Exchange 2.0 Sites\n            * 'WQP' for Water Quality Portal\n        split_catchment (bool, optional): If True, split basins at their outlet locations\n        simplified (bool, optional): If True, return a simplified version of basin geometries.\n            Default to True.\n\n    Raises:\n        ImportError: If pynhd is not installed.\n\n    Returns:\n        geopandas.GeoDataFrame: NLDI indexed basins in EPSG:4326. If some IDs don't return any features\n            a list of missing ID(s) are returned as well.\n    \"\"\"\n\n    try:\n        from pynhd import NLDI\n    except ImportError:\n        raise ImportError(\"pynhd is not installed. Install it with pip install pynhd\")\n\n    return NLDI().get_basins(\n        feature_ids, fsource, split_catchment, simplified, **kwargs\n    )\n</code></pre>"},{"location":"common/#beamgis.common.get_nwi","title":"<code>get_nwi(geometry, inSR='4326', outSR='3857', spatialRel='esriSpatialRelIntersects', return_geometry=True, outFields='*', output=None, **kwargs)</code>","text":"<p>Query the NWI (National Wetlands Inventory) API using various geometry types. https://fwspublicservices.wim.usgs.gov/wetlandsmapservice/rest/services/Wetlands/FeatureServer</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>dict</code> <p>The geometry data (e.g., point, polygon, polyline, multipoint, etc.).</p> required <code>inSR</code> <code>str</code> <p>The input spatial reference (default is EPSG:4326).</p> <code>'4326'</code> <code>outSR</code> <code>str</code> <p>The output spatial reference (default is EPSG:3857).</p> <code>'3857'</code> <code>spatialRel</code> <code>str</code> <p>The spatial relationship (default is \"esriSpatialRelIntersects\").</p> <code>'esriSpatialRelIntersects'</code> <code>return_geometry</code> <code>bool</code> <p>Whether to return the geometry (default is True).</p> <code>True</code> <code>outFields</code> <code>str</code> <p>The fields to be returned (default is \"*\").</p> <code>'*'</code> <code>output</code> <code>str</code> <p>The output file path to save the GeoDataFrame (default is None).</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>The queried NWI data as a GeoDataFrame.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_nwi(\n    geometry: Dict[str, Any],\n    inSR: str = \"4326\",\n    outSR: str = \"3857\",\n    spatialRel: str = \"esriSpatialRelIntersects\",\n    return_geometry: bool = True,\n    outFields: str = \"*\",\n    output: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Union[\"gpd.GeoDataFrame\", \"pd.DataFrame\", Dict[str, str]]:\n    \"\"\"\n    Query the NWI (National Wetlands Inventory) API using various geometry types.\n    https://fwspublicservices.wim.usgs.gov/wetlandsmapservice/rest/services/Wetlands/FeatureServer\n\n    Args:\n        geometry (dict): The geometry data (e.g., point, polygon, polyline, multipoint, etc.).\n        inSR (str): The input spatial reference (default is EPSG:4326).\n        outSR (str): The output spatial reference (default is EPSG:3857).\n        spatialRel (str): The spatial relationship (default is \"esriSpatialRelIntersects\").\n        return_geometry (bool): Whether to return the geometry (default is True).\n        outFields (str): The fields to be returned (default is \"*\").\n        output (str): The output file path to save the GeoDataFrame (default is None).\n        **kwargs: Additional keyword arguments to pass to the API.\n\n    Returns:\n        gpd.GeoDataFrame: The queried NWI data as a GeoDataFrame.\n    \"\"\"\n\n    import geopandas as gpd\n    import pandas as pd\n    from shapely.geometry import Polygon\n\n    def detect_geometry_type(geometry):\n        \"\"\"\n        Automatically detect the geometry type based on the structure of the geometry dictionary.\n        \"\"\"\n        if \"x\" in geometry and \"y\" in geometry:\n            return \"esriGeometryPoint\"\n        elif (\n            \"xmin\" in geometry\n            and \"ymin\" in geometry\n            and \"xmax\" in geometry\n            and \"ymax\" in geometry\n        ):\n            return \"esriGeometryEnvelope\"\n        elif \"rings\" in geometry:\n            return \"esriGeometryPolygon\"\n        elif \"paths\" in geometry:\n            return \"esriGeometryPolyline\"\n        elif \"points\" in geometry:\n            return \"esriGeometryMultipoint\"\n        else:\n            raise ValueError(\"Unsupported geometry type or invalid geometry structure.\")\n\n    # Convert GeoDataFrame to a dictionary if needed\n    geometry_type = None\n    if isinstance(geometry, gpd.GeoDataFrame):\n        geometry_dict = _convert_geodataframe_to_esri_format(geometry)[0]\n        geometry_type = detect_geometry_type(geometry_dict)\n    elif isinstance(geometry, dict):\n        geometry_type = detect_geometry_type(geometry)\n        geometry_dict = geometry\n    elif isinstance(geometry, str):\n        geometry_dict = geometry\n    else:\n        raise ValueError(\n            \"Invalid geometry input. Must be a GeoDataFrame or a dictionary.\"\n        )\n\n    # Convert geometry to a JSON string (required by the API)\n    if isinstance(geometry_dict, dict):\n        geometry_json = json.dumps(geometry_dict)\n    else:\n        geometry_json = geometry_dict\n    # API URL for querying wetlands\n    url = \"https://fwspublicservices.wim.usgs.gov/wetlandsmapservice/rest/services/Wetlands/MapServer/0/query\"\n\n    # Construct the query parameters\n    params = {\n        \"geometry\": geometry_json,  # The geometry as a JSON string\n        \"geometryType\": geometry_type,  # Geometry type (automatically detected)\n        \"inSR\": inSR,  # Spatial reference system (default is WGS84)\n        \"spatialRel\": spatialRel,  # Spatial relationship (default is intersects)\n        \"outFields\": outFields,  # Which fields to return (default is all fields)\n        \"returnGeometry\": str(\n            return_geometry\n        ).lower(),  # Whether to return the geometry\n        \"f\": \"json\",  # Response format\n    }\n\n    for key, value in kwargs.items():\n        params[key] = value\n\n    # Make the GET request\n    response = requests.get(url, params=params)\n\n    # Check if the request was successful\n    if response.status_code == 200:\n        data = response.json()  # Return the data as a Python dictionary\n    else:\n        return {\"error\": f\"Request failed with status code {response.status_code}\"}\n\n    # Extract the features\n    features = data[\"features\"]\n\n    # Prepare the attribute data and geometries\n    attributes = [feature[\"attributes\"] for feature in features]\n\n    # Create a DataFrame for attributes\n    df = pd.DataFrame(attributes)\n    df.rename(\n        columns={\n            \"Shape__Length\": \"Shape_Length\",\n            \"Shape__Area\": \"Shape_Area\",\n            \"WETLAND_TYPE\": \"WETLAND_TY\",\n        },\n        inplace=True,\n    )\n\n    if return_geometry:\n        geometries = [Polygon(feature[\"geometry\"][\"rings\"][0]) for feature in features]\n        # Create a GeoDataFrame by combining the attributes and geometries\n        gdf = gpd.GeoDataFrame(\n            df,\n            geometry=geometries,\n            crs=f\"EPSG:{data['spatialReference']['latestWkid']}\",\n        )\n        if outSR != \"3857\":\n            gdf = gdf.to_crs(outSR)\n\n        if output is not None:\n            gdf.to_file(output)\n\n        return gdf\n    else:\n        return df\n</code></pre>"},{"location":"common/#beamgis.common.get_nwi_by_huc8","title":"<code>get_nwi_by_huc8(huc8=None, geometry=None, out_dir=None, quiet=True, layer='Wetlands', **kwargs)</code>","text":"<p>Fetches National Wetlands Inventory (NWI) data by HUC8 code.</p> <p>Parameters:</p> Name Type Description Default <code>huc8</code> <code>Optional[str]</code> <p>The HUC8 code to query the NWI data. It must be a string of length 8.</p> <code>None</code> <code>geometry</code> <code>Optional[Union[gpd.GeoDataFrame, str]]</code> <p>The geometry to derive the HUC8 code. It can be a GeoDataFrame or a file path.</p> <code>None</code> <code>out_dir</code> <code>Optional[str]</code> <p>The directory to save the downloaded data. Defaults to a temporary directory.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Whether to suppress download progress messages. Defaults to True.</p> <code>True</code> <code>layer</code> <code>str</code> <p>The layer to fetch from the NWI data. It can be one of the following: Wetlands, Watershed, Riparian_Project_Metadata, Wetlands_Historic_Map_Info. Defaults to \"Wetlands\".</p> <code>'Wetlands'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the download_file function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>The fetched NWI data as a GeoDataFrame.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the HUC8 code is invalid or the layer is not allowed.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_nwi_by_huc8(\n    huc8: Optional[str] = None,\n    geometry: Optional[Union[\"gpd.GeoDataFrame\", str]] = None,\n    out_dir: Optional[str] = None,\n    quiet: bool = True,\n    layer: str = \"Wetlands\",\n    **kwargs,\n) -&gt; \"gpd.GeoDataFrame\":\n    \"\"\"\n    Fetches National Wetlands Inventory (NWI) data by HUC8 code.\n\n    Args:\n        huc8 (Optional[str]): The HUC8 code to query the NWI data. It must be a\n            string of length 8.\n        geometry (Optional[Union[gpd.GeoDataFrame, str]]): The geometry to derive\n            the HUC8 code. It can be a GeoDataFrame or a file path.\n        out_dir (Optional[str]): The directory to save the downloaded data.\n            Defaults to a temporary directory.\n        quiet (bool): Whether to suppress download progress messages. Defaults to True.\n        layer (str): The layer to fetch from the NWI data. It can be one of the following:\n            Wetlands, Watershed, Riparian_Project_Metadata, Wetlands_Historic_Map_Info.\n            Defaults to \"Wetlands\".\n        **kwargs: Additional keyword arguments to pass to the download_file function.\n\n    Returns:\n        gpd.GeoDataFrame: The fetched NWI data as a GeoDataFrame.\n\n    Raises:\n        ValueError: If the HUC8 code is invalid or the layer is not allowed.\n    \"\"\"\n    import tempfile\n    import geopandas as gpd\n\n    if geometry is not None:\n        wbd = get_wbd(geometry, return_geometry=False)\n        huc8 = wbd[\"huc8\"].values[0]\n\n    if isinstance(huc8, str) and len(huc8) == 8:\n        pass\n    else:\n        raise ValueError(\"Invalid HUC8 code. It must be a string of length 8.\")\n\n    if out_dir is None:\n        out_dir = tempfile.gettempdir()\n\n    allowed_layers = [\n        \"Wetlands\",\n        \"Watershed\",\n        \"Riparian_Project_Metadata\",\n        \"Wetlands_Historic_Map_Info\",\n        \"Wetlands_Project_Metadata\",\n    ]\n    if layer not in allowed_layers:\n        raise ValueError(f\"Invalid layer. Allowed values are {allowed_layers}\")\n\n    url = f\"https://documentst.ecosphere.fws.gov/wetlands/downloads/watershed/HU8_{huc8}_Watershed.zip\"\n\n    filename = os.path.join(out_dir, f\"HU8_{huc8}_Watershed.zip\")\n\n    download_file(url, filename, quiet=quiet, **kwargs)\n\n    data_dir = os.path.join(out_dir, f\"HU8_{huc8}_Watershed\")\n\n    filepath = os.path.join(data_dir, f\"HU8_{huc8}_{layer}.shp\")\n\n    gdf = gpd.read_file(filepath)\n    return gdf\n</code></pre>"},{"location":"common/#beamgis.common.get_overlap","title":"<code>get_overlap(img1, img2, overlap, out_img1=None, out_img2=None, to_cog=True)</code>","text":"<p>Get overlapping area of two images.</p> <p>Parameters:</p> Name Type Description Default <code>img1</code> <code>str</code> <p>Path to the first image.</p> required <code>img2</code> <code>str</code> <p>Path to the second image.</p> required <code>overlap</code> <code>str</code> <p>Path to the output overlap area in GeoJSON format.</p> required <code>out_img1</code> <code>str</code> <p>Path to the cropped image of the first image.</p> <code>None</code> <code>out_img2</code> <code>str</code> <p>Path to the cropped image of the second image.</p> <code>None</code> <code>to_cog</code> <code>bool</code> <p>Whether to convert the output images to COG.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the overlap area in GeoJSON format.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_overlap(img1, img2, overlap, out_img1=None, out_img2=None, to_cog=True):\n    \"\"\"Get overlapping area of two images.\n\n    Args:\n        img1 (str): Path to the first image.\n        img2 (str): Path to the second image.\n        overlap (str): Path to the output overlap area in GeoJSON format.\n        out_img1 (str, optional): Path to the cropped image of the first image.\n        out_img2 (str, optional): Path to the cropped image of the second image.\n        to_cog (bool, optional): Whether to convert the output images to COG.\n\n    Returns:\n        str: Path to the overlap area in GeoJSON format.\n    \"\"\"\n    import json\n    from osgeo import gdal, ogr, osr\n    import geopandas as gpd\n\n    extent = gdal.Info(img1, format=\"json\")[\"wgs84Extent\"]\n    poly1 = ogr.CreateGeometryFromJson(json.dumps(extent))\n    extent = gdal.Info(img2, format=\"json\")[\"wgs84Extent\"]\n    poly2 = ogr.CreateGeometryFromJson(json.dumps(extent))\n    intersection = poly1.Intersection(poly2)\n    gg = gdal.OpenEx(intersection.ExportToJson())\n    ds = gdal.VectorTranslate(\n        overlap,\n        srcDS=gg,\n        format=\"GeoJSON\",\n        layerCreationOptions=[\"RFC7946=YES\", \"WRITE_BBOX=YES\"],\n    )\n    ds = None\n\n    d = gdal.Open(img1)\n    proj = osr.SpatialReference(wkt=d.GetProjection())\n    epsg = proj.GetAttrValue(\"AUTHORITY\", 1)\n\n    gdf = gpd.read_file(overlap)\n    gdf.to_crs(epsg=epsg, inplace=True)\n    gdf.to_file(overlap)\n\n    if out_img1 is not None:\n        clip_image(img1, overlap, out_img1, to_cog=to_cog)\n\n    if out_img2 is not None:\n        clip_image(img2, overlap, out_img2, to_cog=to_cog)\n\n    return overlap\n</code></pre>"},{"location":"common/#beamgis.common.get_overture_data","title":"<code>get_overture_data(overture_type, bbox=None, columns=None, output=None)</code>","text":"<p>Fetches overture data and returns it as a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>overture_type</code> <code>str</code> <p>The type of overture data to fetch.It can be one of the following: address|building|building_part|division|division_area|division_boundary|place| segment|connector|infrastructure|land|land_cover|land_use|water</p> required <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>The bounding box to filter the data. Defaults to None.</p> <code>None</code> <code>columns</code> <code>List[str]</code> <p>The columns to include in the output. Defaults to None.</p> <code>None</code> <code>output</code> <code>str</code> <p>The file path to save the output GeoDataFrame. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>The fetched overture data as a GeoDataFrame.</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the overture package is not installed.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_overture_data(\n    overture_type: str,\n    bbox: Tuple[float, float, float, float] = None,\n    columns: List[str] = None,\n    output: str = None,\n) -&gt; \"gpd.GeoDataFrame\":\n    \"\"\"Fetches overture data and returns it as a GeoDataFrame.\n\n    Args:\n        overture_type (str): The type of overture data to fetch.It can be one of the following:\n            address|building|building_part|division|division_area|division_boundary|place|\n            segment|connector|infrastructure|land|land_cover|land_use|water\n        bbox (Tuple[float, float, float, float], optional): The bounding box to\n            filter the data. Defaults to None.\n        columns (List[str], optional): The columns to include in the output.\n            Defaults to None.\n        output (str, optional): The file path to save the output GeoDataFrame.\n            Defaults to None.\n\n    Returns:\n        gpd.GeoDataFrame: The fetched overture data as a GeoDataFrame.\n\n    Raises:\n        ImportError: If the overture package is not installed.\n    \"\"\"\n\n    try:\n        from overturemaps import core\n    except ImportError:\n        install_package(\"overturemaps\")\n        from overturemaps import core\n\n    gdf = core.geodataframe(overture_type, bbox=bbox)\n    if columns is not None:\n        gdf = gdf[columns]\n\n    gdf.crs = \"EPSG:4326\"\n    if output is not None:\n        gdf.to_file(output)\n\n    return gdf\n</code></pre>"},{"location":"common/#beamgis.common.get_overture_latest_release","title":"<code>get_overture_latest_release(patch=False)</code>","text":"<p>Retrieves the value of the 'latest' key from the Overture Maps release JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>patch</code> <code>bool</code> <p>If True, returns the full version string (e.g., \"2025-02-19.0\").</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The value of the 'latest' key from the releases.json file.</p> <p>Exceptions:</p> Type Description <code>requests.RequestException</code> <p>If there's an issue with the HTTP request.</p> <code>KeyError</code> <p>If the 'latest' key is not found in the JSON data.</p> <code>json.JSONDecodeError</code> <p>If the response cannot be parsed as JSON.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_overture_latest_release(patch=False) -&gt; str:\n    \"\"\"\n    Retrieves the value of the 'latest' key from the Overture Maps release JSON file.\n\n    Args:\n        patch (bool): If True, returns the full version string (e.g., \"2025-02-19.0\").\n\n    Returns:\n        str: The value of the 'latest' key from the releases.json file.\n\n    Raises:\n        requests.RequestException: If there's an issue with the HTTP request.\n        KeyError: If the 'latest' key is not found in the JSON data.\n        json.JSONDecodeError: If the response cannot be parsed as JSON.\n    \"\"\"\n    url = \"https://labs.overturemaps.org/data/releases.json\"\n\n    try:\n        response = requests.get(url)\n        response.raise_for_status()  # Raise an exception for HTTP errors\n\n        data = response.json()\n        if patch:\n            latest_release = data.get(\"latest\")\n        else:\n            latest_release = data.get(\"latest\").split(\".\")[\n                0\n            ]  # Extract the version number\n\n        if latest_release is None:\n            raise KeyError(\"The 'latest' key was not found in the releases.json file\")\n\n        return latest_release\n\n    except requests.RequestException as e:\n        print(f\"Error making the request: {e}\")\n        raise\n    except json.JSONDecodeError as e:\n        print(f\"Error parsing JSON response: {e}\")\n        raise\n    except KeyError as e:\n        print(f\"Key error: {e}\")\n        raise\n</code></pre>"},{"location":"common/#beamgis.common.get_palettable","title":"<code>get_palettable(types=None)</code>","text":"<p>Get a list of palettable color palettes.</p> <p>Parameters:</p> Name Type Description Default <code>types</code> <code>list</code> <p>A list of palettable types to return, e.g., types=['matplotlib', 'cartocolors']. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of palettable color palettes.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_palettable(types=None):\n    \"\"\"Get a list of palettable color palettes.\n\n    Args:\n        types (list, optional): A list of palettable types to return, e.g., types=['matplotlib', 'cartocolors']. Defaults to None.\n\n    Returns:\n        list: A list of palettable color palettes.\n    \"\"\"\n    try:\n        import palettable\n    except ImportError:\n        raise ImportError(\n            \"Please install the palettable package using 'pip install palettable'.\"\n        )\n\n    if types is not None and (not isinstance(types, list)):\n        raise ValueError(\"The types must be a list.\")\n\n    allowed_palettes = [\n        \"cartocolors\",\n        \"cmocean\",\n        \"colorbrewer\",\n        \"cubehelix\",\n        \"lightbartlein\",\n        \"matplotlib\",\n        \"mycarta\",\n        \"scientific\",\n        \"tableau\",\n        \"wesanderson\",\n    ]\n\n    if types is None:\n        types = allowed_palettes[:]\n\n    if all(x in allowed_palettes for x in types):\n        pass\n    else:\n        raise ValueError(\n            \"The types must be one of the following: \" + \", \".join(allowed_palettes)\n        )\n\n    palettes = []\n\n    if \"cartocolors\" in types:\n        cartocolors_diverging = [\n            f\"cartocolors.diverging.{c}\"\n            for c in dir(palettable.cartocolors.diverging)[:-19]\n        ]\n        cartocolors_qualitative = [\n            f\"cartocolors.qualitative.{c}\"\n            for c in dir(palettable.cartocolors.qualitative)[:-19]\n        ]\n        cartocolors_sequential = [\n            f\"cartocolors.sequential.{c}\"\n            for c in dir(palettable.cartocolors.sequential)[:-41]\n        ]\n\n        palettes = (\n            palettes\n            + cartocolors_diverging\n            + cartocolors_qualitative\n            + cartocolors_sequential\n        )\n\n    if \"cmocean\" in types:\n        cmocean_diverging = [\n            f\"cmocean.diverging.{c}\" for c in dir(palettable.cmocean.diverging)[:-19]\n        ]\n        cmocean_sequential = [\n            f\"cmocean.sequential.{c}\" for c in dir(palettable.cmocean.sequential)[:-19]\n        ]\n\n        palettes = palettes + cmocean_diverging + cmocean_sequential\n\n    if \"colorbrewer\" in types:\n        colorbrewer_diverging = [\n            f\"colorbrewer.diverging.{c}\"\n            for c in dir(palettable.colorbrewer.diverging)[:-19]\n        ]\n        colorbrewer_qualitative = [\n            f\"colorbrewer.qualitative.{c}\"\n            for c in dir(palettable.colorbrewer.qualitative)[:-19]\n        ]\n        colorbrewer_sequential = [\n            f\"colorbrewer.sequential.{c}\"\n            for c in dir(palettable.colorbrewer.sequential)[:-41]\n        ]\n\n        palettes = (\n            palettes\n            + colorbrewer_diverging\n            + colorbrewer_qualitative\n            + colorbrewer_sequential\n        )\n\n    if \"cubehelix\" in types:\n        cubehelix = [\n            \"classic_16\",\n            \"cubehelix1_16\",\n            \"cubehelix2_16\",\n            \"cubehelix3_16\",\n            \"jim_special_16\",\n            \"perceptual_rainbow_16\",\n            \"purple_16\",\n            \"red_16\",\n        ]\n        cubehelix = [f\"cubehelix.{c}\" for c in cubehelix]\n        palettes = palettes + cubehelix\n\n    if \"lightbartlein\" in types:\n        lightbartlein_diverging = [\n            f\"lightbartlein.diverging.{c}\"\n            for c in dir(palettable.lightbartlein.diverging)[:-19]\n        ]\n        lightbartlein_sequential = [\n            f\"lightbartlein.sequential.{c}\"\n            for c in dir(palettable.lightbartlein.sequential)[:-19]\n        ]\n\n        palettes = palettes + lightbartlein_diverging + lightbartlein_sequential\n\n    if \"matplotlib\" in types:\n        matplotlib_colors = [\n            f\"matplotlib.{c}\" for c in dir(palettable.matplotlib)[:-16]\n        ]\n        palettes = palettes + matplotlib_colors\n\n    if \"mycarta\" in types:\n        mycarta = [f\"mycarta.{c}\" for c in dir(palettable.mycarta)[:-16]]\n        palettes = palettes + mycarta\n\n    if \"scientific\" in types:\n        scientific_diverging = [\n            f\"scientific.diverging.{c}\"\n            for c in dir(palettable.scientific.diverging)[:-19]\n        ]\n        scientific_sequential = [\n            f\"scientific.sequential.{c}\"\n            for c in dir(palettable.scientific.sequential)[:-19]\n        ]\n\n        palettes = palettes + scientific_diverging + scientific_sequential\n\n    if \"tableau\" in types:\n        tableau = [f\"tableau.{c}\" for c in dir(palettable.tableau)[:-14]]\n        palettes = palettes + tableau\n\n    return palettes\n</code></pre>"},{"location":"common/#beamgis.common.get_palette_colors","title":"<code>get_palette_colors(cmap_name=None, n_class=None, hashtag=False)</code>","text":"<p>Get a palette from a matplotlib colormap. See the list of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.</p> <p>Parameters:</p> Name Type Description Default <code>cmap_name</code> <code>str</code> <p>The name of the matplotlib colormap. Defaults to None.</p> <code>None</code> <code>n_class</code> <code>int</code> <p>The number of colors. Defaults to None.</p> <code>None</code> <code>hashtag</code> <code>bool</code> <p>Whether to return a list of hex colors. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of hex colors.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_palette_colors(cmap_name=None, n_class=None, hashtag=False):\n    \"\"\"Get a palette from a matplotlib colormap. See the list of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.\n\n    Args:\n        cmap_name (str, optional): The name of the matplotlib colormap. Defaults to None.\n        n_class (int, optional): The number of colors. Defaults to None.\n        hashtag (bool, optional): Whether to return a list of hex colors. Defaults to False.\n\n    Returns:\n        list: A list of hex colors.\n    \"\"\"\n    import matplotlib as mpl\n    import matplotlib.pyplot as plt\n\n    try:\n        cmap = plt.get_cmap(cmap_name, n_class)\n    except:\n        cmap = plt.cm.get_cmap(cmap_name, n_class)\n    colors = [mpl.colors.rgb2hex(cmap(i))[1:] for i in range(cmap.N)]\n    if hashtag:\n        colors = [\"#\" + i for i in colors]\n    return colors\n</code></pre>"},{"location":"common/#beamgis.common.get_parquet_geometry_column","title":"<code>get_parquet_geometry_column(input_parquet, db_con=None)</code>","text":"<p>Retrieves the geometry column name from a Parquet file.</p> <p>This function checks for the presence of a geometry column in the input Parquet file. It looks for columns named \"geometry\" or \"geom\" and returns the first match.</p> <p>Parameters:</p> Name Type Description Default <code>input_parquet</code> <code>str</code> <p>The path to the input Parquet file.</p> required <code>db_con</code> <code>duckdb.Connection</code> <p>An existing DuckDB connection. If None, a new connection will be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The name of the geometry column (\"geometry\" or \"geom\").</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If no recognized geometry column is found in the input Parquet file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; geometry_column = get_parquet_geometry_column(\"data.parquet\")\n&gt;&gt;&gt; print(geometry_column)\n\"geometry\"\n</code></pre> Source code in <code>beamgis/common.py</code> <pre><code>def get_parquet_geometry_column(input_parquet: str, db_con=None) -&gt; str:\n    \"\"\"\n    Retrieves the geometry column name from a Parquet file.\n\n    This function checks for the presence of a geometry column in the input Parquet file.\n    It looks for columns named \"geometry\" or \"geom\" and returns the first match.\n\n    Args:\n        input_parquet (str): The path to the input Parquet file.\n        db_con (duckdb.Connection, optional): An existing DuckDB connection. If None, a new connection will be created.\n\n    Returns:\n        str: The name of the geometry column (\"geometry\" or \"geom\").\n\n    Raises:\n        ValueError: If no recognized geometry column is found in the input Parquet file.\n\n    Example:\n        &gt;&gt;&gt; geometry_column = get_parquet_geometry_column(\"data.parquet\")\n        &gt;&gt;&gt; print(geometry_column)\n        \"geometry\"\n    \"\"\"\n    column_names = get_vector_column_names(input_parquet, db_con=db_con)\n    if \"geometry\" in column_names:\n        return \"geometry\"\n    elif \"geom\" in column_names:\n        return \"geom\"\n    else:\n        raise ValueError(\n            f\"The input vector file does not contain a recognized geometry column. \"\n            f\"Available columns: {column_names}. Please ensure the vector file has a 'geometry' or 'geom' column.\"\n        )\n</code></pre>"},{"location":"common/#beamgis.common.get_solar_data","title":"<code>get_solar_data(lat, lon, radiusMeters=50, view='FULL_LAYERS', requiredQuality='HIGH', pixelSizeMeters=0.1, api_key=None, header=None, out_dir=None, basename=None, quiet=False, **kwargs)</code>","text":"<p>Retrieve solar data for a specific location from Google's Solar API https://developers.google.com/maps/documentation/solar. You need to enable Solar API from https://console.cloud.google.com/google/maps-apis/api-list.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Latitude of the location.</p> required <code>lon</code> <code>float</code> <p>Longitude of the location.</p> required <code>radiusMeters</code> <code>int</code> <p>Radius in meters for the data retrieval (default is 50).</p> <code>50</code> <code>view</code> <code>str</code> <p>View type (default is \"FULL_LAYERS\"). For more options, see https://bit.ly/3LazuBi.</p> <code>'FULL_LAYERS'</code> <code>requiredQuality</code> <code>str</code> <p>Required quality level (default is \"HIGH\").</p> <code>'HIGH'</code> <code>pixelSizeMeters</code> <code>float</code> <p>Pixel size in meters (default is 0.1).</p> <code>0.1</code> <code>api_key</code> <code>str</code> <p>Google API key for authentication (if not provided, checks 'GOOGLE_API_KEY' environment variable).</p> <code>None</code> <code>header</code> <code>dict</code> <p>Additional HTTP headers to include in the request.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>Directory where downloaded files will be saved.</p> <code>None</code> <code>basename</code> <code>str</code> <p>Base name for the downloaded files (default is generated from imagery date).</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>If True, suppress progress messages during file downloads (default is False).</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the download_file function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>A dictionary mapping file names to their corresponding paths.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_solar_data(\n    lat: float,\n    lon: float,\n    radiusMeters: int = 50,\n    view: str = \"FULL_LAYERS\",\n    requiredQuality: str = \"HIGH\",\n    pixelSizeMeters: float = 0.1,\n    api_key: Optional[str] = None,\n    header: Optional[Dict[str, str]] = None,\n    out_dir: Optional[str] = None,\n    basename: Optional[str] = None,\n    quiet: bool = False,\n    **kwargs: Any,\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Retrieve solar data for a specific location from Google's Solar API https://developers.google.com/maps/documentation/solar.\n    You need to enable Solar API from https://console.cloud.google.com/google/maps-apis/api-list.\n\n    Args:\n        lat (float): Latitude of the location.\n        lon (float): Longitude of the location.\n        radiusMeters (int, optional): Radius in meters for the data retrieval (default is 50).\n        view (str, optional): View type (default is \"FULL_LAYERS\"). For more options, see https://bit.ly/3LazuBi.\n        requiredQuality (str, optional): Required quality level (default is \"HIGH\").\n        pixelSizeMeters (float, optional): Pixel size in meters (default is 0.1).\n        api_key (str, optional): Google API key for authentication (if not provided, checks 'GOOGLE_API_KEY' environment variable).\n        header (dict, optional): Additional HTTP headers to include in the request.\n        out_dir (str, optional): Directory where downloaded files will be saved.\n        basename (str, optional): Base name for the downloaded files (default is generated from imagery date).\n        quiet (bool, optional): If True, suppress progress messages during file downloads (default is False).\n        **kwargs: Additional keyword arguments to be passed to the download_file function.\n\n    Returns:\n        Dict[str, str]: A dictionary mapping file names to their corresponding paths.\n    \"\"\"\n\n    if api_key is None:\n        api_key = os.environ.get(\"GOOGLE_API_KEY\", \"\")\n\n    if api_key == \"\":\n        raise ValueError(\"GOOGLE_API_KEY is required to use this function.\")\n\n    url = \"https://solar.googleapis.com/v1/dataLayers:get\"\n    params = {\n        \"location.latitude\": lat,\n        \"location.longitude\": lon,\n        \"radiusMeters\": radiusMeters,\n        \"view\": view,\n        \"requiredQuality\": requiredQuality,\n        \"pixelSizeMeters\": pixelSizeMeters,\n        \"key\": api_key,\n    }\n\n    solar_data = requests.get(url, params=params, headers=header).json()\n\n    links = {}\n\n    for key in solar_data.keys():\n        if \"Url\" in key:\n            if isinstance(solar_data[key], list):\n                urls = [url + \"&amp;key=\" + api_key for url in solar_data[key]]\n                links[key] = urls\n            else:\n                links[key] = solar_data[key] + \"&amp;key=\" + api_key\n\n    if basename is None:\n        date = solar_data[\"imageryDate\"]\n        year = date[\"year\"]\n        month = date[\"month\"]\n        day = date[\"day\"]\n        basename = f\"{year}_{str(month).zfill(2)}_{str(day).zfill(2)}\"\n\n    filenames = {}\n\n    for link in links:\n        if isinstance(links[link], list):\n            for i, url in enumerate(links[link]):\n                filename = (\n                    f\"{basename}_{link.replace('Urls', '')}_{str(i+1).zfill(2)}.tif\"\n                )\n                if out_dir is not None:\n                    filename = os.path.join(out_dir, filename)\n                download_file(url, filename, quiet=quiet, **kwargs)\n                filenames[link.replace(\"Urls\", \"\") + \"_\" + str(i).zfill(2)] = filename\n        else:\n            name = link.replace(\"Url\", \"\")\n            filename = f\"{basename}_{name}.tif\"\n            if out_dir is not None:\n                filename = os.path.join(out_dir, filename)\n            download_file(links[link], filename, quiet=quiet, **kwargs)\n            filenames[name] = filename\n\n    return filenames\n</code></pre>"},{"location":"common/#beamgis.common.get_stac_collections","title":"<code>get_stac_collections(url, **kwargs)</code>","text":"<p>Retrieve a list of STAC collections from a URL. This function is adapted from https://github.com/mykolakozyr/stacdiscovery/blob/a5d1029aec9c428a7ce7ae615621ea8915162824/app.py#L31. Credits to Mykola Kozyr.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>A URL to a STAC catalog.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the pystac Client.open() method. See https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.open</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of STAC collections.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_stac_collections(url, **kwargs):\n    \"\"\"Retrieve a list of STAC collections from a URL.\n    This function is adapted from https://github.com/mykolakozyr/stacdiscovery/blob/a5d1029aec9c428a7ce7ae615621ea8915162824/app.py#L31.\n    Credits to Mykola Kozyr.\n\n    Args:\n        url (str): A URL to a STAC catalog.\n        **kwargs: Additional keyword arguments to pass to the pystac Client.open() method.\n            See https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.open\n\n    Returns:\n        list: A list of STAC collections.\n    \"\"\"\n    from pystac_client import Client\n\n    # Expensive function. Added cache for it.\n\n    # Empty list that would be used for a dataframe to collect and visualize info about collections\n    root_catalog = Client.open(url, **kwargs)\n    collections_list = []\n    # Reading collections in the Catalog\n    collections = list(root_catalog.get_collections())\n    print(collections)\n    for collection in collections:\n        id = collection.id\n        title = collection.title\n        # bbox = collection.extent.spatial.bboxes # not in use for the first release\n        # interval = collection.extent.temporal.intervals # not in use for the first release\n        description = collection.description\n\n        # creating a list of lists of values\n        collections_list.append([id, title, description])\n    return collections_list\n</code></pre>"},{"location":"common/#beamgis.common.get_stac_items","title":"<code>get_stac_items(url, collection, limit=None, bbox=None, datetime=None, intersects=None, ids=None, open_args=None, **kwargs)</code>","text":"<p>Retrieve a list of STAC items from a URL and a collection. This function is adapted from https://github.com/mykolakozyr/stacdiscovery/blob/a5d1029aec9c428a7ce7ae615621ea8915162824/app.py#L49. Credits to Mykola Kozyr. Available parameters can be found at https://github.com/radiantearth/stac-api-spec/tree/master/item-search</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>A URL to a STAC catalog.</p> required <code>collection</code> <code>str</code> <p>A STAC collection ID.</p> required <code>limit</code> <code>int</code> <p>The maximum number of results to return (page size). Defaults to None.</p> <code>None</code> <code>bbox</code> <code>tuple</code> <p>Requested bounding box in the format of (minx, miny, maxx, maxy). Defaults to None.</p> <code>None</code> <code>datetime</code> <code>str</code> <p>Single date+time, or a range ('/' separator), formatted to RFC 3339, section 5.6. Use double dots .. for open date ranges.</p> <code>None</code> <code>intersects</code> <code>dict</code> <p>A dictionary representing a GeoJSON Geometry. Searches items by performing intersection between their geometry and provided GeoJSON geometry. All GeoJSON geometry types must be supported.</p> <code>None</code> <code>ids</code> <code>list</code> <p>A list of item ids to return.</p> <code>None</code> <code>open_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the pystac Client.open() method. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the Catalog.search() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GeoPandas.GeoDataFraem</code> <p>A GeoDataFrame with the STAC items.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_stac_items(\n    url,\n    collection,\n    limit=None,\n    bbox=None,\n    datetime=None,\n    intersects=None,\n    ids=None,\n    open_args=None,\n    **kwargs,\n):\n    \"\"\"Retrieve a list of STAC items from a URL and a collection.\n    This function is adapted from https://github.com/mykolakozyr/stacdiscovery/blob/a5d1029aec9c428a7ce7ae615621ea8915162824/app.py#L49.\n    Credits to Mykola Kozyr.\n    Available parameters can be found at https://github.com/radiantearth/stac-api-spec/tree/master/item-search\n\n    Args:\n        url (str): A URL to a STAC catalog.\n        collection (str): A STAC collection ID.\n        limit (int, optional): The maximum number of results to return (page size). Defaults to None.\n        bbox (tuple, optional): Requested bounding box in the format of (minx, miny, maxx, maxy). Defaults to None.\n        datetime (str, optional): Single date+time, or a range ('/' separator), formatted to RFC 3339, section 5.6. Use double dots .. for open date ranges.\n        intersects (dict, optional): A dictionary representing a GeoJSON Geometry. Searches items by performing intersection between their geometry and provided GeoJSON geometry. All GeoJSON geometry types must be supported.\n        ids (list, optional): A list of item ids to return.\n        open_args (dict, optional): A dictionary of arguments to pass to the pystac Client.open() method. Defaults to None.\n        **kwargs: Additional keyword arguments to pass to the Catalog.search() method.\n\n    Returns:\n        GeoPandas.GeoDataFraem: A GeoDataFrame with the STAC items.\n    \"\"\"\n\n    import itertools\n    import geopandas as gpd\n    from shapely.geometry import shape\n    from pystac_client import Client\n\n    # Empty list that would be used for a dataframe to collect and visualize info about collections\n    items_list = []\n\n    if open_args is None:\n        open_args = {}\n\n    root_catalog = Client.open(url)\n\n    if limit:\n        kwargs[\"limit\"] = limit\n    if bbox:\n        kwargs[\"bbox\"] = bbox\n    if datetime:\n        kwargs[\"datetime\"] = datetime\n    if intersects:\n        kwargs[\"intersects\"] = intersects\n    if ids:\n        kwargs[\"ids\"] = ids\n\n    if kwargs:\n        try:\n            catalog = root_catalog.search(collections=collection, **kwargs)\n        except NotImplementedError:\n            catalog = root_catalog\n    else:\n        catalog = root_catalog\n\n    iterable = catalog.get_all_items()\n    items = list(\n        itertools.islice(iterable, limit)\n    )  # getting first 25000 items. To Do some smarter logic\n    if len(items) == 0:\n        try:\n            catalog = root_catalog.get_child(collection)\n            iterable = catalog.get_all_items()\n            items = list(itertools.islice(iterable, limit))\n        except Exception as _:\n            print(\"Ooops, it looks like this collection does not have items.\")\n            return None\n    # Iterating over items to collect main information\n    for item in items:\n        id = item.id\n        geometry = shape(item.geometry)\n        datetime = (\n            item.datetime\n            or item.properties[\"datetime\"]\n            or item.properties[\"end_datetime\"]\n            or item.properties[\"start_datetime\"]\n        )\n        links = item.links\n        for link in links:\n            if link.rel == \"self\":\n                self_url = link.target\n        assets_list = []\n        assets = item.assets\n        for asset in assets:\n            assets_list.append(asset)\n\n        # creating a list of lists of values\n        items_list.append([id, geometry, datetime, self_url, assets_list])\n\n    if limit is not None:\n        items_list = items_list[:limit]\n    items_df = gpd.GeoDataFrame(items_list)\n    items_df.columns = [\"id\", \"geometry\", \"datetime\", \"self_url\", \"assets_list\"]\n\n    items_gdf = items_df.set_geometry(\"geometry\")\n    items_gdf[\"datetime\"] = items_gdf[\"datetime\"].astype(\n        str\n    )  # specifically for KeplerGL. See https://github.com/keplergl/kepler.gl/issues/602\n    # items_gdf[\"assets_list\"] = items_gdf[\"assets_list\"].astype(str) #specifically for KeplerGL. See https://github.com/keplergl/kepler.gl/issues/602\n    items_gdf.set_crs(epsg=4326, inplace=True)\n    return items_gdf\n</code></pre>"},{"location":"common/#beamgis.common.get_vector_column_names","title":"<code>get_vector_column_names(input_vector, db_con=None)</code>","text":"<p>Retrieves the column names from a DuckDB table.</p> <p>Parameters:</p> Name Type Description Default <code>input_vecotr</code> <code>str</code> <p>The path to the input vector file (e.g., a Parquet or GeoPackage file).</p> required <code>db_con</code> <code>duckdb.Connection</code> <p>An existing DuckDB connection. If None, a new connection will be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of column names from the specified table.</p> <p>Exceptions:</p> Type Description <code>duckdb.CatalogException</code> <p>If the table does not exist.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_vector_column_names(input_vector, db_con=None):\n    \"\"\"\n    Retrieves the column names from a DuckDB table.\n\n    Args:\n        input_vecotr (str): The path to the input vector file (e.g., a Parquet or GeoPackage file).\n        db_con (duckdb.Connection, optional): An existing DuckDB connection. If None, a new connection will be created.\n\n    Returns:\n        List[str]: A list of column names from the specified table.\n\n    Raises:\n        duckdb.CatalogException: If the table does not exist.\n    \"\"\"\n    import duckdb\n\n    if db_con is None:\n        db_con = duckdb.connect()\n\n    db_con.execute(\"INSTALL spatial;\")\n    db_con.execute(\"LOAD spatial;\")\n\n    if not os.path.exists(input_vector):\n        raise ValueError(f\"Input vector file does not exist: {input_vector}\")\n\n    if input_vector.endswith(\".parquet\"):\n        query = f\"SELECT * FROM '{input_vector}' LIMIT 0\"\n    else:\n        query = f\"SELECT * FROM ST_Read('{input_vector}') LIMIT 0\"\n    db_con.execute(query)\n    return [desc[0] for desc in db_con.description]\n</code></pre>"},{"location":"common/#beamgis.common.get_vector_crs","title":"<code>get_vector_crs(input_vector, db_con=None, return_epsg=False)</code>","text":"<p>Retrieves the Coordinate Reference System (CRS) of a vector file.</p> <p>This function extracts the CRS information from the metadata of the input vector file.</p> <p>Parameters:</p> Name Type Description Default <code>input_vector</code> <code>str</code> <p>The path to the input vector file.</p> required <code>db_con</code> <code>duckdb.Connection</code> <p>An existing DuckDB connection. If None, a new connection will be created.</p> <code>None</code> <code>return_epsg</code> <code>bool</code> <p>Whether to return the EPSG code of the CRS. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[dict, int]</code> <p>The CRS information as a dictionary or the EPSG code as an integer.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the CRS information is not available in the input vector file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; crs = get_vector_crs(\"data.gpkg\", return_epsg=True)\n&gt;&gt;&gt; print(crs)\n4326\n</code></pre> Source code in <code>beamgis/common.py</code> <pre><code>def get_vector_crs(input_vector, db_con=None, return_epsg=False):\n    \"\"\"\n    Retrieves the Coordinate Reference System (CRS) of a vector file.\n\n    This function extracts the CRS information from the metadata of the input vector file.\n\n    Args:\n        input_vector (str): The path to the input vector file.\n        db_con (duckdb.Connection, optional): An existing DuckDB connection. If None, a new connection will be created.\n        return_epsg (bool): Whether to return the EPSG code of the CRS. Defaults to False.\n\n    Returns:\n        Union[dict, int]: The CRS information as a dictionary or the EPSG code as an integer.\n\n    Raises:\n        ValueError: If the CRS information is not available in the input vector file.\n\n    Example:\n        &gt;&gt;&gt; crs = get_vector_crs(\"data.gpkg\", return_epsg=True)\n        &gt;&gt;&gt; print(crs)\n        4326\n    \"\"\"\n    metadata = get_vector_metadata(input_vector, db_con=db_con)\n    crs = metadata[\"geometry_fields\"][0][\"crs\"]\n    if return_epsg:\n        if crs[\"auth_name\"] == \"EPSG\" and len(crs[\"auth_code\"]) &gt; 0:\n            return int(crs[\"auth_code\"])  # Return the EPSG code if available\n        else:\n            raise ValueError(\n                f\"CRS information is not available in the input vector file: {input_vector}. \"\n            )\n    else:\n        return crs\n</code></pre>"},{"location":"common/#beamgis.common.get_vector_metadata","title":"<code>get_vector_metadata(input_vector, db_con=None)</code>","text":"<p>Retrieves metadata for a vector file.</p> <p>This function uses DuckDB with the spatial extension to extract metadata about the layers in the input vector file.</p> <p>Parameters:</p> Name Type Description Default <code>input_vector</code> <code>str</code> <p>The path to the input vector file.</p> required <code>db_con</code> <code>duckdb.Connection</code> <p>An existing DuckDB connection. If None, a new connection will be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing metadata about the vector file.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the input vector file does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; metadata = get_vector_metadata(\"data.gpkg\")\n&gt;&gt;&gt; print(metadata)\n{'geometry_fields': [{'name': 'geom', 'crs': {'auth_name': 'EPSG', 'auth_code': '4326'}}], ...}\n</code></pre> Source code in <code>beamgis/common.py</code> <pre><code>def get_vector_metadata(input_vector, db_con=None):\n    \"\"\"\n    Retrieves metadata for a vector file.\n\n    This function uses DuckDB with the spatial extension to extract metadata\n    about the layers in the input vector file.\n\n    Args:\n        input_vector (str): The path to the input vector file.\n        db_con (duckdb.Connection, optional): An existing DuckDB connection. If None, a new connection will be created.\n\n    Returns:\n        dict: A dictionary containing metadata about the vector file.\n\n    Raises:\n        ValueError: If the input vector file does not exist.\n\n    Example:\n        &gt;&gt;&gt; metadata = get_vector_metadata(\"data.gpkg\")\n        &gt;&gt;&gt; print(metadata)\n        {'geometry_fields': [{'name': 'geom', 'crs': {'auth_name': 'EPSG', 'auth_code': '4326'}}], ...}\n    \"\"\"\n    import duckdb\n\n    if db_con is None:\n        db_con = duckdb.connect()\n\n    db_con.execute(\"INSTALL spatial;\")\n    db_con.execute(\"LOAD spatial;\")\n\n    if not os.path.exists(input_vector):\n        raise ValueError(f\"Input vector file does not exist: {input_vector}\")\n\n    query = f\"SELECT * FROM ST_Read_Meta('{input_vector}')\"\n    df = db_con.execute(query).fetch_df()\n    meta = df[\"layers\"][0][0]\n    return meta\n</code></pre>"},{"location":"common/#beamgis.common.get_wbd","title":"<code>get_wbd(geometry=None, searchText=None, inSR='4326', outSR='3857', digit=8, spatialRel='esriSpatialRelIntersects', return_geometry=True, outFields='*', output=None, **kwargs)</code>","text":"<p>Query the WBD (Watershed Boundary Dataset) API using various geometry types or a GeoDataFrame. https://hydro.nationalmap.gov/arcgis/rest/services/wbd/MapServer</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>Union[gpd.GeoDataFrame, Dict]</code> <p>The geometry data (GeoDataFrame or geometry dict).</p> <code>None</code> <code>inSR</code> <code>str</code> <p>The input spatial reference (default is EPSG:4326).</p> <code>'4326'</code> <code>outSR</code> <code>str</code> <p>The output spatial reference (default is EPSG:3857).</p> <code>'3857'</code> <code>digit</code> <code>int</code> <p>The digit code for the WBD layer (default is 8).</p> <code>8</code> <code>spatialRel</code> <code>str</code> <p>The spatial relationship (default is \"esriSpatialRelIntersects\").</p> <code>'esriSpatialRelIntersects'</code> <code>return_geometry</code> <code>bool</code> <p>Whether to return the geometry (default is True).</p> <code>True</code> <code>outFields</code> <code>str</code> <p>The fields to be returned (default is \"*\").</p> <code>'*'</code> <code>output</code> <code>Optional[str]</code> <p>The output file path to save the GeoDataFrame (default is None).</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame or pd.DataFrame</code> <p>The queried WBD data as a GeoDataFrame or DataFrame.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_wbd(\n    geometry: Union[\"gpd.GeoDataFrame\", Dict[str, Any]] = None,\n    searchText: Optional[str] = None,\n    inSR: str = \"4326\",\n    outSR: str = \"3857\",\n    digit: int = 8,\n    spatialRel: str = \"esriSpatialRelIntersects\",\n    return_geometry: bool = True,\n    outFields: str = \"*\",\n    output: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Union[\"gpd.GeoDataFrame\", \"pd.DataFrame\", Dict[str, str]]:\n    \"\"\"\n    Query the WBD (Watershed Boundary Dataset) API using various geometry types or a GeoDataFrame.\n    https://hydro.nationalmap.gov/arcgis/rest/services/wbd/MapServer\n\n    Args:\n        geometry (Union[gpd.GeoDataFrame, Dict]): The geometry data (GeoDataFrame or geometry dict).\n        inSR (str): The input spatial reference (default is EPSG:4326).\n        outSR (str): The output spatial reference (default is EPSG:3857).\n        digit (int): The digit code for the WBD layer (default is 8).\n        spatialRel (str): The spatial relationship (default is \"esriSpatialRelIntersects\").\n        return_geometry (bool): Whether to return the geometry (default is True).\n        outFields (str): The fields to be returned (default is \"*\").\n        output (Optional[str]): The output file path to save the GeoDataFrame (default is None).\n        **kwargs: Additional keyword arguments to pass to the API.\n\n    Returns:\n        gpd.GeoDataFrame or pd.DataFrame: The queried WBD data as a GeoDataFrame or DataFrame.\n    \"\"\"\n\n    import geopandas as gpd\n    import pandas as pd\n    from shapely.geometry import Polygon\n\n    def detect_geometry_type(geometry):\n        \"\"\"\n        Automatically detect the geometry type based on the structure of the geometry dictionary.\n        \"\"\"\n        if \"x\" in geometry and \"y\" in geometry:\n            return \"esriGeometryPoint\"\n        elif (\n            \"xmin\" in geometry\n            and \"ymin\" in geometry\n            and \"xmax\" in geometry\n            and \"ymax\" in geometry\n        ):\n            return \"esriGeometryEnvelope\"\n        elif \"rings\" in geometry:\n            return \"esriGeometryPolygon\"\n        elif \"paths\" in geometry:\n            return \"esriGeometryPolyline\"\n        elif \"points\" in geometry:\n            return \"esriGeometryMultipoint\"\n        else:\n            raise ValueError(\"Unsupported geometry type or invalid geometry structure.\")\n\n    allowed_digit_values = [2, 4, 6, 8, 10, 12, 14, 16]\n    if digit not in allowed_digit_values:\n        raise ValueError(\n            f\"Invalid digit value. Allowed values are {allowed_digit_values}\"\n        )\n\n    layer = allowed_digit_values.index(digit) + 1\n\n    # Convert GeoDataFrame to a dictionary if needed\n    if isinstance(geometry, gpd.GeoDataFrame):\n        geometry_dict = _convert_geodataframe_to_esri_format(geometry)[0]\n        geometry_type = detect_geometry_type(geometry_dict)\n    elif isinstance(geometry, dict):\n        geometry_type = detect_geometry_type(geometry)\n        geometry_dict = geometry\n    elif isinstance(geometry, str):\n        geometry_dict = geometry\n    elif searchText is None:\n        raise ValueError(\n            \"Invalid geometry input. Must be a GeoDataFrame or a dictionary.\"\n        )\n    else:\n        geometry_dict = None\n\n    if geometry_dict is not None:\n        # Convert geometry to a JSON string (required by the API)\n        if isinstance(geometry_dict, dict):\n            geometry_json = json.dumps(geometry_dict)\n        else:\n            geometry_json = geometry_dict\n\n        # Construct the query parameters\n        params = {\n            \"geometry\": geometry_json,\n            \"geometryType\": geometry_type,\n            \"inSR\": inSR,\n            \"spatialRel\": spatialRel,\n            \"outFields\": outFields,\n            \"returnGeometry\": str(return_geometry).lower(),\n            \"f\": \"json\",\n        }\n        # API URL for querying the WBD\n        url = f\"https://hydro.nationalmap.gov/arcgis/rest/services/wbd/MapServer/{layer}/query\"\n    else:\n        # Construct the query parameters\n        params = {\n            \"searchText\": searchText,\n            \"contains\": \"true\",\n            \"layers\": str(layer),\n            \"inSR\": inSR,\n            \"outFields\": outFields,\n            \"returnGeometry\": str(return_geometry).lower(),\n            \"f\": \"json\",\n        }\n        url = f\"https://hydro.nationalmap.gov/arcgis/rest/services/wbd/MapServer/find\"\n\n    # Add additional keyword arguments\n    for key, value in kwargs.items():\n        params[key] = value\n\n    # Make the GET request\n    response = requests.get(url, params=params)\n\n    if response.status_code != 200:\n        return {\"error\": f\"Request failed with status code {response.status_code}\"}\n\n    data = response.json()\n\n    if geometry_dict is not None:\n        # Extract features from the API response\n        features = data.get(\"features\", [])\n        crs = f\"EPSG:{data['spatialReference']['latestWkid']}\"\n    else:\n        features = data.get(\"results\", [])\n        crs = f\"EPSG:{data['results'][0]['geometry']['spatialReference']['latestWkid']}\"\n\n    # Prepare attribute data and geometries\n    attributes = [feature[\"attributes\"] for feature in features]\n    df = pd.DataFrame(attributes)\n    df.rename(\n        columns={\"Shape__Length\": \"Shape_Length\", \"Shape__Area\": \"Shape_Area\"},\n        inplace=True,\n    )\n\n    # Handle geometries\n    if return_geometry:\n        geometries = [\n            (\n                Polygon(feature[\"geometry\"][\"rings\"][0])\n                if \"rings\" in feature[\"geometry\"]\n                else None\n            )\n            for feature in features\n        ]\n        gdf = gpd.GeoDataFrame(\n            df,\n            geometry=geometries,\n            crs=crs,\n        )\n        if outSR != \"3857\":\n            gdf = gdf.to_crs(outSR)\n\n        if output is not None:\n            gdf.to_file(output)\n\n        return gdf\n    else:\n        return df\n</code></pre>"},{"location":"common/#beamgis.common.get_wms_layers","title":"<code>get_wms_layers(url)</code>","text":"<p>Returns a list of WMS layers from a WMS service.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the WMS service.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of WMS layers.</p> Source code in <code>beamgis/common.py</code> <pre><code>def get_wms_layers(url):\n    \"\"\"Returns a list of WMS layers from a WMS service.\n\n    Args:\n        url (str): The URL of the WMS service.\n\n    Returns:\n        list: A list of WMS layers.\n    \"\"\"\n    try:\n        from owslib.wms import WebMapService\n    except ImportError:\n        raise ImportError(\"Please install owslib using 'pip install owslib'.\")\n\n    wms = WebMapService(url)\n    layers = list(wms.contents)\n    layers.sort()\n    return layers\n</code></pre>"},{"location":"common/#beamgis.common.gif_fading","title":"<code>gif_fading(in_gif, out_gif, duration=1, verbose=True)</code>","text":"<p>Fade in/out the gif.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The input gif file. Can be a directory path or http URL, e.g., \"https://i.imgur.com/ZWSZC5z.gif\"</p> required <code>out_gif</code> <code>str</code> <p>The output gif file.</p> required <code>duration</code> <code>float</code> <p>The duration of the fading. Defaults to 1.</p> <code>1</code> <code>verbose</code> <code>bool</code> <p>Whether to print the progress. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>Raise exception when the input gif does not exist.</p> <code>Exception</code> <p>Raise exception when ffmpeg is not installed.</p> Source code in <code>beamgis/common.py</code> <pre><code>def gif_fading(in_gif, out_gif, duration=1, verbose=True):\n    \"\"\"Fade in/out the gif.\n\n    Args:\n        in_gif (str): The input gif file. Can be a directory path or http URL, e.g., \"https://i.imgur.com/ZWSZC5z.gif\"\n        out_gif (str): The output gif file.\n        duration (float, optional): The duration of the fading. Defaults to 1.\n        verbose (bool, optional): Whether to print the progress. Defaults to True.\n\n    Raises:\n        FileNotFoundError: Raise exception when the input gif does not exist.\n        Exception: Raise exception when ffmpeg is not installed.\n    \"\"\"\n    import glob\n    import tempfile\n\n    current_dir = os.getcwd()\n\n    if isinstance(in_gif, str) and in_gif.startswith(\"http\"):\n        ext = os.path.splitext(in_gif)[1]\n        file_path = temp_file_path(ext)\n        download_from_url(in_gif, file_path, verbose=verbose)\n        in_gif = file_path\n\n    in_gif = os.path.abspath(in_gif)\n    if not in_gif.endswith(\".gif\"):\n        raise Exception(\"in_gif must be a gif file.\")\n\n    if \" \" in in_gif:\n        raise Exception(\"The filename cannot contain spaces.\")\n\n    out_gif = os.path.abspath(out_gif)\n    if not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    if not os.path.exists(in_gif):\n        raise FileNotFoundError(f\"{in_gif} does not exist.\")\n\n    basename = os.path.basename(in_gif).replace(\".gif\", \"\")\n    temp_dir = os.path.join(tempfile.gettempdir(), basename)\n    if os.path.exists(temp_dir):\n        shutil.rmtree(temp_dir)\n\n    gif_to_png(in_gif, temp_dir, verbose=verbose)\n\n    os.chdir(temp_dir)\n\n    images = list(glob.glob(os.path.join(temp_dir, \"*.png\")))\n    count = len(images)\n\n    files = []\n    for i in range(1, count + 1):\n        files.append(f\"-loop 1 -t {duration} -i {i}.png\")\n    inputs = \" \".join(files)\n\n    filters = []\n    for i in range(1, count):\n        if i == 1:\n            filters.append(\n                f\"\\\"[1:v][0:v]blend=all_expr='A*(if(gte(T,3),1,T/3))+B*(1-(if(gte(T,3),1,T/3)))'[v0];\"\n            )\n        else:\n            filters.append(\n                f\"[{i}:v][{i-1}:v]blend=all_expr='A*(if(gte(T,3),1,T/3))+B*(1-(if(gte(T,3),1,T/3)))'[v{i-1}];\"\n            )\n\n    last_filter = \"\"\n    for i in range(count - 1):\n        last_filter += f\"[v{i}]\"\n    last_filter += f'concat=n={count-1}:v=1:a=0[v]\" -map \"[v]\"'\n    filters.append(last_filter)\n    filters = \" \".join(filters)\n\n    cmd = f\"ffmpeg -y -loglevel error {inputs} -filter_complex {filters} {out_gif}\"\n\n    os.system(cmd)\n    try:\n        shutil.rmtree(temp_dir)\n    except Exception as e:\n        print(e)\n\n    os.chdir(current_dir)\n</code></pre>"},{"location":"common/#beamgis.common.gif_to_mp4","title":"<code>gif_to_mp4(in_gif, out_mp4)</code>","text":"<p>Converts a gif to mp4.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The input gif file.</p> required <code>out_mp4</code> <code>str</code> <p>The output mp4 file.</p> required Source code in <code>beamgis/common.py</code> <pre><code>def gif_to_mp4(in_gif, out_mp4):\n    \"\"\"Converts a gif to mp4.\n\n    Args:\n        in_gif (str): The input gif file.\n        out_mp4 (str): The output mp4 file.\n    \"\"\"\n    from PIL import Image\n\n    if not os.path.exists(in_gif):\n        raise FileNotFoundError(f\"{in_gif} does not exist.\")\n\n    out_mp4 = os.path.abspath(out_mp4)\n    if not out_mp4.endswith(\".mp4\"):\n        out_mp4 = out_mp4 + \".mp4\"\n\n    if not os.path.exists(os.path.dirname(out_mp4)):\n        os.makedirs(os.path.dirname(out_mp4))\n\n    if not is_tool(\"ffmpeg\"):\n        print(\"ffmpeg is not installed on your computer.\")\n        return\n\n    width, height = Image.open(in_gif).size\n\n    if width % 2 == 0 and height % 2 == 0:\n        cmd = f\"ffmpeg -loglevel error -i {in_gif} -vcodec libx264 -crf 25 -pix_fmt yuv420p {out_mp4}\"\n        os.system(cmd)\n    else:\n        width += width % 2\n        height += height % 2\n        cmd = f\"ffmpeg -loglevel error -i {in_gif} -vf scale={width}:{height} -vcodec libx264 -crf 25 -pix_fmt yuv420p {out_mp4}\"\n        os.system(cmd)\n\n    if not os.path.exists(out_mp4):\n        raise Exception(f\"Failed to create mp4 file.\")\n</code></pre>"},{"location":"common/#beamgis.common.gif_to_png","title":"<code>gif_to_png(in_gif, out_dir=None, prefix='', verbose=True)</code>","text":"<p>Converts a gif to png.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The input gif file.</p> required <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>The prefix of the output png files. Defaults to None.</p> <code>''</code> <code>verbose</code> <code>bool</code> <p>Whether to print the progress. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>Raise exception when the input gif does not exist.</p> <code>Exception</code> <p>Raise exception when ffmpeg is not installed.</p> Source code in <code>beamgis/common.py</code> <pre><code>def gif_to_png(in_gif, out_dir=None, prefix=\"\", verbose=True):\n    \"\"\"Converts a gif to png.\n\n    Args:\n        in_gif (str): The input gif file.\n        out_dir (str, optional): The output directory. Defaults to None.\n        prefix (str, optional): The prefix of the output png files. Defaults to None.\n        verbose (bool, optional): Whether to print the progress. Defaults to True.\n\n    Raises:\n        FileNotFoundError: Raise exception when the input gif does not exist.\n        Exception: Raise exception when ffmpeg is not installed.\n    \"\"\"\n    import tempfile\n\n    in_gif = os.path.abspath(in_gif)\n    if \" \" in in_gif:\n        raise Exception(\"in_gif cannot contain spaces.\")\n    if not os.path.exists(in_gif):\n        raise FileNotFoundError(f\"{in_gif} does not exist.\")\n\n    basename = os.path.basename(in_gif).replace(\".gif\", \"\")\n    if out_dir is None:\n        out_dir = os.path.join(tempfile.gettempdir(), basename)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n    elif isinstance(out_dir, str) and not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n    elif not isinstance(out_dir, str):\n        raise Exception(\"out_dir must be a string.\")\n\n    out_dir = os.path.abspath(out_dir)\n    cmd = f\"ffmpeg -loglevel error -i {in_gif} -vsync 0 {out_dir}/{prefix}%d.png\"\n    os.system(cmd)\n\n    if verbose:\n        print(f\"Images are saved to {out_dir}\")\n</code></pre>"},{"location":"common/#beamgis.common.github_delete_asset","title":"<code>github_delete_asset(username, repository, asset_id, access_token=None)</code>","text":"<p>Deletes an asset from a GitHub release.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>GitHub username or organization name.</p> required <code>repository</code> <code>str</code> <p>Name of the GitHub repository.</p> required <code>asset_id</code> <code>int</code> <p>ID of the asset to delete.</p> required <code>access_token</code> <code>str</code> <p>Personal access token for authentication.</p> <code>None</code> Source code in <code>beamgis/common.py</code> <pre><code>def github_delete_asset(username, repository, asset_id, access_token=None):\n    \"\"\"\n    Deletes an asset from a GitHub release.\n\n    Args:\n        username (str): GitHub username or organization name.\n        repository (str): Name of the GitHub repository.\n        asset_id (int): ID of the asset to delete.\n        access_token (str): Personal access token for authentication.\n    \"\"\"\n    if access_token is None:\n        access_token = get_api_key(\"GITHUB_API_TOKEN\")\n    url = f\"https://api.github.com/repos/{username}/{repository}/releases/assets/{asset_id}\"\n    headers = {\n        \"Authorization\": f\"token {access_token}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n\n    response = requests.delete(url, headers=headers)\n\n    if response.status_code == 204:\n        print(f\"Successfully deleted asset ID: {asset_id}\")\n    else:\n        print(f\"Error: Unable to delete asset (Status code: {response.status_code})\")\n</code></pre>"},{"location":"common/#beamgis.common.github_get_release_assets","title":"<code>github_get_release_assets(username, repository, release_id, access_token=None)</code>","text":"<p>Fetches the assets for a given release.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>GitHub username or organization name.</p> required <code>repository</code> <code>str</code> <p>Name of the GitHub repository.</p> required <code>release_id</code> <code>int</code> <p>ID of the release to fetch assets for.</p> required <code>access_token</code> <code>str</code> <p>Personal access token for authentication.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>List of assets if successful, None otherwise.</p> Source code in <code>beamgis/common.py</code> <pre><code>def github_get_release_assets(username, repository, release_id, access_token=None):\n    \"\"\"\n    Fetches the assets for a given release.\n\n    Args:\n        username (str): GitHub username or organization name.\n        repository (str): Name of the GitHub repository.\n        release_id (int): ID of the release to fetch assets for.\n        access_token (str): Personal access token for authentication.\n\n    Returns:\n        list: List of assets if successful, None otherwise.\n    \"\"\"\n    if access_token is None:\n        access_token = get_api_key(\"GITHUB_API_TOKEN\")\n    url = f\"https://api.github.com/repos/{username}/{repository}/releases/{release_id}/assets\"\n    headers = {\n        \"Authorization\": f\"token {access_token}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n\n    response = requests.get(url, headers=headers)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        print(f\"Error: Unable to fetch assets (Status code: {response.status_code})\")\n        return None\n</code></pre>"},{"location":"common/#beamgis.common.github_get_release_id_by_tag","title":"<code>github_get_release_id_by_tag(username, repository, tag_name, access_token=None)</code>","text":"<p>Fetches the release ID by tag name for a given GitHub repository.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>GitHub username or organization name.</p> required <code>repository</code> <code>str</code> <p>Name of the GitHub repository.</p> required <code>tag_name</code> <code>str</code> <p>Tag name of the release.</p> required <code>access_token</code> <code>str</code> <p>Personal access token for authentication. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The release ID if found, None otherwise.</p> Source code in <code>beamgis/common.py</code> <pre><code>def github_get_release_id_by_tag(username, repository, tag_name, access_token=None):\n    \"\"\"\n    Fetches the release ID by tag name for a given GitHub repository.\n\n    Args:\n        username (str): GitHub username or organization name.\n        repository (str): Name of the GitHub repository.\n        tag_name (str): Tag name of the release.\n        access_token (str, optional): Personal access token for authentication. Defaults to None.\n\n    Returns:\n        int: The release ID if found, None otherwise.\n    \"\"\"\n\n    if access_token is None:\n        access_token = get_api_key(\"GITHUB_API_TOKEN\")\n\n    # GitHub API URL for fetching releases\n    url = (\n        f\"https://api.github.com/repos/{username}/{repository}/releases/tags/{tag_name}\"\n    )\n\n    # Headers for authentication (optional)\n    headers = {\"Authorization\": f\"token {access_token}\"} if access_token else {}\n\n    # Make the request to the GitHub API\n    response = requests.get(url, headers=headers)\n\n    # Check if the request was successful\n    if response.status_code == 200:\n        release_info = response.json()\n        return release_info.get(\"id\")\n    else:\n        print(\n            f\"Error: Unable to fetch release info for tag {tag_name} (Status code: {response.status_code})\"\n        )\n        return None\n</code></pre>"},{"location":"common/#beamgis.common.github_raw_url","title":"<code>github_raw_url(url)</code>","text":"<p>Get the raw URL for a GitHub file.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The GitHub URL.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The raw URL.</p> Source code in <code>beamgis/common.py</code> <pre><code>def github_raw_url(url):\n    \"\"\"Get the raw URL for a GitHub file.\n\n    Args:\n        url (str): The GitHub URL.\n    Returns:\n        str: The raw URL.\n    \"\"\"\n    if isinstance(url, str) and url.startswith(\"https://github.com/\") and \"blob\" in url:\n        url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n            \"blob/\", \"\"\n        )\n    return url\n</code></pre>"},{"location":"common/#beamgis.common.github_upload_asset_to_release","title":"<code>github_upload_asset_to_release(username, repository, release_id, asset_path, quiet=False, access_token=None)</code>","text":"<p>Uploads an asset to a GitHub release.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>GitHub username or organization name.</p> required <code>repository</code> <code>str</code> <p>Name of the GitHub repository.</p> required <code>release_id</code> <code>int</code> <p>ID of the release to upload the asset to.</p> required <code>asset_path</code> <code>str</code> <p>Path to the asset file.</p> required <code>access_token</code> <code>str</code> <p>Personal access token for authentication.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>The response JSON from the GitHub API if the upload is successful. None: If the upload fails.</p> Source code in <code>beamgis/common.py</code> <pre><code>def github_upload_asset_to_release(\n    username, repository, release_id, asset_path, quiet=False, access_token=None\n):\n    \"\"\"\n    Uploads an asset to a GitHub release.\n\n    Args:\n        username (str): GitHub username or organization name.\n        repository (str): Name of the GitHub repository.\n        release_id (int): ID of the release to upload the asset to.\n        asset_path (str): Path to the asset file.\n\n        access_token (str): Personal access token for authentication.\n\n    Returns:\n        dict: The response JSON from the GitHub API if the upload is successful.\n        None: If the upload fails.\n    \"\"\"\n    if access_token is None:\n        access_token = get_api_key(\"GITHUB_API_TOKEN\")\n    # GitHub API URL for uploading release assets\n    url = f\"https://uploads.github.com/repos/{username}/{repository}/releases/{release_id}/assets\"\n\n    # Extract the filename from the asset path\n    asset_name = os.path.basename(asset_path)\n\n    # Set the headers for the upload request\n    headers = {\n        \"Authorization\": f\"token {access_token}\",\n        \"Content-Type\": \"application/octet-stream\",\n    }\n\n    # Set the parameters for the upload request\n    params = {\"name\": asset_name}\n\n    # Check if the asset already exists\n    assets = github_get_release_assets(username, repository, release_id, access_token)\n    if assets:\n        for asset in assets:\n            if asset[\"name\"] == asset_name:\n                github_delete_asset(username, repository, asset[\"id\"], access_token)\n                break\n\n    # Open the asset file in binary mode\n    with open(asset_path, \"rb\") as asset_file:\n        # Make the request to upload the asset\n        response = requests.post(url, headers=headers, params=params, data=asset_file)\n\n    # Check if the request was successful\n    if response.status_code == 201:\n        print(f\"Successfully uploaded asset: {asset_name}\")\n        if not quiet:\n            return response.json()\n        else:\n            return None\n    else:\n        print(f\"Error: Unable to upload asset (Status code: {response.status_code})\")\n        if not quiet:\n            print(response.json())\n        return None\n</code></pre>"},{"location":"common/#beamgis.common.google_buildings_csv_to_vector","title":"<code>google_buildings_csv_to_vector(filename, output=None, **kwargs)</code>","text":"<p>Convert a CSV file containing Google Buildings data to a GeoJSON vector file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the input CSV file.</p> required <code>output</code> <code>str</code> <p>The path to the output GeoJSON file. If not provided, the output file will have the same name as the input file with the extension changed to '.geojson'.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments that are passed to the <code>to_file</code> method of the GeoDataFrame.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>beamgis/common.py</code> <pre><code>def google_buildings_csv_to_vector(\n    filename: str, output: Optional[str] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Convert a CSV file containing Google Buildings data to a GeoJSON vector file.\n\n    Args:\n        filename (str): The path to the input CSV file.\n        output (str, optional): The path to the output GeoJSON file. If not provided, the output file will have the same\n            name as the input file with the extension changed to '.geojson'.\n        **kwargs: Additional keyword arguments that are passed to the `to_file` method of the GeoDataFrame.\n\n    Returns:\n        None\n    \"\"\"\n    import pandas as pd\n    import geopandas as gpd\n    from shapely import wkt\n\n    df = pd.read_csv(filename)\n\n    # Create a geometry column from the \"geometry\" column in the DataFrame\n    df[\"geometry\"] = df[\"geometry\"].apply(wkt.loads)\n\n    # Convert the pandas DataFrame to a GeoDataFrame\n    gdf = gpd.GeoDataFrame(df, geometry=\"geometry\")\n    gdf.crs = \"EPSG:4326\"\n\n    if output is None:\n        output = os.path.splitext(filename)[0] + \".geojson\"\n\n    gdf.to_file(output, **kwargs)\n</code></pre>"},{"location":"common/#beamgis.common.h5_keys","title":"<code>h5_keys(filename)</code>","text":"<p>Retrieve the keys (dataset names) within an HDF5 file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the HDF5 file.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of dataset names present in the HDF5 file.</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>Raised if h5py is not installed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; keys = h5_keys('data.h5')\n&gt;&gt;&gt; print(keys)\n[\n</code></pre> Source code in <code>beamgis/common.py</code> <pre><code>def h5_keys(filename: str) -&gt; List[str]:\n    \"\"\"\n    Retrieve the keys (dataset names) within an HDF5 file.\n\n    Args:\n        filename (str): The filename of the HDF5 file.\n\n    Returns:\n        List[str]: A list of dataset names present in the HDF5 file.\n\n    Raises:\n        ImportError: Raised if h5py is not installed.\n\n    Example:\n        &gt;&gt;&gt; keys = h5_keys('data.h5')\n        &gt;&gt;&gt; print(keys)\n        [\n    \"\"\"\n    try:\n        import h5py\n    except ImportError:\n        raise ImportError(\n            \"h5py must be installed to use this function. Please install it with 'pip install h5py'.\"\n        )\n\n    with h5py.File(filename, \"r\") as f:\n        keys = list(f.keys())\n\n    return keys\n</code></pre>"},{"location":"common/#beamgis.common.h5_to_gdf","title":"<code>h5_to_gdf(filenames, dataset, lat='lat_lowestmode', lon='lon_lowestmode', columns=None, crs='EPSG:4326', nodata=None, **kwargs)</code>","text":"<p>Read data from one or multiple HDF5 files and return as a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>filenames</code> <code>str or List[str]</code> <p>The filename(s) of the HDF5 file(s).</p> required <code>dataset</code> <code>str</code> <p>The dataset name within the H5 file(s).</p> required <code>lat</code> <code>str</code> <p>The column name representing latitude. Default is 'lat_lowestmode'.</p> <code>'lat_lowestmode'</code> <code>lon</code> <code>str</code> <p>The column name representing longitude. Default is 'lon_lowestmode'.</p> <code>'lon_lowestmode'</code> <code>columns</code> <code>List[str]</code> <p>List of column names to include. If None, all columns will be included. Default is None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The coordinate reference system code. Default is \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the GeoDataFrame constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>A GeoDataFrame containing the data from the H5 file(s).</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>Raised if h5py is not installed.</p> <code>ValueError</code> <p>Raised if the provided filenames argument is not a valid type or if a specified file does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = h5_to_gdf('data.h5', 'dataset1', 'lat', 'lon', columns=['column1', 'column2'], crs='EPSG:4326')\n&gt;&gt;&gt; print(gdf.head())\n   column1  column2        lat        lon                    geometry\n0        10       20  40.123456 -75.987654  POINT (-75.987654 40.123456)\n1        15       25  40.234567 -75.876543  POINT (-75.876543 40.234567)\n...\n</code></pre> Source code in <code>beamgis/common.py</code> <pre><code>def h5_to_gdf(\n    filenames: str,\n    dataset: str,\n    lat: str = \"lat_lowestmode\",\n    lon: str = \"lon_lowestmode\",\n    columns: Optional[List[str]] = None,\n    crs: str = \"EPSG:4326\",\n    nodata=None,\n    **kwargs,\n):\n    \"\"\"\n    Read data from one or multiple HDF5 files and return as a GeoDataFrame.\n\n    Args:\n        filenames (str or List[str]): The filename(s) of the HDF5 file(s).\n        dataset (str): The dataset name within the H5 file(s).\n        lat (str): The column name representing latitude. Default is 'lat_lowestmode'.\n        lon (str): The column name representing longitude. Default is 'lon_lowestmode'.\n        columns (List[str], optional): List of column names to include. If None, all columns will be included. Default is None.\n        crs (str, optional): The coordinate reference system code. Default is \"EPSG:4326\".\n        **kwargs: Additional keyword arguments to be passed to the GeoDataFrame constructor.\n\n    Returns:\n        geopandas.GeoDataFrame: A GeoDataFrame containing the data from the H5 file(s).\n\n    Raises:\n        ImportError: Raised if h5py is not installed.\n        ValueError: Raised if the provided filenames argument is not a valid type or if a specified file does not exist.\n\n    Example:\n        &gt;&gt;&gt; gdf = h5_to_gdf('data.h5', 'dataset1', 'lat', 'lon', columns=['column1', 'column2'], crs='EPSG:4326')\n        &gt;&gt;&gt; print(gdf.head())\n           column1  column2        lat        lon                    geometry\n        0        10       20  40.123456 -75.987654  POINT (-75.987654 40.123456)\n        1        15       25  40.234567 -75.876543  POINT (-75.876543 40.234567)\n        ...\n\n    \"\"\"\n    try:\n        import h5py\n    except ImportError:\n        install_package(\"h5py\")\n        import h5py\n\n    import glob\n    import pandas as pd\n    import geopandas as gpd\n\n    if isinstance(filenames, str):\n        if os.path.exists(filenames):\n            files = [filenames]\n        else:\n            files = glob.glob(filenames)\n            if not files:\n                raise ValueError(f\"File {filenames} does not exist.\")\n            files.sort()\n    elif isinstance(filenames, list):\n        files = filenames\n    else:\n        raise ValueError(\"h5_file must be a string or a list of strings.\")\n\n    out_df = pd.DataFrame()\n\n    for file in files:\n        h5 = h5py.File(file, \"r\")\n        try:\n            data = h5[dataset]\n        except KeyError:\n            print(f\"Dataset {dataset} not found in file {file}. Skipping...\")\n            continue\n        col_names = []\n        col_val = []\n\n        for key, value in data.items():\n            if columns is None or key in columns or key == lat or key == lon:\n                col_names.append(key)\n                col_val.append(value[:].tolist())\n\n        df = pd.DataFrame(map(list, zip(*col_val)), columns=col_names)\n        out_df = pd.concat([out_df, df])\n        h5.close()\n\n    if nodata is not None and columns is not None:\n        out_df = out_df[out_df[columns[0]] != nodata]\n\n    gdf = gpd.GeoDataFrame(\n        out_df, geometry=gpd.points_from_xy(out_df[lon], out_df[lat]), crs=crs, **kwargs\n    )\n\n    return gdf\n</code></pre>"},{"location":"common/#beamgis.common.h5_variables","title":"<code>h5_variables(filename, key)</code>","text":"<p>Retrieve the variables (column names) within a specific key (dataset) in an H5 file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the H5 file.</p> required <code>key</code> <code>str</code> <p>The key (dataset name) within the H5 file.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of variable names (column names) within the specified key.</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>Raised if h5py is not installed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; variables = h5_variables('data.h5', 'dataset1')\n&gt;&gt;&gt; print(variables)\n['var1', 'var2', 'var3']\n</code></pre> Source code in <code>beamgis/common.py</code> <pre><code>def h5_variables(filename: str, key: str) -&gt; List[str]:\n    \"\"\"\n    Retrieve the variables (column names) within a specific key (dataset) in an H5 file.\n\n    Args:\n        filename (str): The filename of the H5 file.\n        key (str): The key (dataset name) within the H5 file.\n\n    Returns:\n        List[str]: A list of variable names (column names) within the specified key.\n\n    Raises:\n        ImportError: Raised if h5py is not installed.\n\n    Example:\n        &gt;&gt;&gt; variables = h5_variables('data.h5', 'dataset1')\n        &gt;&gt;&gt; print(variables)\n        ['var1', 'var2', 'var3']\n    \"\"\"\n    try:\n        import h5py\n    except ImportError:\n        raise ImportError(\n            \"h5py must be installed to use this function. Please install it with 'pip install h5py'.\"\n        )\n\n    with h5py.File(filename, \"r\") as f:\n        cols = list(f[key].keys())\n\n    return cols\n</code></pre>"},{"location":"common/#beamgis.common.has_transparency","title":"<code>has_transparency(img)</code>","text":"<p>Checks whether an image has transparency.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>a PIL Image object.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if it has transparency, False otherwise.</p> Source code in <code>beamgis/common.py</code> <pre><code>def has_transparency(img) -&gt; bool:\n    \"\"\"Checks whether an image has transparency.\n\n    Args:\n        img (object):  a PIL Image object.\n\n    Returns:\n        bool: True if it has transparency, False otherwise.\n    \"\"\"\n\n    if img.mode == \"P\":\n        transparent = img.info.get(\"transparency\", -1)\n        for _, index in img.getcolors():\n            if index == transparent:\n                return True\n    elif img.mode == \"RGBA\":\n        extrema = img.getextrema()\n        if extrema[3][0] &lt; 255:\n            return True\n\n    return False\n</code></pre>"},{"location":"common/#beamgis.common.hex_to_rgb","title":"<code>hex_to_rgb(value='FFFFFF')</code>","text":"<p>Converts hex color to RGB color.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Hex color code as a string. Defaults to 'FFFFFF'.</p> <code>'FFFFFF'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>RGB color as a tuple.</p> Source code in <code>beamgis/common.py</code> <pre><code>def hex_to_rgb(value: Optional[str] = \"FFFFFF\") -&gt; Tuple[int, int, int]:\n    \"\"\"Converts hex color to RGB color.\n\n    Args:\n        value (str, optional): Hex color code as a string. Defaults to 'FFFFFF'.\n\n    Returns:\n        tuple: RGB color as a tuple.\n    \"\"\"\n    value = value.lstrip(\"#\")\n    lv = len(value)\n    return tuple(int(value[i : i + lv // 3], 16) for i in range(0, lv, lv // 3))\n</code></pre>"},{"location":"common/#beamgis.common.html_to_gradio","title":"<code>html_to_gradio(html, width='100%', height='500px', **kwargs)</code>","text":"<p>Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as     attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>str</code> <p>The width of the map. Defaults to '100%'.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>The height of the map. Defaults to '500px'.</p> <code>'500px'</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML string to use in Gradio.</p> Source code in <code>beamgis/common.py</code> <pre><code>def html_to_gradio(html, width=\"100%\", height=\"500px\", **kwargs):\n    \"\"\"Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as\n        attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190\n\n    Args:\n        width (str, optional): The width of the map. Defaults to '100%'.\n        height (str, optional): The height of the map. Defaults to '500px'.\n\n    Returns:\n        str: The HTML string to use in Gradio.\n    \"\"\"\n\n    if isinstance(width, int):\n        width = f\"{width}px\"\n\n    if isinstance(height, int):\n        height = f\"{height}px\"\n\n    if isinstance(html, str):\n        with open(html, \"r\") as f:\n            lines = f.readlines()\n    elif isinstance(html, list):\n        lines = html\n    else:\n        raise TypeError(\"html must be a file path or a list of strings\")\n\n    output = []\n    skipped_lines = []\n    for index, line in enumerate(lines):\n        if index in skipped_lines:\n            continue\n        if line.lstrip().startswith('{\"attribution\":'):\n            continue\n        elif \"on(L.Draw.Event.CREATED, function(e)\" in line:\n            for i in range(14):\n                skipped_lines.append(index + i)\n        elif \"L.Control.geocoder\" in line:\n            for i in range(5):\n                skipped_lines.append(index + i)\n        elif \"function(e)\" in line:\n            print(\n                f\"Warning: The folium plotting backend does not support functions in code blocks. Please delete line {index + 1}.\"\n            )\n        else:\n            output.append(line + \"\\n\")\n\n    return f\"\"\"&lt;iframe style=\"width: {width}; height: {height}\" name=\"result\" allow=\"midi; geolocation; microphone; camera;\n    display-capture; encrypted-media;\" sandbox=\"allow-modals allow-forms\n    allow-scripts allow-same-origin allow-popups\n    allow-top-navigation-by-user-activation allow-downloads\" allowfullscreen=\"\"\n    allowpaymentrequest=\"\" frameborder=\"0\" srcdoc='{\"\".join(output)}'&gt;&lt;/iframe&gt;\"\"\"\n</code></pre>"},{"location":"common/#beamgis.common.html_to_streamlit","title":"<code>html_to_streamlit(html, width=800, height=600, responsive=True, scrolling=False, token_name=None, token_value=None, **kwargs)</code>","text":"<p>Renders an HTML file in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>The HTML file to render. It can a local file path or a URL.</p> required <code>width</code> <code>int</code> <p>Width of the map. Defaults to 800.</p> <code>800</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>600</code> <code>responsive</code> <code>bool</code> <p>Whether to make the map responsive. Defaults to True.</p> <code>True</code> <code>scrolling</code> <code>bool</code> <p>Whether to allow the map to scroll. Defaults to False.</p> <code>False</code> <code>token_name</code> <code>str</code> <p>The name of the token in the HTML file to be replaced. Defaults to None.</p> <code>None</code> <code>token_value</code> <code>str</code> <p>The value of the token to pass to the HTML file. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>streamlit.components</code> <p>components.html object.</p> Source code in <code>beamgis/common.py</code> <pre><code>def html_to_streamlit(\n    html,\n    width=800,\n    height=600,\n    responsive=True,\n    scrolling=False,\n    token_name=None,\n    token_value=None,\n    **kwargs,\n):\n    \"\"\"Renders an HTML file in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.\n\n    Args:\n        html (str): The HTML file to render. It can a local file path or a URL.\n        width (int, optional): Width of the map. Defaults to 800.\n        height (int, optional): Height of the map. Defaults to 600.\n        responsive (bool, optional): Whether to make the map responsive. Defaults to True.\n        scrolling (bool, optional): Whether to allow the map to scroll. Defaults to False.\n        token_name (str, optional): The name of the token in the HTML file to be replaced. Defaults to None.\n        token_value (str, optional): The value of the token to pass to the HTML file. Defaults to None.\n\n    Returns:\n        streamlit.components: components.html object.\n    \"\"\"\n\n    try:\n        import streamlit as st  # pylint: disable=E0401\n        import streamlit.components.v1 as components  # pylint: disable=E0401\n\n        if isinstance(html, str):\n            temp_path = None\n            if html.startswith(\"http\") and html.endswith(\".html\"):\n                temp_path = temp_file_path(\".html\")\n                out_file = os.path.basename(temp_path)\n                out_dir = os.path.dirname(temp_path)\n                download_from_url(html, out_file, out_dir)\n                html = temp_path\n\n            elif not os.path.exists(html):\n                raise FileNotFoundError(\"The specified input html does not exist.\")\n\n            with open(html) as f:\n                lines = f.readlines()\n                if (token_name is not None) and (token_value is not None):\n                    lines = [line.replace(token_name, token_value) for line in lines]\n                html_str = \"\".join(lines)\n\n            if temp_path is not None:\n                os.remove(temp_path)\n\n            if responsive:\n                make_map_responsive = \"\"\"\n                &lt;style&gt;\n                [title~=\"st.iframe\"] { width: 100%}\n                &lt;/style&gt;\n                \"\"\"\n                st.markdown(make_map_responsive, unsafe_allow_html=True)\n            return components.html(\n                html_str, width=width, height=height, scrolling=scrolling\n            )\n        else:\n            raise TypeError(\"The html must be a string.\")\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.image_bandcount","title":"<code>image_bandcount(image, **kwargs)</code>","text":"<p>Get the number of bands in an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of bands in the image.</p> Source code in <code>beamgis/common.py</code> <pre><code>def image_bandcount(image, **kwargs):\n    \"\"\"Get the number of bands in an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        int: The number of bands in the image.\n    \"\"\"\n\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return len(client.metadata()[\"bands\"])\n</code></pre>"},{"location":"common/#beamgis.common.image_bounds","title":"<code>image_bounds(image, **kwargs)</code>","text":"<p>Get the bounds of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of bounds in the form of [(south, west), (north, east)].</p> Source code in <code>beamgis/common.py</code> <pre><code>def image_bounds(image, **kwargs):\n    \"\"\"Get the bounds of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        list: A list of bounds in the form of [(south, west), (north, east)].\n    \"\"\"\n\n    image_check(image)\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    bounds = client.bounds()\n    return [(bounds[0], bounds[2]), (bounds[1], bounds[3])]\n</code></pre>"},{"location":"common/#beamgis.common.image_center","title":"<code>image_center(image, **kwargs)</code>","text":"<p>Get the center of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (latitude, longitude).</p> Source code in <code>beamgis/common.py</code> <pre><code>def image_center(image, **kwargs):\n    \"\"\"Get the center of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        tuple: A tuple of (latitude, longitude).\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.center()\n</code></pre>"},{"location":"common/#beamgis.common.image_client","title":"<code>image_client(image, **kwargs)</code>","text":"<p>Get a LocalTileserver TileClient from an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>TileClient</code> <p>A LocalTileserver TileClient.</p> Source code in <code>beamgis/common.py</code> <pre><code>def image_client(image, **kwargs):\n    \"\"\"Get a LocalTileserver TileClient from an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        TileClient: A LocalTileserver TileClient.\n    \"\"\"\n    image_check(image)\n\n    _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    return client\n</code></pre>"},{"location":"common/#beamgis.common.image_comparison","title":"<code>image_comparison(img1, img2, label1='1', label2='2', width=704, show_labels=True, starting_position=50, make_responsive=True, in_memory=True, out_html=None)</code>","text":"<p>Create a comparison slider for two images. The source code is adapted from     https://github.com/fcakyon/streamlit-image-comparison. Credits to the GitHub user @fcakyon.     Users can also use https://juxtapose.knightlab.com to create a comparison slider.</p> <p>Parameters:</p> Name Type Description Default <code>img1</code> <code>str</code> <p>Path to the first image. It can be a local file path, a URL, or a numpy array.</p> required <code>img2</code> <code>str</code> <p>Path to the second image. It can be a local file path, a URL, or a numpy array.</p> required <code>label1</code> <code>str</code> <p>Label for the first image. Defaults to \"1\".</p> <code>'1'</code> <code>label2</code> <code>str</code> <p>Label for the second image. Defaults to \"2\".</p> <code>'2'</code> <code>width</code> <code>int</code> <p>Width of the component in pixels. Defaults to 704.</p> <code>704</code> <code>show_labels</code> <code>bool</code> <p>Whether to show labels on the images. Default is True.</p> <code>True</code> <code>starting_position</code> <code>int</code> <p>Starting position of the slider as a percentage (0-100). Default is 50.</p> <code>50</code> <code>make_responsive</code> <code>bool</code> <p>Whether to enable responsive mode. Default is True.</p> <code>True</code> <code>in_memory</code> <code>bool</code> <p>Whether to handle pillow to base64 conversion in memory without saving to local. Default is True.</p> <code>True</code> <code>out_html</code> <code>str</code> <p>Whether to handle pillow to base64 conversion in memory without saving to local. Default is True.</p> <code>None</code> Source code in <code>beamgis/common.py</code> <pre><code>def image_comparison(\n    img1: str,\n    img2: str,\n    label1: str = \"1\",\n    label2: str = \"2\",\n    width: int = 704,\n    show_labels: bool = True,\n    starting_position: int = 50,\n    make_responsive: bool = True,\n    in_memory: bool = True,\n    out_html: str = None,\n):\n    \"\"\"Create a comparison slider for two images. The source code is adapted from\n        https://github.com/fcakyon/streamlit-image-comparison. Credits to the GitHub user @fcakyon.\n        Users can also use https://juxtapose.knightlab.com to create a comparison slider.\n\n    Args:\n        img1 (str): Path to the first image. It can be a local file path, a URL, or a numpy array.\n        img2 (str): Path to the second image. It can be a local file path, a URL, or a numpy array.\n        label1 (str, optional): Label for the first image. Defaults to \"1\".\n        label2 (str, optional): Label for the second image. Defaults to \"2\".\n        width (int, optional): Width of the component in pixels. Defaults to 704.\n        show_labels (bool, optional): Whether to show labels on the images. Default is True.\n        starting_position (int, optional): Starting position of the slider as a percentage (0-100). Default is 50.\n        make_responsive (bool, optional): Whether to enable responsive mode. Default is True.\n        in_memory (bool, optional): Whether to handle pillow to base64 conversion in memory without saving to local. Default is True.\n        out_html (str, optional): Whether to handle pillow to base64 conversion in memory without saving to local. Default is True.\n\n    \"\"\"\n\n    from PIL import Image\n    import base64\n    import io\n    import os\n    import uuid\n    from typing import Union\n    import requests\n    import tempfile\n    import numpy as np\n    from IPython.display import HTML, display\n\n    TEMP_DIR = os.path.join(tempfile.gettempdir(), random_string(6))\n    os.makedirs(TEMP_DIR, exist_ok=True)\n\n    def exif_transpose(image: Image.Image):\n        \"\"\"\n        Transpose a PIL image accordingly if it has an EXIF Orientation tag.\n        Inplace version of https://github.com/python-pillow/Pillow/blob/master/src/PIL/ImageOps.py exif_transpose()\n        :param image: The image to transpose.\n        :return: An image.\n        \"\"\"\n        exif = image.getexif()\n        orientation = exif.get(0x0112, 1)  # default 1\n        if orientation &gt; 1:\n            method = {\n                2: Image.FLIP_LEFT_RIGHT,\n                3: Image.ROTATE_180,\n                4: Image.FLIP_TOP_BOTTOM,\n                5: Image.TRANSPOSE,\n                6: Image.ROTATE_270,\n                7: Image.TRANSVERSE,\n                8: Image.ROTATE_90,\n            }.get(orientation)\n            if method is not None:\n                image = image.transpose(method)\n                del exif[0x0112]\n                image.info[\"exif\"] = exif.tobytes()\n        return image\n\n    def read_image_as_pil(\n        image: Union[Image.Image, str, np.ndarray], exif_fix: bool = False\n    ):\n        \"\"\"\n        Loads an image as PIL.Image.Image.\n        Args:\n            image : Can be image path or url (str), numpy image (np.ndarray) or PIL.Image\n        \"\"\"\n        # https://stackoverflow.com/questions/56174099/how-to-load-images-larger-than-max-image-pixels-with-pil\n        Image.MAX_IMAGE_PIXELS = None\n\n        if isinstance(image, Image.Image):\n            image_pil = image.convert(\"RGB\")\n        elif isinstance(image, str):\n            # read image if str image path is provided\n            try:\n                image_pil = Image.open(\n                    requests.get(image, stream=True).raw\n                    if str(image).startswith(\"http\")\n                    else image\n                ).convert(\"RGB\")\n                if exif_fix:\n                    image_pil = exif_transpose(image_pil)\n            except:  # handle large/tiff image reading\n                try:\n                    import skimage.io\n                except ImportError:\n                    raise ImportError(\n                        \"Please run 'pip install -U scikit-image imagecodecs' for large image handling.\"\n                    )\n                image_sk = skimage.io.imread(image).astype(np.uint8)\n                if len(image_sk.shape) == 2:  # b&amp;w\n                    image_pil = Image.fromarray(image_sk, mode=\"1\").convert(\"RGB\")\n                elif image_sk.shape[2] == 4:  # rgba\n                    image_pil = Image.fromarray(image_sk, mode=\"RGBA\").convert(\"RGB\")\n                elif image_sk.shape[2] == 3:  # rgb\n                    image_pil = Image.fromarray(image_sk, mode=\"RGB\")\n                else:\n                    raise TypeError(\n                        f\"image with shape: {image_sk.shape[3]} is not supported.\"\n                    )\n        elif isinstance(image, np.ndarray):\n            if image.shape[0] &lt; 5:  # image in CHW\n                image = image[:, :, ::-1]\n            image_pil = Image.fromarray(image).convert(\"RGB\")\n        else:\n            raise TypeError(\"read image with 'pillow' using 'Image.open()'\")\n\n        return image_pil\n\n    def pillow_to_base64(image: Image.Image) -&gt; str:\n        \"\"\"\n        Convert a PIL image to a base64-encoded string.\n\n        Parameters\n        ----------\n        image: PIL.Image.Image\n            The image to be converted.\n\n        Returns\n        -------\n        str\n            The base64-encoded string.\n        \"\"\"\n        in_mem_file = io.BytesIO()\n        image.save(in_mem_file, format=\"JPEG\", subsampling=0, quality=100)\n        img_bytes = in_mem_file.getvalue()  # bytes\n        image_str = base64.b64encode(img_bytes).decode(\"utf-8\")\n        base64_src = f\"data:image/jpg;base64,{image_str}\"\n        return base64_src\n\n    def local_file_to_base64(image_path: str) -&gt; str:\n        \"\"\"\n        Convert a local image file to a base64-encoded string.\n\n        Parameters\n        ----------\n        image_path: str\n            The path to the image file.\n\n        Returns\n        -------\n        str\n            The base64-encoded string.\n        \"\"\"\n        file_ = open(image_path, \"rb\")\n        img_bytes = file_.read()\n        image_str = base64.b64encode(img_bytes).decode(\"utf-8\")\n        file_.close()\n        base64_src = f\"data:image/jpg;base64,{image_str}\"\n        return base64_src\n\n    def pillow_local_file_to_base64(image: Image.Image, temp_dir: str):\n        \"\"\"\n        Convert a Pillow image to a base64 string, using a temporary file on disk.\n\n        Parameters\n        ----------\n        image : PIL.Image.Image\n            The Pillow image to convert.\n        temp_dir : str\n            The directory to use for the temporary file.\n\n        Returns\n        -------\n        str\n            A base64-encoded string representing the image.\n        \"\"\"\n        # Create temporary file path using os.path.join()\n        img_path = os.path.join(temp_dir, str(uuid.uuid4()) + \".jpg\")\n\n        # Save image to temporary file\n        image.save(img_path, subsampling=0, quality=100)\n\n        # Convert temporary file to base64 string\n        base64_src = local_file_to_base64(img_path)\n\n        return base64_src\n\n    # Prepare images\n    img1_pillow = read_image_as_pil(img1)\n    img2_pillow = read_image_as_pil(img2)\n\n    img_width, img_height = img1_pillow.size\n    h_to_w = img_height / img_width\n    height = int((width * h_to_w) * 0.95)\n\n    if in_memory:\n        # Convert images to base64 strings\n        img1 = pillow_to_base64(img1_pillow)\n        img2 = pillow_to_base64(img2_pillow)\n    else:\n        # Create base64 strings from temporary files\n        os.makedirs(TEMP_DIR, exist_ok=True)\n        for file_ in os.listdir(TEMP_DIR):\n            if file_.endswith(\".jpg\"):\n                os.remove(os.path.join(TEMP_DIR, file_))\n        img1 = pillow_local_file_to_base64(img1_pillow, TEMP_DIR)\n        img2 = pillow_local_file_to_base64(img2_pillow, TEMP_DIR)\n\n    # Load CSS and JS\n    cdn_path = \"https://cdn.knightlab.com/libs/juxtapose/latest\"\n    css_block = f'&lt;link rel=\"stylesheet\" href=\"{cdn_path}/css/juxtapose.css\"&gt;'\n    js_block = f'&lt;script src=\"{cdn_path}/js/juxtapose.min.js\"&gt;&lt;/script&gt;'\n\n    # write html block\n    htmlcode = f\"\"\"\n        &lt;html&gt;\n        &lt;head&gt;\n        &lt;style&gt;body {{ margin: unset; }}&lt;/style&gt;\n        {css_block}\n        {js_block}\n        &lt;div id=\"foo\" style=\"height: {height}; width: {width or '100%'};\"&gt;&lt;/div&gt;\n        &lt;script&gt;\n        slider = new juxtapose.JXSlider('#foo',\n            [\n                {{\n                    src: '{img1}',\n                    label: '{label1}',\n                }},\n                {{\n                    src: '{img2}',\n                    label: '{label2}',\n                }}\n            ],\n            {{\n                animate: true,\n                showLabels: {'true' if show_labels else 'false'},\n                showCredits: true,\n                startingPosition: \"{starting_position}%\",\n                makeResponsive: {'true' if make_responsive else 'false'},\n            }});\n        &lt;/script&gt;\n        &lt;/head&gt;\n        &lt;/html&gt;\n        \"\"\"\n\n    if out_html is not None:\n        with open(out_html, \"w\") as f:\n            f.write(htmlcode)\n\n    shutil.rmtree(TEMP_DIR)\n\n    display(HTML(htmlcode))\n</code></pre>"},{"location":"common/#beamgis.common.image_filesize","title":"<code>image_filesize(region, cellsize, bands=1, dtype='uint8', unit='MB', source_crs='epsg:4326', dst_crs='epsg:3857', bbox=False)</code>","text":"<p>Calculate the size of an image in a given region and cell size.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>list</code> <p>A bounding box in the format of [minx, miny, maxx, maxy].</p> required <code>cellsize</code> <code>float</code> <p>The resolution of the image.</p> required <code>bands</code> <code>int</code> <p>Number of bands. Defaults to 1.</p> <code>1</code> <code>dtype</code> <code>str</code> <p>Data type, such as unit8, float32. For more info, see https://numpy.org/doc/stable/user/basics.types.html. Defaults to 'uint8'.</p> <code>'uint8'</code> <code>unit</code> <code>str</code> <p>The unit of the output. Defaults to 'MB'.</p> <code>'MB'</code> <code>source_crs</code> <code>str</code> <p>The CRS of the region. Defaults to 'epsg:4326'.</p> <code>'epsg:4326'</code> <code>dst_crs</code> <code>str</code> <p>The destination CRS to calculate the area. Defaults to 'epsg:3857'.</p> <code>'epsg:3857'</code> <code>bbox</code> <code>bool</code> <p>Whether to use the bounding box of the region to calculate the area. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>The size of the image in a given unit.</p> Source code in <code>beamgis/common.py</code> <pre><code>def image_filesize(\n    region,\n    cellsize,\n    bands=1,\n    dtype=\"uint8\",\n    unit=\"MB\",\n    source_crs=\"epsg:4326\",\n    dst_crs=\"epsg:3857\",\n    bbox=False,\n):\n    \"\"\"Calculate the size of an image in a given region and cell size.\n\n    Args:\n        region (list): A bounding box in the format of [minx, miny, maxx, maxy].\n        cellsize (float): The resolution of the image.\n        bands (int, optional): Number of bands. Defaults to 1.\n        dtype (str, optional): Data type, such as unit8, float32. For more info,\n            see https://numpy.org/doc/stable/user/basics.types.html. Defaults to 'uint8'.\n        unit (str, optional): The unit of the output. Defaults to 'MB'.\n        source_crs (str, optional): The CRS of the region. Defaults to 'epsg:4326'.\n        dst_crs (str, optional): The destination CRS to calculate the area. Defaults to 'epsg:3857'.\n        bbox (bool, optional): Whether to use the bounding box of the region to calculate the area. Defaults to False.\n\n    Returns:\n        float: The size of the image in a given unit.\n    \"\"\"\n    import numpy as np\n    import geopandas as gpd\n\n    if bbox:\n        if isinstance(region, gpd.GeoDataFrame):\n            region = region.to_crs(dst_crs).total_bounds.tolist()\n        elif isinstance(region, str) and os.path.exists(region):\n            region = gpd.read_file(region).to_crs(dst_crs).total_bounds.tolist()\n        elif isinstance(region, list):\n            region = (\n                bbox_to_gdf(region, crs=source_crs)\n                .to_crs(dst_crs)\n                .total_bounds.tolist()\n            )\n        else:\n            raise ValueError(\"Invalid input region.\")\n\n        bytes = (\n            np.prod(\n                [\n                    int((region[2] - region[0]) / cellsize),\n                    int((region[3] - region[1]) / cellsize),\n                    bands,\n                ]\n            )\n            * np.dtype(dtype).itemsize\n        )\n    else:\n        if isinstance(region, list):\n            region = bbox_to_gdf(region, crs=source_crs)\n\n        bytes = (\n            vector_area(region, crs=dst_crs)\n            / pow(cellsize, 2)\n            * np.dtype(dtype).itemsize\n            * bands\n        )\n\n    unit = unit.upper()\n\n    if unit == \"KB\":\n        return bytes / 1024\n    elif unit == \"MB\":\n        return bytes / pow(1024, 2)\n    elif unit == \"GB\":\n        return bytes / pow(1024, 3)\n    elif unit == \"TB\":\n        return bytes / pow(1024, 4)\n    elif unit == \"PB\":\n        return bytes / pow(1024, 5)\n    else:\n        return bytes\n</code></pre>"},{"location":"common/#beamgis.common.image_geotransform","title":"<code>image_geotransform(image, **kwargs)</code>","text":"<p>Get the geotransform of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of geotransform values.</p> Source code in <code>beamgis/common.py</code> <pre><code>def image_geotransform(image, **kwargs):\n    \"\"\"Get the geotransform of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        list: A list of geotransform values.\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.metadata()[\"GeoTransform\"]\n</code></pre>"},{"location":"common/#beamgis.common.image_metadata","title":"<code>image_metadata(image, **kwargs)</code>","text":"<p>Get the metadata of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of image metadata.</p> Source code in <code>beamgis/common.py</code> <pre><code>def image_metadata(image, **kwargs):\n    \"\"\"Get the metadata of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        dict: A dictionary of image metadata.\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.metadata\n</code></pre>"},{"location":"common/#beamgis.common.image_min_max","title":"<code>image_min_max(image, bands=None)</code>","text":"<p>Computes the minimum and maximum pixel values of an image.</p> <p>This function opens an image file using xarray and rasterio, optionally     selects specific bands, and then computes the minimum and maximum pixel     values in the image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The path to the image file.</p> required <code>bands</code> <code>int or list</code> <p>The band or list of bands to select. If None, all bands are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>The minimum and maximum pixel values in the image.</p> Source code in <code>beamgis/common.py</code> <pre><code>def image_min_max(\n    image: str, bands: Optional[Union[int, list]] = None\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Computes the minimum and maximum pixel values of an image.\n\n    This function opens an image file using xarray and rasterio, optionally\n        selects specific bands, and then computes the minimum and maximum pixel\n        values in the image.\n\n    Args:\n        image (str): The path to the image file.\n        bands (int or list, optional): The band or list of bands to select. If\n            None, all bands are used.\n\n    Returns:\n        Tuple[float, float]: The minimum and maximum pixel values in the image.\n    \"\"\"\n\n    import rioxarray\n    import xarray as xr\n\n    dataset = xr.open_dataset(image, engine=\"rasterio\")\n\n    if bands is not None:\n        dataset = dataset.sel(band=bands)\n\n    vmin = dataset[\"band_data\"].min().values.item()\n    vmax = dataset[\"band_data\"].max().values.item()\n\n    return vmin, vmax\n</code></pre>"},{"location":"common/#beamgis.common.image_projection","title":"<code>image_projection(image, **kwargs)</code>","text":"<p>Get the projection of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The projection of the image.</p> Source code in <code>beamgis/common.py</code> <pre><code>def image_projection(image, **kwargs):\n    \"\"\"Get the projection of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        str: The projection of the image.\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.metadata()[\"Projection\"]\n</code></pre>"},{"location":"common/#beamgis.common.image_resolution","title":"<code>image_resolution(image, **kwargs)</code>","text":"<p>Get the resolution of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The resolution of the image.</p> Source code in <code>beamgis/common.py</code> <pre><code>def image_resolution(image, **kwargs):\n    \"\"\"Get the resolution of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        float: The resolution of the image.\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.metadata()[\"GeoTransform\"][1]\n</code></pre>"},{"location":"common/#beamgis.common.image_set_crs","title":"<code>image_set_crs(image, epsg)</code>","text":"<p>Define the CRS of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath</p> required <code>epsg</code> <code>int</code> <p>The EPSG code of the CRS to set.</p> required Source code in <code>beamgis/common.py</code> <pre><code>def image_set_crs(image, epsg):\n    \"\"\"Define the CRS of an image.\n\n    Args:\n        image (str): The input image filepath\n        epsg (int): The EPSG code of the CRS to set.\n    \"\"\"\n\n    from rasterio.crs import CRS\n    import rasterio\n\n    with rasterio.open(image, \"r+\") as rds:\n        rds.crs = CRS.from_epsg(epsg)\n</code></pre>"},{"location":"common/#beamgis.common.image_size","title":"<code>image_size(image, **kwargs)</code>","text":"<p>Get the size (width, height) of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (width, height).</p> Source code in <code>beamgis/common.py</code> <pre><code>def image_size(image, **kwargs):\n    \"\"\"Get the size (width, height) of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        tuple: A tuple of (width, height).\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n\n    metadata = client.metadata()\n    return metadata[\"sourceSizeX\"], metadata[\"sourceSizeY\"]\n</code></pre>"},{"location":"common/#beamgis.common.image_to_cog","title":"<code>image_to_cog(source, dst_path=None, profile='deflate', BIGTIFF=None, **kwargs)</code>","text":"<p>Converts an image to a COG file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>A dataset path, URL or rasterio.io.DatasetReader object.</p> required <code>dst_path</code> <code>str</code> <p>An output dataset path or or PathLike object. Defaults to None.</p> <code>None</code> <code>profile</code> <code>str</code> <p>COG profile. More at https://cogeotiff.github.io/rio-cogeo/profile. Defaults to \"deflate\".</p> <code>'deflate'</code> <code>BIGTIFF</code> <code>str</code> <p>Create a BigTIFF file. Can be \"IF_SAFER\" or \"YES\". Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If rio-cogeo is not installed.</p> <code>FileNotFoundError</code> <p>If the source file could not be found.</p> Source code in <code>beamgis/common.py</code> <pre><code>def image_to_cog(source, dst_path=None, profile=\"deflate\", BIGTIFF=None, **kwargs):\n    \"\"\"Converts an image to a COG file.\n\n    Args:\n        source (str): A dataset path, URL or rasterio.io.DatasetReader object.\n        dst_path (str, optional): An output dataset path or or PathLike object. Defaults to None.\n        profile (str, optional): COG profile. More at https://cogeotiff.github.io/rio-cogeo/profile. Defaults to \"deflate\".\n        BIGTIFF (str, optional): Create a BigTIFF file. Can be \"IF_SAFER\" or \"YES\". Defaults to None.\n\n    Raises:\n        ImportError: If rio-cogeo is not installed.\n        FileNotFoundError: If the source file could not be found.\n    \"\"\"\n    try:\n        from rio_cogeo.cogeo import cog_translate\n        from rio_cogeo.profiles import cog_profiles\n\n    except ImportError:\n        raise ImportError(\n            \"The rio-cogeo package is not installed. Please install it with `pip install rio-cogeo` or `conda install rio-cogeo -c conda-forge`.\"\n        )\n\n    if not source.startswith(\"http\"):\n        source = check_file_path(source)\n\n        if not os.path.exists(source):\n            raise FileNotFoundError(\"The provided input file could not be found.\")\n\n    if dst_path is None:\n        if not source.startswith(\"http\"):\n            dst_path = os.path.splitext(source)[0] + \"_cog.tif\"\n        else:\n            dst_path = temp_file_path(extension=\".tif\")\n\n    dst_path = check_file_path(dst_path)\n\n    dst_profile = cog_profiles.get(profile)\n    if \"dst_kwargs\" in kwargs:\n        dst_profile.update(kwargs.pop(\"dst_kwargs\"))\n\n    if BIGTIFF is not None:\n        dst_profile.update({\"BIGTIFF\": BIGTIFF})\n    cog_translate(source, dst_path, dst_profile, **kwargs)\n</code></pre>"},{"location":"common/#beamgis.common.image_to_geotiff","title":"<code>image_to_geotiff(image, dst_path, dtype=None, to_cog=True, **kwargs)</code>","text":"<p>Converts an image to a GeoTIFF file.</p> <p>This function takes an image in the form of a rasterio.io.DatasetReader object, and writes it to a GeoTIFF file at the specified destination path. The data type of the output GeoTIFF can be specified. Additional keyword arguments can be passed to customize the GeoTIFF profile.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>DatasetReader</code> <p>The input image as a rasterio.io.DatasetReader object.</p> required <code>dst_path</code> <code>str</code> <p>The destination path where the GeoTIFF file will be saved.</p> required <code>dtype</code> <code>Optional[str]</code> <p>The data type for the output GeoTIFF file. If None, the data type of the input image will be used. Defaults to None.</p> <code>None</code> <code>to_cog</code> <code>bool</code> <p>Whether to convert the output GeoTIFF to a Cloud Optimized GeoTIFF (COG). Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to be included in the GeoTIFF profile.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the input image is not a rasterio.io.DatasetReader object.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>beamgis/common.py</code> <pre><code>def image_to_geotiff(image, dst_path, dtype=None, to_cog=True, **kwargs) -&gt; None:\n    \"\"\"\n    Converts an image to a GeoTIFF file.\n\n    This function takes an image in the form of a rasterio.io.DatasetReader object, and writes it to a GeoTIFF file\n    at the specified destination path. The data type of the output GeoTIFF can be specified. Additional keyword\n    arguments can be passed to customize the GeoTIFF profile.\n\n    Args:\n        image (DatasetReader): The input image as a rasterio.io.DatasetReader object.\n        dst_path (str): The destination path where the GeoTIFF file will be saved.\n        dtype (Optional[str]): The data type for the output GeoTIFF file. If None, the data type of the input image\n            will be used. Defaults to None.\n        to_cog (bool): Whether to convert the output GeoTIFF to a Cloud Optimized GeoTIFF (COG). Defaults to True.\n        **kwargs: Additional keyword arguments to be included in the GeoTIFF profile.\n\n    Raises:\n        ValueError: If the input image is not a rasterio.io.DatasetReader object.\n\n    Returns:\n        None\n    \"\"\"\n    import rasterio\n    from rasterio.enums import Resampling\n\n    if not isinstance(image, rasterio.io.DatasetReader):\n        raise ValueError(\"The input image must be a rasterio.io.DatasetReader object.\")\n\n    dst_path = check_file_path(dst_path)\n\n    profile = image.profile\n    if dtype is not None:\n        profile[\"dtype\"] = dtype\n\n    for key, value in kwargs.items():\n        profile[key] = value\n\n    with rasterio.open(dst_path, \"w\", **profile) as dst:\n        dst.write(image.read())\n\n    if to_cog:\n        image_to_cog(dst_path, dst_path)\n</code></pre>"},{"location":"common/#beamgis.common.image_to_numpy","title":"<code>image_to_numpy(image)</code>","text":"<p>Converts an image to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>A dataset path, URL or rasterio.io.DatasetReader object.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the provided file could not be found.</p> <p>Returns:</p> Type Description <code>np.array</code> <p>A numpy array.</p> Source code in <code>beamgis/common.py</code> <pre><code>def image_to_numpy(image):\n    \"\"\"Converts an image to a numpy array.\n\n    Args:\n        image (str): A dataset path, URL or rasterio.io.DatasetReader object.\n\n    Raises:\n        FileNotFoundError: If the provided file could not be found.\n\n    Returns:\n        np.array: A numpy array.\n    \"\"\"\n    import rasterio\n\n    from osgeo import gdal\n\n    # ... and suppress errors\n    gdal.PushErrorHandler(\"CPLQuietErrorHandler\")\n\n    try:\n        with rasterio.open(image, \"r\") as ds:\n            arr = ds.read()  # read all raster values\n        return arr\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.images_to_tiles","title":"<code>images_to_tiles(images, names=None, **kwargs)</code>","text":"<p>Convert a list of images to a dictionary of ipyleaflet.TileLayer objects.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>str | list</code> <p>The path to a directory of images or a list of image paths.</p> required <code>names</code> <code>list</code> <p>A list of names for the layers. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to get_local_tile_layer().</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of ipyleaflet.TileLayer objects.</p> Source code in <code>beamgis/common.py</code> <pre><code>def images_to_tiles(\n    images: Union[str, List[str]], names: List[str] = None, **kwargs\n) -&gt; Dict[str, ipyleaflet.TileLayer]:\n    \"\"\"Convert a list of images to a dictionary of ipyleaflet.TileLayer objects.\n\n    Args:\n        images (str | list): The path to a directory of images or a list of image paths.\n        names (list, optional): A list of names for the layers. Defaults to None.\n        **kwargs: Additional arguments to pass to get_local_tile_layer().\n\n    Returns:\n        dict: A dictionary of ipyleaflet.TileLayer objects.\n    \"\"\"\n\n    tiles = {}\n\n    if isinstance(images, str):\n        images = os.path.abspath(images)\n        images = find_files(images, ext=\".tif\", recursive=False)\n\n    if not isinstance(images, list):\n        raise ValueError(\"images must be a list of image paths or a directory\")\n\n    if names is None:\n        names = [os.path.splitext(os.path.basename(image))[0] for image in images]\n\n    if len(names) != len(images):\n        raise ValueError(\"names must have the same length as images\")\n\n    for index, image in enumerate(images):\n        name = names[index]\n        try:\n            if image.startswith(\"http\") and image.endswith(\".tif\"):\n                url = cog_tile(image, **kwargs)\n                tile = ipyleaflet.TileLayer(url=url, name=name, **kwargs)\n            elif image.startswith(\"http\"):\n                url = stac_tile(image, **kwargs)\n                tile = ipyleaflet.TileLayer(url=url, name=name, **kwargs)\n            else:\n                tile = get_local_tile_layer(image, layer_name=name, **kwargs)\n            tiles[name] = tile\n        except Exception as e:\n            print(image, e)\n\n    return tiles\n</code></pre>"},{"location":"common/#beamgis.common.install_package","title":"<code>install_package(package)</code>","text":"<p>Install a Python package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str | list</code> <p>The package name or a GitHub URL or a list of package names or GitHub URLs.</p> required Source code in <code>beamgis/common.py</code> <pre><code>def install_package(package):\n    \"\"\"Install a Python package.\n\n    Args:\n        package (str | list): The package name or a GitHub URL or a list of package names or GitHub URLs.\n    \"\"\"\n    import subprocess\n\n    if isinstance(package, str):\n        packages = [package]\n    elif isinstance(package, list):\n        packages = package\n\n    for package in packages:\n        if package.startswith(\"https\"):\n            package = f\"git+{package}\"\n\n        # Execute pip install command and show output in real-time\n        command = f\"pip install {package}\"\n        process = subprocess.Popen(command.split(), stdout=subprocess.PIPE)\n\n        # Print output in real-time\n        while True:\n            output = process.stdout.readline()\n            if output == b\"\" and process.poll() is not None:\n                break\n            if output:\n                print(output.decode(\"utf-8\").strip())\n\n        # Wait for process to complete\n        process.wait()\n</code></pre>"},{"location":"common/#beamgis.common.is_arcpy","title":"<code>is_arcpy()</code>","text":"<p>Check if arcpy is available.</p> <p>Returns:</p> Type Description <code>book</code> <p>True if arcpy is available, False otherwise.</p> Source code in <code>beamgis/common.py</code> <pre><code>def is_arcpy():\n    \"\"\"Check if arcpy is available.\n\n    Returns:\n        book: True if arcpy is available, False otherwise.\n    \"\"\"\n    import sys\n\n    if \"arcpy\" in sys.modules:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"common/#beamgis.common.is_array","title":"<code>is_array(x)</code>","text":"<p>Test whether x is either a numpy.ndarray or xarray.DataArray</p> Source code in <code>beamgis/common.py</code> <pre><code>def is_array(x):\n    \"\"\"Test whether x is either a numpy.ndarray or xarray.DataArray\"\"\"\n    import sys\n\n    if isinstance(x, sys.modules[\"numpy\"].ndarray):\n        return True\n    if \"xarray\" in sys.modules:\n        if isinstance(x, sys.modules[\"xarray\"].DataArray):\n            return True\n    return False\n</code></pre>"},{"location":"common/#beamgis.common.is_jupyterlite","title":"<code>is_jupyterlite()</code>","text":"<p>Check if the current notebook is running on JupyterLite.</p> <p>Returns:</p> Type Description <code>book</code> <p>True if the notebook is running on JupyterLite.</p> Source code in <code>beamgis/common.py</code> <pre><code>def is_jupyterlite():\n    \"\"\"Check if the current notebook is running on JupyterLite.\n\n    Returns:\n        book: True if the notebook is running on JupyterLite.\n    \"\"\"\n    import sys\n\n    if \"pyodide\" in sys.modules:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"common/#beamgis.common.is_on_aws","title":"<code>is_on_aws()</code>","text":"<p>Check if the current notebook is running on AWS.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the notebook is running on AWS.</p> Source code in <code>beamgis/common.py</code> <pre><code>def is_on_aws():\n    \"\"\"Check if the current notebook is running on AWS.\n\n    Returns:\n        bool: True if the notebook is running on AWS.\n    \"\"\"\n\n    import psutil\n\n    on_aws = False\n    try:\n        output = psutil.Process().parent().cmdline()\n\n        for item in output:\n            if item.endswith(\".aws\") or \"ec2-user\" in item:\n                on_aws = True\n    except:\n        pass\n    return on_aws\n</code></pre>"},{"location":"common/#beamgis.common.is_studio_lab","title":"<code>is_studio_lab()</code>","text":"<p>Check if the current notebook is running on Studio Lab.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the notebook is running on Studio Lab.</p> Source code in <code>beamgis/common.py</code> <pre><code>def is_studio_lab():\n    \"\"\"Check if the current notebook is running on Studio Lab.\n\n    Returns:\n        bool: True if the notebook is running on Studio Lab.\n    \"\"\"\n\n    import psutil\n\n    on_studio_lab = False\n\n    try:\n        output = psutil.Process().parent().cmdline()\n\n        for item in output:\n            if \"studiolab/bin\" in item:\n                on_studio_lab = True\n    except:\n        pass\n    return on_studio_lab\n</code></pre>"},{"location":"common/#beamgis.common.is_tool","title":"<code>is_tool(name)</code>","text":"<p>Check whether <code>name</code> is on PATH and marked as executable.</p> Source code in <code>beamgis/common.py</code> <pre><code>def is_tool(name):\n    \"\"\"Check whether `name` is on PATH and marked as executable.\"\"\"\n\n    return shutil.which(name) is not None\n</code></pre>"},{"location":"common/#beamgis.common.kml_to_geojson","title":"<code>kml_to_geojson(in_kml, out_geojson=None)</code>","text":"<p>Converts a KML to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>in_kml</code> <code>str</code> <p>The file path to the input KML.</p> required <code>out_geojson</code> <code>str</code> <p>The file path to the output GeoJSON. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The input KML could not be found.</p> <code>TypeError</code> <p>The output must be a GeoJSON.</p> Source code in <code>beamgis/common.py</code> <pre><code>def kml_to_geojson(in_kml, out_geojson=None):\n    \"\"\"Converts a KML to GeoJSON.\n\n    Args:\n        in_kml (str): The file path to the input KML.\n        out_geojson (str): The file path to the output GeoJSON. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The input KML could not be found.\n        TypeError: The output must be a GeoJSON.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    in_kml = os.path.abspath(in_kml)\n    if not os.path.exists(in_kml):\n        raise FileNotFoundError(\"The input KML could not be found.\")\n\n    if out_geojson is not None:\n        out_geojson = os.path.abspath(out_geojson)\n        ext = os.path.splitext(out_geojson)[1].lower()\n        if ext not in [\".json\", \".geojson\"]:\n            raise TypeError(\"The output file must be a GeoJSON.\")\n\n        out_dir = os.path.dirname(out_geojson)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n    import fiona\n\n    # import fiona\n    # print(fiona.supported_drivers)\n    fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n    gdf = gpd.read_file(in_kml, driver=\"KML\")\n\n    if out_geojson is not None:\n        gdf.to_file(out_geojson, driver=\"GeoJSON\")\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"common/#beamgis.common.kml_to_shp","title":"<code>kml_to_shp(in_kml, out_shp)</code>","text":"<p>Converts a KML to shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>in_kml</code> <code>str</code> <p>The file path to the input KML.</p> required <code>out_shp</code> <code>str</code> <p>The file path to the output shapefile.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The input KML could not be found.</p> <code>TypeError</code> <p>The output must be a shapefile.</p> Source code in <code>beamgis/common.py</code> <pre><code>def kml_to_shp(in_kml, out_shp):\n    \"\"\"Converts a KML to shapefile.\n\n    Args:\n        in_kml (str): The file path to the input KML.\n        out_shp (str): The file path to the output shapefile.\n\n    Raises:\n        FileNotFoundError: The input KML could not be found.\n        TypeError: The output must be a shapefile.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    in_kml = os.path.abspath(in_kml)\n    if not os.path.exists(in_kml):\n        raise FileNotFoundError(\"The input KML could not be found.\")\n\n    out_shp = os.path.abspath(out_shp)\n    if not out_shp.endswith(\".shp\"):\n        raise TypeError(\"The output must be a shapefile.\")\n\n    out_dir = os.path.dirname(out_shp)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n    import fiona\n\n    # print(fiona.supported_drivers)\n    fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n    df = gpd.read_file(in_kml, driver=\"KML\")\n    df.to_file(out_shp)\n</code></pre>"},{"location":"common/#beamgis.common.line_to_points","title":"<code>line_to_points(data)</code>","text":"<p>Converts a LineString geometry in a GeoDataFrame into individual points.</p> <p>Parameters:</p> Name Type Description Default <code>line_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing a LineString geometry.</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A new GeoDataFrame where each vertex of the LineString is a Point geometry.</p> Source code in <code>beamgis/common.py</code> <pre><code>def line_to_points(data: str) -&gt; \"GeoDataFrame\":\n    \"\"\"\n    Converts a LineString geometry in a GeoDataFrame into individual points.\n\n    Args:\n        line_gdf (GeoDataFrame): A GeoDataFrame containing a LineString geometry.\n\n    Returns:\n        GeoDataFrame: A new GeoDataFrame where each vertex of the LineString is a Point geometry.\n    \"\"\"\n    import geopandas as gpd\n    from shapely.geometry import Point, LineString\n    from geopandas import GeoDataFrame\n\n    if isinstance(data, str):\n        line_gdf = gpd.read_file(data)\n    elif isinstance(data, GeoDataFrame):\n        line_gdf = data\n    else:\n        raise ValueError(\"Invalid input. Must be a file path or a GeoDataFrame.\")\n\n    # Ensure there is a LineString in the GeoDataFrame\n    if not all(line_gdf.geometry.type == \"LineString\"):\n        raise ValueError(\"Input GeoDataFrame must contain only LineString geometries.\")\n\n    # Extract the first (and only) LineString from the GeoDataFrame\n    line = line_gdf.geometry.iloc[0]\n\n    # Convert each point in the LineString to a Point geometry\n    points = [Point(coord) for coord in line.coords]\n\n    # Create a new GeoDataFrame with these points\n    points_gdf = gpd.GeoDataFrame(geometry=points, crs=line_gdf.crs)\n\n    return points_gdf\n</code></pre>"},{"location":"common/#beamgis.common.list_palettes","title":"<code>list_palettes(add_extra=False, lowercase=False)</code>","text":"<p>List all available colormaps. See a complete lost of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.</p> <p>Returns:</p> Type Description <code>list</code> <p>The list of colormap names.</p> Source code in <code>beamgis/common.py</code> <pre><code>def list_palettes(add_extra=False, lowercase=False):\n    \"\"\"List all available colormaps. See a complete lost of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.\n\n    Returns:\n        list: The list of colormap names.\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    result = plt.colormaps()\n    if add_extra:\n        result += [\"dem\", \"ndvi\", \"ndwi\"]\n    if lowercase:\n        result = [i.lower() for i in result]\n    result.sort()\n    return result\n</code></pre>"},{"location":"common/#beamgis.common.lnglat_to_meters","title":"<code>lnglat_to_meters(longitude, latitude)</code>","text":"<p>coordinate conversion between lat/lon in decimal degrees to web mercator</p> <p>Parameters:</p> Name Type Description Default <code>longitude</code> <code>float</code> <p>The longitude.</p> required <code>latitude</code> <code>float</code> <p>The latitude.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (x, y) in meters.</p> Source code in <code>beamgis/common.py</code> <pre><code>def lnglat_to_meters(longitude, latitude):\n    \"\"\"coordinate conversion between lat/lon in decimal degrees to web mercator\n\n    Args:\n        longitude (float): The longitude.\n        latitude (float): The latitude.\n\n    Returns:\n        tuple: A tuple of (x, y) in meters.\n    \"\"\"\n    import numpy as np\n\n    origin_shift = np.pi * 6378137\n    easting = longitude * origin_shift / 180.0\n    northing = np.log(np.tan((90 + latitude) * np.pi / 360.0)) * origin_shift / np.pi\n\n    if np.isnan(easting):\n        if longitude &gt; 0:\n            easting = 20026376\n        else:\n            easting = -20026376\n\n    if np.isnan(northing):\n        if latitude &gt; 0:\n            northing = 20048966\n        else:\n            northing = -20048966\n\n    return (easting, northing)\n</code></pre>"},{"location":"common/#beamgis.common.local_tile_bands","title":"<code>local_tile_bands(source)</code>","text":"<p>Get band names from COG.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | TileClient</code> <p>A local COG file path or TileClient</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of band names.</p> Source code in <code>beamgis/common.py</code> <pre><code>def local_tile_bands(source):\n    \"\"\"Get band names from COG.\n\n    Args:\n        source (str | TileClient): A local COG file path or TileClient\n\n    Returns:\n        list: A list of band names.\n    \"\"\"\n    check_package(\"localtileserver\", \"https://github.com/banesullivan/localtileserver\")\n    from localtileserver import TileClient\n\n    if isinstance(source, str):\n        tile_client = TileClient(source)\n    elif isinstance(source, TileClient):\n        tile_client = source\n    else:\n        raise ValueError(\"source must be a string or TileClient object.\")\n\n    return tile_client.band_names\n</code></pre>"},{"location":"common/#beamgis.common.local_tile_pixel_value","title":"<code>local_tile_pixel_value(lon, lat, tile_client, verbose=True, **kwargs)</code>","text":"<p>Get pixel value from COG.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Longitude of the pixel.</p> required <code>lat</code> <code>float</code> <p>Latitude of the pixel.</p> required <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., 'https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif'</p> required <code>bidx</code> <code>str</code> <p>Dataset band indexes (e.g bidx=1, bidx=1&amp;bidx=2&amp;bidx=3). Defaults to None.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> required <code>verbose</code> <code>bool</code> <p>Print status messages. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>PointData</code> <p>rio-tiler point data.</p> Source code in <code>beamgis/common.py</code> <pre><code>def local_tile_pixel_value(\n    lon,\n    lat,\n    tile_client,\n    verbose=True,\n    **kwargs,\n):\n    \"\"\"Get pixel value from COG.\n\n    Args:\n        lon (float): Longitude of the pixel.\n        lat (float): Latitude of the pixel.\n        url (str): HTTP URL to a COG, e.g., 'https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif'\n        bidx (str, optional): Dataset band indexes (e.g bidx=1, bidx=1&amp;bidx=2&amp;bidx=3). Defaults to None.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        verbose (bool, optional): Print status messages. Defaults to True.\n\n    Returns:\n        PointData: rio-tiler point data.\n    \"\"\"\n    return tile_client.point(lon, lat, coord_crs=\"EPSG:4326\", **kwargs)\n</code></pre>"},{"location":"common/#beamgis.common.local_tile_vmin_vmax","title":"<code>local_tile_vmin_vmax(source, bands=None, **kwargs)</code>","text":"<p>Get vmin and vmax from COG.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | TileClient</code> <p>A local COG file path or TileClient object.</p> required <code>bands</code> <code>str | list</code> <p>A list of band names. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If source is not a TileClient object or a local COG file path.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of vmin and vmax.</p> Source code in <code>beamgis/common.py</code> <pre><code>def local_tile_vmin_vmax(\n    source,\n    bands=None,\n    **kwargs,\n):\n    \"\"\"Get vmin and vmax from COG.\n\n    Args:\n        source (str | TileClient): A local COG file path or TileClient object.\n        bands (str | list, optional): A list of band names. Defaults to None.\n\n    Raises:\n        ValueError: If source is not a TileClient object or a local COG file path.\n\n    Returns:\n        tuple: A tuple of vmin and vmax.\n    \"\"\"\n    check_package(\"localtileserver\", \"https://github.com/banesullivan/localtileserver\")\n    from localtileserver import TileClient\n\n    if isinstance(source, str):\n        tile_client = TileClient(source)\n    elif isinstance(source, TileClient):\n        tile_client = source\n    else:\n        raise ValueError(\"source must be a string or TileClient object.\")\n\n    bandnames = tile_client.band_names\n    stats = tile_client.reader.statistics()\n\n    if isinstance(bands, str):\n        bands = [bands]\n    elif isinstance(bands, list):\n        pass\n    elif bands is None:\n        bands = bandnames\n\n    if all(b in bandnames for b in bands):\n        vmin = min([stats[b][\"min\"] for b in bands])\n        vmax = max([stats[b][\"max\"] for b in bands])\n    else:\n        vmin = min([stats[b][\"min\"] for b in bandnames])\n        vmax = max([stats[b][\"max\"] for b in bandnames])\n    return vmin, vmax\n</code></pre>"},{"location":"common/#beamgis.common.make_gif","title":"<code>make_gif(images, out_gif, ext='jpg', fps=10, loop=0, mp4=False, clean_up=False)</code>","text":"<p>Creates a gif from a list of images.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>list | str</code> <p>The list of images or input directory to create the gif from.</p> required <code>out_gif</code> <code>str</code> <p>File path to the output gif.</p> required <code>ext</code> <code>str</code> <p>The extension of the images. Defaults to 'jpg'.</p> <code>'jpg'</code> <code>fps</code> <code>int</code> <p>The frames per second of the gif. Defaults to 10.</p> <code>10</code> <code>loop</code> <code>int</code> <p>The number of times to loop the gif. Defaults to 0.</p> <code>0</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the gif to mp4. Defaults to False.</p> <code>False</code> Source code in <code>beamgis/common.py</code> <pre><code>def make_gif(images, out_gif, ext=\"jpg\", fps=10, loop=0, mp4=False, clean_up=False):\n    \"\"\"Creates a gif from a list of images.\n\n    Args:\n        images (list | str): The list of images or input directory to create the gif from.\n        out_gif (str): File path to the output gif.\n        ext (str, optional): The extension of the images. Defaults to 'jpg'.\n        fps (int, optional): The frames per second of the gif. Defaults to 10.\n        loop (int, optional): The number of times to loop the gif. Defaults to 0.\n        mp4 (bool, optional): Whether to convert the gif to mp4. Defaults to False.\n\n    \"\"\"\n    import glob\n    from PIL import Image\n\n    ext = ext.replace(\".\", \"\")\n\n    if isinstance(images, str) and os.path.isdir(images):\n        images = list(glob.glob(os.path.join(images, f\"*.{ext}\")))\n        if len(images) == 0:\n            raise ValueError(\"No images found in the input directory.\")\n    elif not isinstance(images, list):\n        raise ValueError(\"images must be a list or a path to the image directory.\")\n\n    images.sort()\n\n    frames = [Image.open(image) for image in images]\n    frame_one = frames[0]\n    frame_one.save(\n        out_gif,\n        format=\"GIF\",\n        append_images=frames,\n        save_all=True,\n        duration=int(1000 / fps),\n        loop=loop,\n    )\n\n    if mp4:\n        if not is_tool(\"ffmpeg\"):\n            print(\"ffmpeg is not installed on your computer.\")\n            return\n\n        if os.path.exists(out_gif):\n            out_mp4 = out_gif.replace(\".gif\", \".mp4\")\n            cmd = f\"ffmpeg -loglevel error -i {out_gif} -vcodec libx264 -crf 25 -pix_fmt yuv420p {out_mp4}\"\n            os.system(cmd)\n            if not os.path.exists(out_mp4):\n                raise Exception(f\"Failed to create mp4 file.\")\n    if clean_up:\n        for image in images:\n            os.remove(image)\n</code></pre>"},{"location":"common/#beamgis.common.map_tiles_to_geotiff","title":"<code>map_tiles_to_geotiff(output, bbox, zoom=None, resolution=None, source='OpenStreetMap', crs='EPSG:3857', to_cog=False, quiet=False, **kwargs)</code>","text":"<p>Download map tiles and convert them to a GeoTIFF. The source is adapted from https://github.com/gumblex/tms2geotiff.     Credits to the GitHub user @gumblex.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The output GeoTIFF file.</p> required <code>bbox</code> <code>list</code> <p>The bounding box [minx, miny, maxx, maxy] coordinates in EPSG:4326, e.g., [-122.5216, 37.733, -122.3661, 37.8095]</p> required <code>zoom</code> <code>int</code> <p>The map zoom level. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>float</code> <p>The resolution in meters. Defaults to None.</p> <code>None</code> <code>source</code> <code>str</code> <p>The tile source. It can be one of the following: \"OPENSTREETMAP\", \"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or an HTTP URL. Defaults to \"OpenStreetMap\".</p> <code>'OpenStreetMap'</code> <code>crs</code> <code>str</code> <p>The coordinate reference system. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>to_cog</code> <code>bool</code> <p>Convert to Cloud Optimized GeoTIFF. Defaults to False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments to pass to gdal.GetDriverByName(\"GTiff\").Create().</p> <code>{}</code> Source code in <code>beamgis/common.py</code> <pre><code>def map_tiles_to_geotiff(\n    output,\n    bbox,\n    zoom=None,\n    resolution=None,\n    source=\"OpenStreetMap\",\n    crs=\"EPSG:3857\",\n    to_cog=False,\n    quiet=False,\n    **kwargs,\n):\n    \"\"\"Download map tiles and convert them to a GeoTIFF. The source is adapted from https://github.com/gumblex/tms2geotiff.\n        Credits to the GitHub user @gumblex.\n\n    Args:\n        output (str): The output GeoTIFF file.\n        bbox (list): The bounding box [minx, miny, maxx, maxy] coordinates in EPSG:4326, e.g., [-122.5216, 37.733, -122.3661, 37.8095]\n        zoom (int, optional): The map zoom level. Defaults to None.\n        resolution (float, optional): The resolution in meters. Defaults to None.\n        source (str, optional): The tile source. It can be one of the following: \"OPENSTREETMAP\", \"ROADMAP\",\n            \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or an HTTP URL. Defaults to \"OpenStreetMap\".\n        crs (str, optional): The coordinate reference system. Defaults to \"EPSG:3857\".\n        to_cog (bool, optional): Convert to Cloud Optimized GeoTIFF. Defaults to False.\n        quiet (bool, optional): Suppress output. Defaults to False.\n        **kwargs: Additional arguments to pass to gdal.GetDriverByName(\"GTiff\").Create().\n\n    \"\"\"\n    import re\n    import io\n    import math\n    import itertools\n    import concurrent.futures\n\n    import numpy\n    from PIL import Image\n\n    try:\n        from osgeo import gdal, osr\n    except ImportError:\n        raise ImportError(\"GDAL is not installed. Install it with pip install GDAL\")\n\n    try:\n        import httpx\n\n        SESSION = httpx.Client()\n    except ImportError:\n        import requests\n\n        SESSION = requests.Session()\n\n    SESSION.headers.update(\n        {\n            \"Accept\": \"*/*\",\n            \"Accept-Encoding\": \"gzip, deflate\",\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0\",\n        }\n    )\n\n    xyz_tiles = {\n        \"OPENSTREETMAP\": {\n            \"url\": \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            \"attribution\": \"OpenStreetMap\",\n            \"name\": \"OpenStreetMap\",\n        },\n        \"ROADMAP\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Maps\",\n        },\n        \"SATELLITE\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Satellite\",\n        },\n        \"TERRAIN\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Terrain\",\n        },\n        \"HYBRID\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Satellite\",\n        },\n    }\n\n    if isinstance(source, str) and source.upper() in xyz_tiles:\n        source = xyz_tiles[source.upper()][\"url\"]\n    elif isinstance(source, str) and source.startswith(\"http\"):\n        pass\n    elif isinstance(source, str):\n        tiles = basemap_xyz_tiles()\n        if source in tiles:\n            source = tiles[source].url\n    else:\n        raise ValueError(\n            'source must be one of \"OpenStreetMap\", \"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or a URL'\n        )\n\n    # Web Mercator tile size in meters at zoom level 0\n    MERCATOR_ZOOM_0_RESOLUTION_M = 156543.03392804097\n\n    def resolution_to_zoom_level(resolution):\n        \"\"\"\n        Convert map resolution in meters to zoom level for Web Mercator (EPSG:3857) tiles.\n        \"\"\"\n        initial_resolution = MERCATOR_ZOOM_0_RESOLUTION_M\n\n        # Calculate the zoom level\n        zoom_level = math.log2(initial_resolution / resolution)\n\n        return int(zoom_level)\n\n    def zoom_level_to_resolution(zoom):\n        \"\"\"\n        Convert map zoom level to resolution in meters for Web Mercator (EPSG:3857) tiles.\n        \"\"\"\n        initial_resolution = MERCATOR_ZOOM_0_RESOLUTION_M\n\n        # Calculate resolution\n        resolution_m = initial_resolution / (2**zoom)\n\n        return resolution_m\n\n    if isinstance(bbox, list) and len(bbox) == 4:\n        west, south, east, north = bbox\n    else:\n        raise ValueError(\n            \"bbox must be a list of 4 coordinates in the format of [xmin, ymin, xmax, ymax]\"\n        )\n\n    if (zoom is None) and (resolution is None):\n        raise ValueError(\"Either zoom or resolution must be provided\")\n\n    elif (zoom is not None) and (resolution is not None):\n        raise ValueError(\"Only one of zoom or resolution can be provided\")\n\n    elif (zoom is None) and (resolution is not None):\n        zoom = resolution_to_zoom_level(resolution)\n    else:\n        # condition: (resolution is None) and (zoom is not None):\n        resolution = zoom_level_to_resolution(zoom)\n\n    EARTH_EQUATORIAL_RADIUS = 6378137.0\n\n    Image.MAX_IMAGE_PIXELS = None\n\n    gdal.UseExceptions()\n    web_mercator = osr.SpatialReference()\n    try:\n        web_mercator.ImportFromEPSG(3857)\n    except RuntimeError as e:\n        # https://github.com/PDAL/PDAL/issues/2544#issuecomment-637995923\n        if \"PROJ\" in str(e):\n            pattern = r\"/[\\w/]+\"\n            match = re.search(pattern, str(e))\n            if match:\n                file_path = match.group(0)\n                os.environ[\"PROJ_LIB\"] = file_path\n                os.environ[\"GDAL_DATA\"] = file_path.replace(\"proj\", \"gdal\")\n                web_mercator.ImportFromEPSG(3857)\n\n    WKT_3857 = web_mercator.ExportToWkt()\n\n    def from4326_to3857(lat, lon):\n        xtile = math.radians(lon) * EARTH_EQUATORIAL_RADIUS\n        ytile = (\n            math.log(math.tan(math.radians(45 + lat / 2.0))) * EARTH_EQUATORIAL_RADIUS\n        )\n        return (xtile, ytile)\n\n    def deg2num(lat, lon, zoom):\n        lat_r = math.radians(lat)\n        n = 2**zoom\n        xtile = (lon + 180) / 360 * n\n        ytile = (1 - math.log(math.tan(lat_r) + 1 / math.cos(lat_r)) / math.pi) / 2 * n\n        return (xtile, ytile)\n\n    def is_empty(im):\n        extrema = im.getextrema()\n        if len(extrema) &gt;= 3:\n            if len(extrema) &gt; 3 and extrema[-1] == (0, 0):\n                return True\n            for ext in extrema[:3]:\n                if ext != (0, 0):\n                    return False\n            return True\n        else:\n            return extrema[0] == (0, 0)\n\n    def paste_tile(bigim, base_size, tile, corner_xy, bbox):\n        if tile is None:\n            return bigim\n        im = Image.open(io.BytesIO(tile))\n        mode = \"RGB\" if im.mode == \"RGB\" else \"RGBA\"\n        size = im.size\n        if bigim is None:\n            base_size[0] = size[0]\n            base_size[1] = size[1]\n            newim = Image.new(\n                mode, (size[0] * (bbox[2] - bbox[0]), size[1] * (bbox[3] - bbox[1]))\n            )\n        else:\n            newim = bigim\n\n        dx = abs(corner_xy[0] - bbox[0])\n        dy = abs(corner_xy[1] - bbox[1])\n        xy0 = (size[0] * dx, size[1] * dy)\n        if mode == \"RGB\":\n            newim.paste(im, xy0)\n        else:\n            if im.mode != mode:\n                im = im.convert(mode)\n            if not is_empty(im):\n                newim.paste(im, xy0)\n        im.close()\n        return newim\n\n    def finish_picture(bigim, base_size, bbox, x0, y0, x1, y1):\n        xfrac = x0 - bbox[0]\n        yfrac = y0 - bbox[1]\n        x2 = round(base_size[0] * xfrac)\n        y2 = round(base_size[1] * yfrac)\n        imgw = round(base_size[0] * (x1 - x0))\n        imgh = round(base_size[1] * (y1 - y0))\n        retim = bigim.crop((x2, y2, x2 + imgw, y2 + imgh))\n        if retim.mode == \"RGBA\" and retim.getextrema()[3] == (255, 255):\n            retim = retim.convert(\"RGB\")\n        bigim.close()\n        return retim\n\n    def get_tile(url):\n        retry = 3\n        while 1:\n            try:\n                r = SESSION.get(url, timeout=60)\n                break\n            except Exception:\n                retry -= 1\n                if not retry:\n                    raise\n        if r.status_code == 404:\n            return None\n        elif not r.content:\n            return None\n        r.raise_for_status()\n        return r.content\n\n    def draw_tile(\n        source, lat0, lon0, lat1, lon1, zoom, filename, quiet=False, **kwargs\n    ):\n        x0, y0 = deg2num(lat0, lon0, zoom)\n        x1, y1 = deg2num(lat1, lon1, zoom)\n        x0, x1 = sorted([x0, x1])\n        y0, y1 = sorted([y0, y1])\n        corners = tuple(\n            itertools.product(\n                range(math.floor(x0), math.ceil(x1)),\n                range(math.floor(y0), math.ceil(y1)),\n            )\n        )\n        totalnum = len(corners)\n        futures = []\n        with concurrent.futures.ThreadPoolExecutor(5) as executor:\n            for x, y in corners:\n                futures.append(\n                    executor.submit(get_tile, source.format(z=zoom, x=x, y=y))\n                )\n            bbox = (math.floor(x0), math.floor(y0), math.ceil(x1), math.ceil(y1))\n            bigim = None\n            base_size = [256, 256]\n            for k, (fut, corner_xy) in enumerate(zip(futures, corners), 1):\n                bigim = paste_tile(bigim, base_size, fut.result(), corner_xy, bbox)\n                if not quiet:\n                    print(\"Downloaded image %d/%d\" % (k, totalnum))\n\n        if not quiet:\n            print(\"Saving GeoTIFF. Please wait...\")\n        img = finish_picture(bigim, base_size, bbox, x0, y0, x1, y1)\n        imgbands = len(img.getbands())\n        driver = gdal.GetDriverByName(\"GTiff\")\n\n        if \"options\" not in kwargs:\n            kwargs[\"options\"] = [\n                \"COMPRESS=DEFLATE\",\n                \"PREDICTOR=2\",\n                \"ZLEVEL=9\",\n                \"TILED=YES\",\n            ]\n\n        kwargs.pop(\"overwrite\", None)\n        gtiff = driver.Create(\n            filename,\n            img.size[0],\n            img.size[1],\n            imgbands,\n            gdal.GDT_Byte,\n            **kwargs,\n        )\n\n        gtiff.SetMetadata({\"ZOOM_LEVEL\": str(zoom), \"RESOLUTION_M\": str(resolution)})\n\n        xp0, yp0 = from4326_to3857(lat0, lon0)\n        xp1, yp1 = from4326_to3857(lat1, lon1)\n        pwidth = abs(xp1 - xp0) / img.size[0]\n        pheight = abs(yp1 - yp0) / img.size[1]\n        gtiff.SetGeoTransform((min(xp0, xp1), pwidth, 0, max(yp0, yp1), 0, -pheight))\n        gtiff.SetProjection(WKT_3857)\n        for band in range(imgbands):\n            array = np.array(img.getdata(band), dtype=\"u8\")\n            array = array.reshape((img.size[1], img.size[0]))\n            band = gtiff.GetRasterBand(band + 1)\n            band.WriteArray(array)\n        gtiff.FlushCache()\n\n        if not quiet:\n            print(f\"Image saved to {filename}\")\n        return img\n\n    try:\n        draw_tile(source, south, west, north, east, zoom, output, quiet, **kwargs)\n        if crs.upper() != \"EPSG:3857\":\n            reproject(image=output, output=output, dst_crs=crs, to_cog=to_cog)\n        elif to_cog:\n            image_to_cog(source=output, dst_path=output)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.mbtiles_to_pmtiles","title":"<code>mbtiles_to_pmtiles(input_file, output_file, max_zoom=99)</code>","text":"<p>Converts mbtiles to pmtiles using the pmtiles package.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the input .mbtiles file.</p> required <code>output_file</code> <code>str</code> <p>Path to the output .pmtiles file.</p> required <code>max_zoom</code> <code>int</code> <p>Maximum zoom level for the conversion. Defaults to 99.</p> <code>99</code> <p>Returns:</p> Type Description <code>None</code> <p>The function returns None either upon successful completion or when the pmtiles package is not installed.</p> Source code in <code>beamgis/common.py</code> <pre><code>def mbtiles_to_pmtiles(\n    input_file: str, output_file: str, max_zoom: int = 99\n) -&gt; Optional[None]:\n    \"\"\"\n    Converts mbtiles to pmtiles using the pmtiles package.\n\n    Args:\n        input_file (str): Path to the input .mbtiles file.\n        output_file (str): Path to the output .pmtiles file.\n        max_zoom (int): Maximum zoom level for the conversion. Defaults to 99.\n\n    Returns:\n        None: The function returns None either upon successful completion or when the pmtiles package is not installed.\n\n    \"\"\"\n\n    import pmtiles.convert as convert\n\n    convert.mbtiles_to_pmtiles(input_file, output_file, maxzoom=max_zoom)\n</code></pre>"},{"location":"common/#beamgis.common.merge_gifs","title":"<code>merge_gifs(in_gifs, out_gif)</code>","text":"<p>Merge multiple gifs into one.</p> <p>Parameters:</p> Name Type Description Default <code>in_gifs</code> <code>str | list</code> <p>The input gifs as a list or a directory path.</p> required <code>out_gif</code> <code>str</code> <p>The output gif.</p> required <p>Exceptions:</p> Type Description <code>Exception</code> <p>Raise exception when gifsicle is not installed.</p> Source code in <code>beamgis/common.py</code> <pre><code>def merge_gifs(in_gifs, out_gif):\n    \"\"\"Merge multiple gifs into one.\n\n    Args:\n        in_gifs (str | list): The input gifs as a list or a directory path.\n        out_gif (str): The output gif.\n\n    Raises:\n        Exception:  Raise exception when gifsicle is not installed.\n    \"\"\"\n    import glob\n\n    try:\n        if isinstance(in_gifs, str) and os.path.isdir(in_gifs):\n            in_gifs = glob.glob(os.path.join(in_gifs, \"*.gif\"))\n        elif not isinstance(in_gifs, list):\n            raise Exception(\"in_gifs must be a list.\")\n\n        in_gifs = \" \".join(in_gifs)\n\n        cmd = f\"gifsicle {in_gifs} &gt; {out_gif}\"\n        os.system(cmd)\n\n    except Exception as e:\n        print(\n            \"gifsicle is not installed. Run 'sudo apt-get install -y gifsicle' to install it.\"\n        )\n        print(e)\n</code></pre>"},{"location":"common/#beamgis.common.merge_rasters","title":"<code>merge_rasters(input_dir_or_files, output, input_pattern='*.tif', output_format='GTiff', output_nodata=None, output_options=None, **kwargs)</code>","text":"<p>Merge a directory of rasters or a list of file paths into a single raster.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir_or_files</code> <code>Union[str, List[str]]</code> <p>The path to the input directory or a list of file paths.</p> required <code>output</code> <code>str</code> <p>The path to the output raster.</p> required <code>input_pattern</code> <code>str</code> <p>The glob pattern to match input files if a directory is provided. Defaults to \"*.tif\".</p> <code>'*.tif'</code> <code>output_format</code> <code>str</code> <p>The output raster format. Defaults to \"GTiff\".</p> <code>'GTiff'</code> <code>output_nodata</code> <code>float</code> <p>The nodata value for the output raster. Defaults to None.</p> <code>None</code> <code>output_options</code> <code>list</code> <p>A list of creation options for the output raster. Defaults to [\"COMPRESS=DEFLATE\"].</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to gdal.WarpOptions.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If GDAL is not installed.</p> <code>ValueError</code> <p>If no input files are found.</p> Source code in <code>beamgis/common.py</code> <pre><code>def merge_rasters(\n    input_dir_or_files: Union[str, List[str]],\n    output: str,\n    input_pattern: str = \"*.tif\",\n    output_format: str = \"GTiff\",\n    output_nodata: float = None,\n    output_options: list = None,\n    **kwargs,\n):\n    \"\"\"\n    Merge a directory of rasters or a list of file paths into a single raster.\n\n    Args:\n        input_dir_or_files (Union[str, List[str]]): The path to the input directory or a list of file paths.\n        output (str): The path to the output raster.\n        input_pattern (str, optional): The glob pattern to match input files if a directory is provided. Defaults to \"*.tif\".\n        output_format (str, optional): The output raster format. Defaults to \"GTiff\".\n        output_nodata (float, optional): The nodata value for the output raster. Defaults to None.\n        output_options (list, optional): A list of creation options for the output raster. Defaults to [\"COMPRESS=DEFLATE\"].\n        **kwargs: Additional arguments to pass to gdal.WarpOptions.\n\n    Raises:\n        ImportError: If GDAL is not installed.\n        ValueError: If no input files are found.\n    \"\"\"\n    import glob\n\n    if output_options is None:\n        output_options = [\"COMPRESS=DEFLATE\"]\n\n    try:\n        from osgeo import gdal  # Ensure GDAL is available\n    except ImportError as e:\n        raise ImportError(\n            \"GDAL is required to use this function. Install it with `conda install gdal -c conda-forge`\"\n        ) from e\n\n    # Get a list of input files\n    if isinstance(input_dir_or_files, str):  # It's a directory\n        input_files = glob.glob(os.path.join(input_dir_or_files, input_pattern))\n    elif isinstance(input_dir_or_files, list):  # It's a list of file paths\n        input_files = input_dir_or_files\n    else:\n        raise ValueError(\n            \"input_dir_or_files must be a directory path (str) or a list of file paths (List[str]).\"\n        )\n\n    # Check if files are found\n    if not input_files:\n        raise ValueError(\n            \"No input files found. Please check the directory or file paths provided.\"\n        )\n\n    # Configure warp options\n    warp_options = gdal.WarpOptions(\n        format=output_format,\n        dstNodata=output_nodata,\n        creationOptions=output_options,\n        **kwargs,\n    )\n\n    # Perform the raster merge\n    print(f\"Merging {len(input_files)} rasters into '{output}'...\")\n    result = gdal.Warp(\n        destNameOrDestDS=output,\n        srcDSOrSrcDSTab=input_files,\n        options=warp_options,\n    )\n\n    # Check for success\n    if result is None:\n        raise RuntimeError(\n            \"Raster merge failed. Please check your inputs and parameters.\"\n        )\n    print(f\"Raster merge completed successfully: {output}\")\n</code></pre>"},{"location":"common/#beamgis.common.merge_vector","title":"<code>merge_vector(files, output, crs=None, ext='geojson', recursive=False, quiet=False, return_gdf=False, **kwargs)</code>","text":"<p>Merge vector files into a single GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Union[str, List[str]]</code> <p>A string or a list of file paths to be merged.</p> required <code>output</code> <code>str</code> <p>The file path to save the merged GeoDataFrame.</p> required <code>crs</code> <code>str</code> <p>Optional. The coordinate reference system (CRS) of the output GeoDataFrame.</p> <code>None</code> <code>ext</code> <code>str</code> <p>Optional. The file extension of the input files. Default is 'geojson'.</p> <code>'geojson'</code> <code>recursive</code> <code>bool</code> <p>Optional. If True, search for files recursively in subdirectories. Default is False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Optional. If True, suppresses progress messages. Default is False.</p> <code>False</code> <code>return_gdf</code> <code>bool</code> <p>Optional. If True, returns the merged GeoDataFrame. Default is False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the <code>gpd.read_file</code> function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[gpd.GeoDataFrame]</code> <p>If <code>return_gdf</code> is True, returns the merged GeoDataFrame. Otherwise, returns None.</p> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If <code>files</code> is not a list of file paths.</p> Source code in <code>beamgis/common.py</code> <pre><code>def merge_vector(\n    files: Union[str, List[str]],\n    output: str,\n    crs: str = None,\n    ext: str = \"geojson\",\n    recursive: bool = False,\n    quiet: bool = False,\n    return_gdf: bool = False,\n    **kwargs,\n) -&gt; Optional[\"gpd.GeoDataFrame\"]:\n    \"\"\"\n    Merge vector files into a single GeoDataFrame.\n\n    Args:\n        files: A string or a list of file paths to be merged.\n        output: The file path to save the merged GeoDataFrame.\n        crs: Optional. The coordinate reference system (CRS) of the output GeoDataFrame.\n        ext: Optional. The file extension of the input files. Default is 'geojson'.\n        recursive: Optional. If True, search for files recursively in subdirectories. Default is False.\n        quiet: Optional. If True, suppresses progress messages. Default is False.\n        return_gdf: Optional. If True, returns the merged GeoDataFrame. Default is False.\n        **kwargs: Additional keyword arguments to be passed to the `gpd.read_file` function.\n\n    Returns:\n        If `return_gdf` is True, returns the merged GeoDataFrame. Otherwise, returns None.\n\n    Raises:\n        TypeError: If `files` is not a list of file paths.\n\n    \"\"\"\n\n    import pandas as pd\n    import geopandas as gpd\n\n    if isinstance(files, str):\n        files = find_files(files, ext=ext, recursive=recursive)\n\n    if not isinstance(files, list):\n        raise TypeError(\"files must be a list of file paths\")\n\n    gdfs = []\n    for index, filename in enumerate(files):\n        if not quiet:\n            print(f\"Reading {index+1} of {len(files)}: {filename}\")\n        gdf = gpd.read_file(filename, **kwargs)\n        if crs is None:\n            crs = gdf.crs\n        gdfs.append(gdf)\n\n    if not quiet:\n        print(\"Merging GeoDataFrames ...\")\n    gdf = gpd.GeoDataFrame(pd.concat(gdfs, ignore_index=True), crs=crs)\n\n    if not quiet:\n        print(f\"Saving merged file to {output} ...\")\n    gdf.to_file(output)\n    print(f\"Saved merged file to {output}\")\n\n    if return_gdf:\n        return gdf\n</code></pre>"},{"location":"common/#beamgis.common.meters_to_lnglat","title":"<code>meters_to_lnglat(x, y)</code>","text":"<p>coordinate conversion between web mercator to lat/lon in decimal degrees</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x coordinate.</p> required <code>y</code> <code>float</code> <p>The y coordinate.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (longitude, latitude) in decimal degrees.</p> Source code in <code>beamgis/common.py</code> <pre><code>def meters_to_lnglat(x, y):\n    \"\"\"coordinate conversion between web mercator to lat/lon in decimal degrees\n\n    Args:\n        x (float): The x coordinate.\n        y (float): The y coordinate.\n\n    Returns:\n        tuple: A tuple of (longitude, latitude) in decimal degrees.\n    \"\"\"\n\n    origin_shift = np.pi * 6378137\n    longitude = (x / origin_shift) * 180.0\n    latitude = (y / origin_shift) * 180.0\n    latitude = (\n        180 / np.pi * (2 * np.arctan(np.exp(latitude * np.pi / 180.0)) - np.pi / 2.0)\n    )\n    return (longitude, latitude)\n</code></pre>"},{"location":"common/#beamgis.common.mosaic","title":"<code>mosaic(images, output, ext='tif', recursive=True, merge_args={}, to_cog=True, verbose=True, **kwargs)</code>","text":"<p>Mosaics a list of images into a single image. Inspired by https://bit.ly/3A6roDK.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>str | list</code> <p>An input directory containing images or a list of images.</p> required <code>output</code> <code>str</code> <p>The output image filepath.</p> required <code>ext</code> <code>str</code> <p>The file extension of the images. Defaults to 'tif'.</p> <code>'tif'</code> <code>recursive</code> <code>bool</code> <p>Whether to recursively search for images in the input directory. Defaults to True.</p> <code>True</code> <code>merge_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the rasterio.merge function. Defaults to {}.</p> <code>{}</code> <code>to_cog</code> <code>bool</code> <p>Whether to convert the output image to a Cloud Optimized GeoTIFF. Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Whether to print progress. Defaults to True.</p> <code>True</code> Source code in <code>beamgis/common.py</code> <pre><code>def mosaic(\n    images,\n    output,\n    ext=\"tif\",\n    recursive=True,\n    merge_args={},\n    to_cog=True,\n    verbose=True,\n    **kwargs,\n):\n    \"\"\"Mosaics a list of images into a single image. Inspired by https://bit.ly/3A6roDK.\n\n    Args:\n        images (str | list): An input directory containing images or a list of images.\n        output (str): The output image filepath.\n        ext (str, optional): The file extension of the images. Defaults to 'tif'.\n        recursive (bool, optional): Whether to recursively search for images in the input directory. Defaults to True.\n        merge_args (dict, optional): A dictionary of arguments to pass to the rasterio.merge function. Defaults to {}.\n        to_cog (bool, optional): Whether to convert the output image to a Cloud Optimized GeoTIFF. Defaults to True.\n        verbose (bool, optional): Whether to print progress. Defaults to True.\n\n    \"\"\"\n    from rasterio.merge import merge\n    import rasterio as rio\n    from pathlib import Path\n\n    output = os.path.abspath(output)\n\n    if isinstance(images, str):\n        raster_files = find_files(images, ext=ext, recursive=recursive)\n    elif isinstance(images, list):\n        raster_files = images\n    else:\n        raise ValueError(\"images must be a list of raster files.\")\n\n    raster_to_mosiac = []\n\n    if not os.path.exists(os.path.dirname(output)):\n        os.makedirs(os.path.dirname(output))\n\n    for index, p in enumerate(raster_files):\n        if verbose:\n            print(f\"Reading {index+1}/{len(raster_files)}: {os.path.basename(p)}\")\n        raster = rio.open(p, **kwargs)\n        raster_to_mosiac.append(raster)\n\n    if verbose:\n        print(\"Merging rasters...\")\n    arr, transform = merge(raster_to_mosiac, **merge_args)\n\n    output_meta = raster.meta.copy()\n    output_meta.update(\n        {\n            \"driver\": \"GTiff\",\n            \"height\": arr.shape[1],\n            \"width\": arr.shape[2],\n            \"transform\": transform,\n        }\n    )\n\n    with rio.open(output, \"w\", **output_meta) as m:\n        m.write(arr)\n\n    if to_cog:\n        if verbose:\n            print(\"Converting to COG...\")\n        image_to_cog(output, output)\n\n    if verbose:\n        print(f\"Saved mosaic to {output}\")\n</code></pre>"},{"location":"common/#beamgis.common.mosaic_bounds","title":"<code>mosaic_bounds(url, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the bounding box of a MosaicJSON.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a MosaicJSON.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of values representing [left, bottom, right, top]</p> Source code in <code>beamgis/common.py</code> <pre><code>def mosaic_bounds(url, titiler_endpoint=None, **kwargs):\n    \"\"\"Get the bounding box of a MosaicJSON.\n\n    Args:\n        url (str): HTTP URL to a MosaicJSON.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n\n    Returns:\n        list: A list of values representing [left, bottom, right, top]\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if isinstance(url, str) and url.startswith(\"http\"):\n        kwargs[\"url\"] = url\n    else:\n        raise ValueError(\"url must be a string and start with http.\")\n\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/bounds\",\n            params=kwargs,\n        ).json()\n    else:\n        raise ValueError(\"titiler_endpoint must be a string.\")\n\n    return r[\"bounds\"]\n</code></pre>"},{"location":"common/#beamgis.common.mosaic_info","title":"<code>mosaic_info(url, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the info of a MosaicJSON.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a MosaicJSON.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing bounds, center, minzoom, maxzoom, and name as keys.</p> Source code in <code>beamgis/common.py</code> <pre><code>def mosaic_info(url, titiler_endpoint=None, **kwargs):\n    \"\"\"Get the info of a MosaicJSON.\n\n    Args:\n        url (str): HTTP URL to a MosaicJSON.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n\n    Returns:\n        dict: A dictionary containing bounds, center, minzoom, maxzoom, and name as keys.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if isinstance(url, str) and url.startswith(\"http\"):\n        kwargs[\"url\"] = url\n    else:\n        raise ValueError(\"url must be a string and start with http.\")\n\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/info\",\n            params=kwargs,\n        ).json()\n    else:\n        raise ValueError(\"titiler_endpoint must be a string.\")\n\n    return r\n</code></pre>"},{"location":"common/#beamgis.common.mosaic_info_geojson","title":"<code>mosaic_info_geojson(url, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the info of a MosaicJSON.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a MosaicJSON.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representing a dict of GeoJSON.</p> Source code in <code>beamgis/common.py</code> <pre><code>def mosaic_info_geojson(url, titiler_endpoint=None, **kwargs):\n    \"\"\"Get the info of a MosaicJSON.\n\n    Args:\n        url (str): HTTP URL to a MosaicJSON.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n\n    Returns:\n        dict: A dictionary representing a dict of GeoJSON.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if isinstance(url, str) and url.startswith(\"http\"):\n        kwargs[\"url\"] = url\n    else:\n        raise ValueError(\"url must be a string and start with http.\")\n\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/info.geojson\",\n            params=kwargs,\n        ).json()\n    else:\n        raise ValueError(\"titiler_endpoint must be a string.\")\n\n    return r\n</code></pre>"},{"location":"common/#beamgis.common.mosaic_tile","title":"<code>mosaic_tile(url, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the tile URL from a MosaicJSON.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a MosaicJSON.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The tile URL.</p> Source code in <code>beamgis/common.py</code> <pre><code>def mosaic_tile(url, titiler_endpoint=None, **kwargs):\n    \"\"\"Get the tile URL from a MosaicJSON.\n\n    Args:\n        url (str): HTTP URL to a MosaicJSON.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n\n    Returns:\n        str: The tile URL.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if isinstance(url, str) and url.startswith(\"http\"):\n        kwargs[\"url\"] = url\n    else:\n        raise ValueError(\"url must be a string and start with http.\")\n\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/tilejson.json\",\n            params=kwargs,\n        ).json()\n    else:\n        raise ValueError(\"titiler_endpoint must be a string.\")\n\n    return r[\"tiles\"][0]\n</code></pre>"},{"location":"common/#beamgis.common.nasa_data_download","title":"<code>nasa_data_download(granules, out_dir=None, provider=None, threads=8)</code>","text":"<p>Downloads NASA Earthdata granules.</p> <p>Parameters:</p> Name Type Description Default <code>granules</code> <code>List[dict]</code> <p>The granules to download.</p> required <code>out_dir</code> <code>str</code> <p>The output directory where the granules will be downloaded. Defaults to None (current directory).</p> <code>None</code> <code>provider</code> <code>str</code> <p>The provider of the granules.</p> <code>None</code> <code>threads</code> <code>int</code> <p>The number of threads to use for downloading. Defaults to 8.</p> <code>8</code> Source code in <code>beamgis/common.py</code> <pre><code>def nasa_data_download(\n    granules: List[dict],\n    out_dir: Optional[str] = None,\n    provider: Optional[str] = None,\n    threads: int = 8,\n) -&gt; None:\n    \"\"\"Downloads NASA Earthdata granules.\n\n    Args:\n        granules (List[dict]): The granules to download.\n        out_dir (str, optional): The output directory where the granules will be downloaded. Defaults to None (current directory).\n        provider (str, optional): The provider of the granules.\n        threads (int, optional): The number of threads to use for downloading. Defaults to 8.\n    \"\"\"\n    import earthaccess\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    earthaccess.download(\n        granules, local_path=out_dir, provider=provider, threads=threads\n    )\n</code></pre>"},{"location":"common/#beamgis.common.nasa_data_granules_to_gdf","title":"<code>nasa_data_granules_to_gdf(granules, crs='EPSG:4326', output=None, **kwargs)</code>","text":"<p>Converts granules data to a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>granules</code> <code>List[dict]</code> <p>A list of granules.</p> required <code>crs</code> <code>str</code> <p>The coordinate reference system (CRS) of the GeoDataFrame. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>output</code> <code>str</code> <p>The output file path to save the GeoDataFrame as a file. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the gpd.GeoDataFrame.to_file() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>The resulting GeoDataFrame.</p> Source code in <code>beamgis/common.py</code> <pre><code>def nasa_data_granules_to_gdf(\n    granules: List[dict], crs: str = \"EPSG:4326\", output: str = None, **kwargs\n):\n    \"\"\"Converts granules data to a GeoDataFrame.\n\n    Args:\n        granules (List[dict]): A list of granules.\n        crs (str, optional): The coordinate reference system (CRS) of the GeoDataFrame. Defaults to \"EPSG:4326\".\n        output (str, optional): The output file path to save the GeoDataFrame as a file. Defaults to None.\n        **kwargs: Additional keyword arguments for the gpd.GeoDataFrame.to_file() function.\n\n    Returns:\n        gpd.GeoDataFrame: The resulting GeoDataFrame.\n    \"\"\"\n    import pandas as pd\n    import geopandas as gpd\n    from shapely.geometry import box, Polygon\n\n    df = pd.json_normalize([dict(i.items()) for i in granules])\n    df.columns = [col.split(\".\")[-1] for col in df.columns]\n    df = df.drop(\"Version\", axis=1)\n\n    def get_bbox(rectangles):\n        xmin = min(rectangle[\"WestBoundingCoordinate\"] for rectangle in rectangles)\n        ymin = min(rectangle[\"SouthBoundingCoordinate\"] for rectangle in rectangles)\n        xmax = max(rectangle[\"EastBoundingCoordinate\"] for rectangle in rectangles)\n        ymax = max(rectangle[\"NorthBoundingCoordinate\"] for rectangle in rectangles)\n\n        bbox = (xmin, ymin, xmax, ymax)\n        return bbox\n\n    def get_polygon(coordinates):\n        # Extract the points from the dictionary\n        points = [\n            (point[\"Longitude\"], point[\"Latitude\"])\n            for point in coordinates[0][\"Boundary\"][\"Points\"]\n        ]\n\n        # Create a Polygon\n        polygon = Polygon(points)\n        return polygon\n\n    if \"BoundingRectangles\" in df.columns:\n        df[\"bbox\"] = df[\"BoundingRectangles\"].apply(get_bbox)\n        df[\"geometry\"] = df[\"bbox\"].apply(lambda x: box(*x))\n    elif \"GPolygons\" in df.columns:\n        df[\"geometry\"] = df[\"GPolygons\"].apply(get_polygon)\n\n    gdf = gpd.GeoDataFrame(df, geometry=\"geometry\")\n\n    gdf.crs = crs\n\n    if output is not None:\n        for column in gdf.columns:\n            if gdf[column].apply(lambda x: isinstance(x, list)).any():\n                gdf[column] = gdf[column].apply(lambda x: str(x))\n\n        gdf.to_file(output, **kwargs)\n\n    return gdf\n</code></pre>"},{"location":"common/#beamgis.common.nasa_data_login","title":"<code>nasa_data_login(strategy='all', persist=True, **kwargs)</code>","text":"<p>Logs in to NASA Earthdata.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>str</code> <p>The authentication method. \"all\": (default) try all methods until one works \"interactive\": enter username and password. \"netrc\": retrieve username and password from ~/.netrc. \"environment\": retrieve username and password from $EARTHDATA_USERNAME and $EARTHDATA_PASSWORD.</p> <code>'all'</code> <code>persist</code> <code>bool</code> <p>Whether to persist credentials in a .netrc file. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments for the earthaccess.login() function.</p> <code>{}</code> Source code in <code>beamgis/common.py</code> <pre><code>def nasa_data_login(strategy: str = \"all\", persist: bool = True, **kwargs) -&gt; None:\n    \"\"\"Logs in to NASA Earthdata.\n\n    Args:\n        strategy (str, optional): The authentication method.\n            \"all\": (default) try all methods until one works\n            \"interactive\": enter username and password.\n            \"netrc\": retrieve username and password from ~/.netrc.\n            \"environment\": retrieve username and password from $EARTHDATA_USERNAME and $EARTHDATA_PASSWORD.\n        persist (bool, optional): Whether to persist credentials in a .netrc file. Defaults to True.\n        **kwargs: Additional keyword arguments for the earthaccess.login() function.\n    \"\"\"\n    try:\n        import earthaccess\n    except ImportError:\n        install_package(\"earthaccess\")\n        import earthaccess\n\n    try:\n        earthaccess.login(strategy=strategy, persist=persist, **kwargs)\n    except:\n        print(\n            \"Please login to Earthdata first. Register at https://urs.earthdata.nasa.gov\"\n        )\n</code></pre>"},{"location":"common/#beamgis.common.nasa_data_search","title":"<code>nasa_data_search(count=-1, short_name=None, bbox=None, temporal=None, version=None, doi=None, daac=None, provider=None, output=None, crs='EPSG:4326', return_gdf=False, **kwargs)</code>","text":"<p>Searches for NASA Earthdata granules.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of granules to retrieve. Defaults to -1 (retrieve all).</p> <code>-1</code> <code>short_name</code> <code>str</code> <p>The short name of the dataset.</p> <code>None</code> <code>bbox</code> <code>List[float]</code> <p>The bounding box coordinates [xmin, ymin, xmax, ymax].</p> <code>None</code> <code>temporal</code> <code>str</code> <p>The temporal extent of the data.</p> <code>None</code> <code>version</code> <code>str</code> <p>The version of the dataset.</p> <code>None</code> <code>doi</code> <code>str</code> <p>The Digital Object Identifier (DOI) of the dataset.</p> <code>None</code> <code>daac</code> <code>str</code> <p>The Distributed Active Archive Center (DAAC) of the dataset.</p> <code>None</code> <code>provider</code> <code>str</code> <p>The provider of the dataset.</p> <code>None</code> <code>output</code> <code>str</code> <p>The output file path to save the GeoDataFrame as a file.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The coordinate reference system (CRS) of the GeoDataFrame. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>return_gdf</code> <code>bool</code> <p>Whether to return the GeoDataFrame in addition to the granules. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments for the earthaccess.search_data() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[List[dict], tuple]</code> <p>The retrieved granules. If return_gdf is True, also returns the resulting GeoDataFrame.</p> Source code in <code>beamgis/common.py</code> <pre><code>def nasa_data_search(\n    count: int = -1,\n    short_name: Optional[str] = None,\n    bbox: Optional[List[float]] = None,\n    temporal: Optional[str] = None,\n    version: Optional[str] = None,\n    doi: Optional[str] = None,\n    daac: Optional[str] = None,\n    provider: Optional[str] = None,\n    output: Optional[str] = None,\n    crs: str = \"EPSG:4326\",\n    return_gdf: bool = False,\n    **kwargs,\n) -&gt; Union[List[dict], tuple]:\n    \"\"\"Searches for NASA Earthdata granules.\n\n    Args:\n        count (int, optional): The number of granules to retrieve. Defaults to -1 (retrieve all).\n        short_name (str, optional): The short name of the dataset.\n        bbox (List[float], optional): The bounding box coordinates [xmin, ymin, xmax, ymax].\n        temporal (str, optional): The temporal extent of the data.\n        version (str, optional): The version of the dataset.\n        doi (str, optional): The Digital Object Identifier (DOI) of the dataset.\n        daac (str, optional): The Distributed Active Archive Center (DAAC) of the dataset.\n        provider (str, optional): The provider of the dataset.\n        output (str, optional): The output file path to save the GeoDataFrame as a file.\n        crs (str, optional): The coordinate reference system (CRS) of the GeoDataFrame. Defaults to \"EPSG:4326\".\n        return_gdf (bool, optional): Whether to return the GeoDataFrame in addition to the granules. Defaults to False.\n        **kwargs: Additional keyword arguments for the earthaccess.search_data() function.\n\n    Returns:\n        Union[List[dict], tuple]: The retrieved granules. If return_gdf is True, also returns the resulting GeoDataFrame.\n    \"\"\"\n    try:\n        import earthaccess\n    except ImportError:\n        install_package(\"earthaccess\")\n\n    if short_name is not None:\n        kwargs[\"short_name\"] = short_name\n    if bbox is not None:\n        kwargs[\"bounding_box\"] = bbox\n    if temporal is not None:\n        kwargs[\"temporal\"] = temporal\n    if version is not None:\n        kwargs[\"version\"] = version\n    if doi is not None:\n        kwargs[\"doi\"] = doi\n    if daac is not None:\n        kwargs[\"daac\"] = daac\n    if provider is not None:\n        kwargs[\"provider\"] = provider\n\n    granules = earthaccess.search_data(\n        count=count,\n        **kwargs,\n    )\n\n    if output is not None:\n        nasa_data_granules_to_gdf(granules, crs=crs, output=output)\n\n    if return_gdf:\n        gdf = nasa_data_granules_to_gdf(granules, crs=crs)\n        return granules, gdf\n    else:\n        return granules\n</code></pre>"},{"location":"common/#beamgis.common.nasa_datasets","title":"<code>nasa_datasets(keyword=None, df=None, return_short_name=False)</code>","text":"<p>Searches for NASA datasets based on a keyword in a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for. Defaults to None.</p> <code>None</code> <code>df</code> <code>pd.DataFrame</code> <p>The DataFrame to search in. If None, it will download the NASA dataset CSV from GitHub. Defaults to None.</p> <code>None</code> <code>return_short_name</code> <code>bool</code> <p>If True, only returns the list of short names of the matched datasets. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[pd.DataFrame, List[str]]</code> <p>Filtered DataFrame if return_short_name is False, otherwise a list of short names.</p> Source code in <code>beamgis/common.py</code> <pre><code>def nasa_datasets(keyword=None, df=None, return_short_name=False):\n    \"\"\"\n    Searches for NASA datasets based on a keyword in a DataFrame.\n\n    Args:\n        keyword (str, optional): The keyword to search for. Defaults to None.\n        df (pd.DataFrame, optional): The DataFrame to search in. If None, it will download the NASA dataset CSV from GitHub. Defaults to None.\n        return_short_name (bool, optional): If True, only returns the list of short names of the matched datasets. Defaults to False.\n\n    Returns:\n        Union[pd.DataFrame, List[str]]: Filtered DataFrame if return_short_name is False, otherwise a list of short names.\n\n    \"\"\"\n    import pandas as pd\n\n    if df is None:\n        url = \"https://github.com/opengeos/NASA-Earth-Data/raw/main/nasa_earth_data.tsv\"\n        df = pd.read_csv(url, sep=\"\\t\")\n\n    if keyword is not None:\n        # Convert keyword and DataFrame values to lowercase\n        keyword_lower = keyword.lower()\n        df_lower = df.applymap(lambda x: x.lower() if isinstance(x, str) else x)\n\n        # Use boolean indexing to filter the DataFrame\n        filtered_df = df[\n            df_lower.astype(str).apply(lambda x: keyword_lower in \" \".join(x), axis=1)\n        ].reset_index(drop=True)\n\n        if return_short_name:\n            return filtered_df[\"ShortName\"].tolist()\n        else:\n            return filtered_df\n    else:\n        if return_short_name:\n            return df[\"ShortName\"].tolist()\n        else:\n            return df\n</code></pre>"},{"location":"common/#beamgis.common.netcdf_tile_layer","title":"<code>netcdf_tile_layer(filename, variables=None, colormap=None, vmin=None, vmax=None, nodata=None, port='default', debug=False, attribution=None, tile_format='ipyleaflet', layer_name='NetCDF layer', return_client=False, shift_lon=True, lat='lat', lon='lon', **kwargs)</code>","text":"<p>Generate an ipyleaflet/folium TileLayer from a netCDF file.     If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),     try adding to following two lines to the beginning of the notebook if the raster does not render properly.</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>File path or HTTP URL to the netCDF file.</p> required <code>variables</code> <code>int</code> <p>The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.</p> <code>None</code> <code>port</code> <code>str</code> <p>The port to use for the server. Defaults to \"default\".</p> <code>'default'</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>If True, the server will be started in debug mode. Defaults to False.</p> <code>False</code> <code>projection</code> <code>str</code> <p>The projection of the GeoTIFF. Defaults to \"EPSG:3857\".</p> required <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>tile_format</code> <code>str</code> <p>The tile layer format. Can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to \"NetCDF layer\".</p> <code>'NetCDF layer'</code> <code>return_client</code> <code>bool</code> <p>If True, the tile client will be returned. Defaults to False.</p> <code>False</code> <code>shift_lon</code> <code>bool</code> <p>Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.</p> <code>True</code> <code>lat</code> <code>str</code> <p>Name of the latitude variable. Defaults to 'lat'.</p> <code>'lat'</code> <code>lon</code> <code>str</code> <p>Name of the longitude variable. Defaults to 'lon'.</p> <code>'lon'</code> <p>Returns:</p> Type Description <code>ipyleaflet.TileLayer | folium.TileLayer</code> <p>An ipyleaflet.TileLayer or folium.TileLayer.</p> Source code in <code>beamgis/common.py</code> <pre><code>def netcdf_tile_layer(\n    filename,\n    variables=None,\n    colormap=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    port=\"default\",\n    debug=False,\n    attribution=None,\n    tile_format=\"ipyleaflet\",\n    layer_name=\"NetCDF layer\",\n    return_client=False,\n    shift_lon=True,\n    lat=\"lat\",\n    lon=\"lon\",\n    **kwargs,\n):\n    \"\"\"Generate an ipyleaflet/folium TileLayer from a netCDF file.\n        If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),\n        try adding to following two lines to the beginning of the notebook if the raster does not render properly.\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n\n    Args:\n        filename (str): File path or HTTP URL to the netCDF file.\n        variables (int, optional): The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.\n        port (str, optional): The port to use for the server. Defaults to \"default\".\n        colormap (str, optional): The name of the colormap from `matplotlib` to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.\n        vmin (float, optional): The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        debug (bool, optional): If True, the server will be started in debug mode. Defaults to False.\n        projection (str, optional): The projection of the GeoTIFF. Defaults to \"EPSG:3857\".\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        tile_format (str, optional): The tile layer format. Can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n        layer_name (str, optional): The layer name to use. Defaults to \"NetCDF layer\".\n        return_client (bool, optional): If True, the tile client will be returned. Defaults to False.\n        shift_lon (bool, optional): Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.\n        lat (str, optional): Name of the latitude variable. Defaults to 'lat'.\n        lon (str, optional): Name of the longitude variable. Defaults to 'lon'.\n\n    Returns:\n        ipyleaflet.TileLayer | folium.TileLayer: An ipyleaflet.TileLayer or folium.TileLayer.\n    \"\"\"\n\n    check_package(\n        \"localtileserver\", URL=\"https://github.com/banesullivan/localtileserver\"\n    )\n\n    try:\n        import xarray as xr\n    except ImportError as e:\n        raise ImportError(e)\n\n    if filename.startswith(\"http\"):\n        filename = download_file(filename)\n\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"{filename} does not exist.\")\n\n    output = filename.replace(\".nc\", \".tif\")\n\n    xds = xr.open_dataset(filename, **kwargs)\n\n    if shift_lon:\n        xds.coords[lon] = (xds.coords[lon] + 180) % 360 - 180\n        xds = xds.sortby(xds.lon)\n\n    allowed_vars = list(xds.data_vars.keys())\n    if isinstance(variables, str):\n        if variables not in allowed_vars:\n            raise ValueError(f\"{variables} is not a subset of {allowed_vars}.\")\n        variables = [variables]\n\n    if variables is not None and len(variables) &gt; 3:\n        raise ValueError(\"Only 3 variables can be plotted at a time.\")\n\n    if variables is not None and (not set(variables).issubset(allowed_vars)):\n        raise ValueError(f\"{variables} must be a subset of {allowed_vars}.\")\n\n    xds.rio.set_spatial_dims(x_dim=lon, y_dim=lat).rio.to_raster(output)\n    if variables is None:\n        if len(allowed_vars) &gt;= 3:\n            band_idx = [1, 2, 3]\n        else:\n            band_idx = [1]\n    else:\n        band_idx = [allowed_vars.index(var) + 1 for var in variables]\n\n    tile_layer = get_local_tile_layer(\n        output,\n        port=port,\n        debug=debug,\n        indexes=band_idx,\n        colormap=colormap,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        tile_format=tile_format,\n        layer_name=layer_name,\n        return_client=return_client,\n    )\n    return tile_layer\n</code></pre>"},{"location":"common/#beamgis.common.netcdf_to_tif","title":"<code>netcdf_to_tif(filename, output=None, variables=None, shift_lon=True, lat='lat', lon='lon', lev='lev', level_index=0, time=0, crs='epsg:4326', return_vars=False, **kwargs)</code>","text":"<p>Convert a netcdf file to a GeoTIFF file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the netcdf file.</p> required <code>output</code> <code>str</code> <p>Path to the output GeoTIFF file. Defaults to None. If None, the output file will be the same as the input file with the extension changed to .tif.</p> <code>None</code> <code>variables</code> <code>str | list</code> <p>Name of the variable or a list of variables to extract. Defaults to None. If None, all variables will be extracted.</p> <code>None</code> <code>shift_lon</code> <code>bool</code> <p>Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.</p> <code>True</code> <code>lat</code> <code>str</code> <p>Name of the latitude variable. Defaults to 'lat'.</p> <code>'lat'</code> <code>lon</code> <code>str</code> <p>Name of the longitude variable. Defaults to 'lon'.</p> <code>'lon'</code> <code>lev</code> <code>str</code> <p>Name of the level variable. Defaults to 'lev'.</p> <code>'lev'</code> <code>level_index</code> <code>int</code> <p>Index of the level dimension. Defaults to 0'.</p> <code>0</code> <code>time</code> <code>int</code> <p>Index of the time dimension. Defaults to 0'.</p> <code>0</code> <code>crs</code> <code>str</code> <p>The coordinate reference system. Defaults to 'epsg:4326'.</p> <code>'epsg:4326'</code> <code>return_vars</code> <code>bool</code> <p>Flag to return all variables. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the xarray or rioxarray package is not installed.</p> <code>FileNotFoundError</code> <p>If the netcdf file is not found.</p> <code>ValueError</code> <p>If the variable is not found in the netcdf file.</p> Source code in <code>beamgis/common.py</code> <pre><code>def netcdf_to_tif(\n    filename,\n    output=None,\n    variables=None,\n    shift_lon=True,\n    lat=\"lat\",\n    lon=\"lon\",\n    lev=\"lev\",\n    level_index=0,\n    time=0,\n    crs=\"epsg:4326\",\n    return_vars=False,\n    **kwargs,\n):\n    \"\"\"Convert a netcdf file to a GeoTIFF file.\n\n    Args:\n        filename (str): Path to the netcdf file.\n        output (str, optional): Path to the output GeoTIFF file. Defaults to None. If None, the output file will be the same as the input file with the extension changed to .tif.\n        variables (str | list, optional): Name of the variable or a list of variables to extract. Defaults to None. If None, all variables will be extracted.\n        shift_lon (bool, optional): Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.\n        lat (str, optional): Name of the latitude variable. Defaults to 'lat'.\n        lon (str, optional): Name of the longitude variable. Defaults to 'lon'.\n        lev (str, optional): Name of the level variable. Defaults to 'lev'.\n        level_index (int, optional): Index of the level dimension. Defaults to 0'.\n        time (int, optional): Index of the time dimension. Defaults to 0'.\n        crs (str, optional): The coordinate reference system. Defaults to 'epsg:4326'.\n        return_vars (bool, optional): Flag to return all variables. Defaults to False.\n\n    Raises:\n        ImportError: If the xarray or rioxarray package is not installed.\n        FileNotFoundError: If the netcdf file is not found.\n        ValueError: If the variable is not found in the netcdf file.\n    \"\"\"\n    try:\n        import xarray as xr\n    except ImportError as e:\n        raise ImportError(e)\n\n    if filename.startswith(\"http\"):\n        filename = download_file(filename)\n\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"{filename} does not exist.\")\n\n    if output is None:\n        ext = os.path.splitext(filename)[1].lower()\n        if ext not in [\".nc\", \".nc4\"]:\n            raise TypeError(\n                \"The output file must be a netCDF with extension .nc or .nc4.\"\n            )\n        output = filename.replace(ext, \".tif\")\n    else:\n        output = check_file_path(output)\n\n    xds = xr.open_dataset(filename, **kwargs)\n\n    coords = list(xds.coords.keys())\n    if \"time\" in coords:\n        xds = xds.isel(time=time, drop=True)\n\n    if lev in coords:\n        xds = xds.isel(lev=level_index, drop=True)\n\n    if shift_lon:\n        xds.coords[lon] = (xds.coords[lon] + 180) % 360 - 180\n        xds = xds.sortby(xds[lon])\n\n    allowed_vars = list(xds.data_vars.keys())\n    if isinstance(variables, str):\n        if variables not in allowed_vars:\n            raise ValueError(f\"{variables} is not a valid variable.\")\n        variables = [variables]\n\n    if variables is not None and (not set(variables).issubset(allowed_vars)):\n        raise ValueError(f\"{variables} must be a subset of {allowed_vars}.\")\n\n    if variables is None:\n        xds.rio.set_spatial_dims(x_dim=lon, y_dim=lat).rio.write_crs(crs).rio.to_raster(\n            output\n        )\n    else:\n        xds[variables].rio.set_spatial_dims(x_dim=lon, y_dim=lat).rio.write_crs(\n            crs\n        ).rio.to_raster(output)\n\n    if return_vars:\n        return output, allowed_vars\n    else:\n        return output\n</code></pre>"},{"location":"common/#beamgis.common.numpy_to_cog","title":"<code>numpy_to_cog(np_array, out_cog, bounds=None, profile=None, dtype=None, dst_crs=None, coord_crs=None)</code>","text":"<p>Converts a numpy array to a COG file.</p> <p>Parameters:</p> Name Type Description Default <code>np_array</code> <code>np.array</code> <p>A numpy array representing an image or an HTTP URL to an image.</p> required <code>out_cog</code> <code>str</code> <p>The output COG file path.</p> required <code>bounds</code> <code>tuple</code> <p>The bounds of the image in the format of (minx, miny, maxx, maxy). Defaults to None.</p> <code>None</code> <code>profile</code> <code>str | dict</code> <p>File path to an existing COG file or a dictionary representing the profile. Defaults to None.</p> <code>None</code> <code>dtype</code> <code>str</code> <p>The data type of the output COG file. Defaults to None.</p> <code>None</code> <code>dst_crs</code> <code>str</code> <p>The coordinate reference system of the output COG file. Defaults to \"epsg:4326\".</p> <code>None</code> <code>coord_crs</code> <code>str</code> <p>The coordinate reference system of bbox coordinates. Defaults to None.</p> <code>None</code> Source code in <code>beamgis/common.py</code> <pre><code>def numpy_to_cog(\n    np_array,\n    out_cog,\n    bounds=None,\n    profile=None,\n    dtype=None,\n    dst_crs=None,\n    coord_crs=None,\n):\n    \"\"\"Converts a numpy array to a COG file.\n\n    Args:\n        np_array (np.array): A numpy array representing an image or an HTTP URL to an image.\n        out_cog (str): The output COG file path.\n        bounds (tuple, optional): The bounds of the image in the format of (minx, miny, maxx, maxy). Defaults to None.\n        profile (str | dict, optional): File path to an existing COG file or a dictionary representing the profile. Defaults to None.\n        dtype (str, optional): The data type of the output COG file. Defaults to None.\n        dst_crs (str, optional): The coordinate reference system of the output COG file. Defaults to \"epsg:4326\".\n        coord_crs (str, optional): The coordinate reference system of bbox coordinates. Defaults to None.\n\n    \"\"\"\n\n    import numpy as np\n    import rasterio\n    from rasterio.io import MemoryFile\n    from rasterio.transform import from_bounds\n\n    from rio_cogeo.cogeo import cog_translate\n    from rio_cogeo.profiles import cog_profiles\n\n    warnings.filterwarnings(\"ignore\")\n\n    if isinstance(np_array, str):\n        with rasterio.open(np_array, \"r\") as ds:\n            np_array = ds.read()\n\n    if not isinstance(np_array, np.ndarray):\n        raise TypeError(\"The input array must be a numpy array.\")\n\n    out_dir = os.path.dirname(out_cog)\n    check_dir(out_dir)\n\n    if profile is not None:\n        if isinstance(profile, str):\n            if (not profile.startswith(\"http\")) and (not os.path.exists(profile)):\n                raise FileNotFoundError(\"The provided file could not be found.\")\n            with rasterio.open(profile) as ds:\n                dst_crs = ds.crs\n                if bounds is None:\n                    bounds = ds.bounds\n\n        elif isinstance(profile, rasterio.profiles.Profile):\n            profile = dict(profile)\n        elif not isinstance(profile, dict):\n            raise TypeError(\"The provided profile must be a file path or a dictionary.\")\n\n    if bounds is None:\n        print(\n            \"warning: bounds is not set. Using the default bounds (-180.0, -85.0511, 180.0, 85.0511)\"\n        )\n        bounds = (-180.0, -85.0511287798066, 180.0, 85.0511287798066)\n\n    if not isinstance(bounds, tuple) and len(bounds) != 4:\n        raise TypeError(\"The provided bounds must be a tuple of length 4.\")\n\n    # Rasterio uses numpy array of shape of `(bands, height, width)`\n\n    if len(np_array.shape) == 3:\n        nbands = np_array.shape[0]\n        height = np_array.shape[1]\n        width = np_array.shape[2]\n    elif len(np_array.shape) == 2:\n        nbands = 1\n        height = np_array.shape[0]\n        width = np_array.shape[1]\n        np_array = np_array.reshape((1, height, width))\n    else:\n        raise ValueError(\"The input array must be a 2D or 3D numpy array.\")\n\n    if coord_crs is not None and dst_crs is not None:\n        bounds = transform_bbox_coords(bounds, coord_crs, dst_crs)\n\n    src_transform = from_bounds(*bounds, width=width, height=height)\n    if dtype is None:\n        dtype = str(np_array.dtype)\n\n    if dst_crs is None:\n        dst_crs = \"epsg:4326\"\n\n    if isinstance(profile, dict):\n        src_profile = profile\n        src_profile[\"count\"] = nbands\n    else:\n        src_profile = dict(\n            driver=\"GTiff\",\n            dtype=dtype,\n            count=nbands,\n            height=height,\n            width=width,\n            crs=dst_crs,\n            transform=src_transform,\n        )\n\n    with MemoryFile() as memfile:\n        with memfile.open(**src_profile) as mem:\n            # Populate the input file with numpy array\n            mem.write(np_array)\n\n            dst_profile = cog_profiles.get(\"deflate\")\n            cog_translate(\n                mem,\n                out_cog,\n                dst_profile,\n                in_memory=True,\n                quiet=True,\n            )\n</code></pre>"},{"location":"common/#beamgis.common.numpy_to_image","title":"<code>numpy_to_image(np_array, filename, transpose=True, bands=None, size=None, resize_args=None, **kwargs)</code>","text":"<p>Converts a numpy array to an image in the specified format, such as JPG, PNG, TIFF, etc.</p> <p>Parameters:</p> Name Type Description Default <code>np_array</code> <code>np.ndarray</code> <p>A numpy array or a path to a raster file.</p> required <code>filename</code> <code>str</code> <p>The output filename.</p> required <code>transpose</code> <code>bool</code> <p>Whether to transpose the array from (bands, rows, cols) to (rows, cols, bands). Defaults to True.</p> <code>True</code> <code>bands</code> <code>int | list</code> <p>The band(s) to use, starting from 0. Defaults to None.</p> <code>None</code> Source code in <code>beamgis/common.py</code> <pre><code>def numpy_to_image(\n    np_array,\n    filename: str,\n    transpose: bool = True,\n    bands: Union[int, list] = None,\n    size: Tuple = None,\n    resize_args: dict = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Converts a numpy array to an image in the specified format, such as JPG, PNG, TIFF, etc.\n\n    Args:\n        np_array (np.ndarray): A numpy array or a path to a raster file.\n        filename (str): The output filename.\n        transpose (bool, optional): Whether to transpose the array from (bands, rows, cols) to (rows, cols, bands). Defaults to True.\n        bands (int | list, optional): The band(s) to use, starting from 0. Defaults to None.\n\n    \"\"\"\n\n    import numpy as np\n    from PIL import Image\n\n    warnings.filterwarnings(\"ignore\")\n\n    if isinstance(np_array, str):\n        np_array = image_to_numpy(np_array)\n\n    if not isinstance(np_array, np.ndarray):\n        raise TypeError(\"The provided input must be a numpy array.\")\n\n    if np_array.dtype == np.float64 or np_array.dtype == np.float32:\n        # Convert the array to uint8\n        # np_array = (np_array * 255).astype(np.uint8)\n        np.interp(np_array, (np_array.min(), np_array.max()), (0, 255)).astype(np.uint8)\n    else:\n        # The array is already uint8\n        np_array = np_array\n\n    if np_array.ndim == 2:\n        img = Image.fromarray(np_array)\n    elif np_array.ndim == 3:\n        if transpose:\n            np_array = np_array.transpose(1, 2, 0)\n        if bands is None:\n            if np_array.shape[2] &lt; 3:\n                np_array = np_array[:, :, 0]\n            elif np_array.shape[2] &gt; 3:\n                np_array = np_array[:, :, :3]\n\n        elif isinstance(bands, list):\n            if len(bands) == 1:\n                np_array = np_array[:, :, bands[0]]\n            else:\n                np_array = np_array[:, :, bands]\n        elif isinstance(bands, int):\n            np_array = np_array[:, :, bands]\n        img = Image.fromarray(np_array)\n    else:\n        raise ValueError(\"The provided input must be a 2D or 3D numpy array.\")\n\n    if isinstance(size, tuple):\n        try:\n            from skimage.transform import resize\n        except ImportError:\n            raise ImportError(\n                \"The scikit-image package is not installed. Please install it with `pip install scikit-image` \\\n                  or `conda install scikit-image -c conda-forge`.\"\n            )\n        if resize_args is None:\n            resize_args = {}\n        if \"preserve_range\" not in resize_args:\n            resize_args[\"preserve_range\"] = True\n        np_array = resize(np_array, size, **resize_args).astype(\"uint8\")\n        img = Image.fromarray(np_array)\n\n    img.save(filename, **kwargs)\n</code></pre>"},{"location":"common/#beamgis.common.open_image_from_url","title":"<code>open_image_from_url(url)</code>","text":"<p>Loads an image from the specified URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the image.</p> required <p>Returns:</p> Type Description <code>object</code> <p>Image object.</p> Source code in <code>beamgis/common.py</code> <pre><code>def open_image_from_url(url: str):\n    \"\"\"Loads an image from the specified URL.\n\n    Args:\n        url (str): URL of the image.\n\n    Returns:\n        object: Image object.\n    \"\"\"\n    from PIL import Image\n\n    from io import BytesIO\n\n    # from urllib.parse import urlparse\n\n    try:\n        response = requests.get(url)\n        img = Image.open(BytesIO(response.content))\n        return img\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#beamgis.common.overlay_images","title":"<code>overlay_images(image1, image2, alpha=0.5, backend='TkAgg', height_ratios=[10, 1], show_args1={}, show_args2={})</code>","text":"<p>Overlays two images using a slider to control the opacity of the top image.</p> <p>Parameters:</p> Name Type Description Default <code>image1</code> <code>str | np.ndarray</code> <p>The first input image at the bottom represented as a NumPy array or the path to the image.</p> required <code>image2</code> <code>_type_</code> <p>The second input image on top represented as a NumPy array or the path to the image.</p> required <code>alpha</code> <code>float</code> <p>The alpha value of the top image. Defaults to 0.5.</p> <code>0.5</code> <code>backend</code> <code>str</code> <p>The backend of the matplotlib plot. Defaults to \"TkAgg\".</p> <code>'TkAgg'</code> <code>height_ratios</code> <code>list</code> <p>The height ratios of the two subplots. Defaults to [10, 1].</p> <code>[10, 1]</code> <code>show_args1</code> <code>dict</code> <p>The keyword arguments to pass to the imshow() function for the first image. Defaults to {}.</p> <code>{}</code> <code>show_args2</code> <code>dict</code> <p>The keyword arguments to pass to the imshow() function for the second image. Defaults to {}.</p> <code>{}</code> Source code in <code>beamgis/common.py</code> <pre><code>def overlay_images(\n    image1,\n    image2,\n    alpha=0.5,\n    backend=\"TkAgg\",\n    height_ratios=[10, 1],\n    show_args1={},\n    show_args2={},\n):\n    \"\"\"Overlays two images using a slider to control the opacity of the top image.\n\n    Args:\n        image1 (str | np.ndarray): The first input image at the bottom represented as a NumPy array or the path to the image.\n        image2 (_type_): The second input image on top represented as a NumPy array or the path to the image.\n        alpha (float, optional): The alpha value of the top image. Defaults to 0.5.\n        backend (str, optional): The backend of the matplotlib plot. Defaults to \"TkAgg\".\n        height_ratios (list, optional): The height ratios of the two subplots. Defaults to [10, 1].\n        show_args1 (dict, optional): The keyword arguments to pass to the imshow() function for the first image. Defaults to {}.\n        show_args2 (dict, optional): The keyword arguments to pass to the imshow() function for the second image. Defaults to {}.\n\n    \"\"\"\n    import sys\n    import matplotlib\n    import matplotlib.pyplot as plt\n    import matplotlib.widgets as mpwidgets\n\n    if \"google.colab\" in sys.modules:\n        backend = \"inline\"\n        print(\n            \"The TkAgg backend is not supported in Google Colab. The overlay_images function will not work on Colab.\"\n        )\n        return\n\n    matplotlib.use(backend)\n\n    if isinstance(image1, str):\n        if image1.startswith(\"http\"):\n            image1 = download_file(image1)\n\n        if not os.path.exists(image1):\n            raise ValueError(f\"Input path {image1} does not exist.\")\n\n    if isinstance(image2, str):\n        if image2.startswith(\"http\"):\n            image2 = download_file(image2)\n\n        if not os.path.exists(image2):\n            raise ValueError(f\"Input path {image2} does not exist.\")\n\n    # Load the two images\n    x = plt.imread(image1)\n    y = plt.imread(image2)\n\n    # Create the plot\n    fig, (ax0, ax1) = plt.subplots(2, 1, gridspec_kw={\"height_ratios\": height_ratios})\n    img0 = ax0.imshow(x, **show_args1)\n    img1 = ax0.imshow(y, alpha=alpha, **show_args2)\n\n    # Define the update function\n    def update(value):\n        img1.set_alpha(value)\n        fig.canvas.draw_idle()\n\n    # Create the slider\n    slider0 = mpwidgets.Slider(ax=ax1, label=\"alpha\", valmin=0, valmax=1, valinit=alpha)\n    slider0.on_changed(update)\n\n    # Display the plot\n    plt.show()\n</code></pre>"},{"location":"common/#beamgis.common.pandas_to_geojson","title":"<code>pandas_to_geojson(df, coordinates=['lng', 'lat'], geometry_type='Point', properties=None, output=None)</code>","text":"<p>Convert a DataFrame to a GeoJSON format.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>The input DataFrame containing the data.</p> required <code>coordinates</code> <code>list</code> <p>A list of two column names representing the longitude and latitude coordinates.</p> <code>['lng', 'lat']</code> <code>geometry_type</code> <code>str</code> <p>The type of geometry for the GeoJSON features (e.g., \"Point\", \"LineString\", \"Polygon\").</p> <code>'Point'</code> <code>properties</code> <code>list</code> <p>A list of column names to include in the properties of each GeoJSON feature. If None, all columns except the coordinate columns are included.</p> <code>None</code> <code>output</code> <code>str</code> <p>The file path to save the GeoJSON output. If None, the GeoJSON is not saved to a file.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representing the GeoJSON object.</p> Source code in <code>beamgis/common.py</code> <pre><code>def pandas_to_geojson(\n    df,\n    coordinates=[\"lng\", \"lat\"],\n    geometry_type: str = \"Point\",\n    properties: list = None,\n    output: Optional[str] = None,\n) -&gt; dict:\n    \"\"\"\n    Convert a DataFrame to a GeoJSON format.\n\n    Args:\n        df (pd.DataFrame): The input DataFrame containing the data.\n        coordinates (list): A list of two column names representing the\n            longitude and latitude coordinates.\n        geometry_type (str): The type of geometry for the GeoJSON features\n            (e.g., \"Point\", \"LineString\", \"Polygon\").\n        properties (list): A list of column names to include in the properties\n            of each GeoJSON feature. If None, all columns except the coordinate\n            columns are included.\n        output (str, optional): The file path to save the GeoJSON output. If None,\n            the GeoJSON is not saved to a file.\n\n    Returns:\n        dict: A dictionary representing the GeoJSON object.\n    \"\"\"\n\n    import pandas as pd\n\n    if isinstance(df, str):\n        if df.endswith(\".csv\"):\n            df = pd.read_csv(df)\n        elif df.endswith(\".json\"):\n            df = pd.read_json(df)\n        else:\n            raise ValueError(\"The input file must be a CSV or JSON file.\")\n\n    geojson = {\"type\": \"FeatureCollection\", \"features\": []}\n\n    if properties is None:\n        properties = [col for col in df.columns if col not in coordinates]\n\n    for _, row in df.iterrows():\n        feature = {\n            \"type\": \"Feature\",\n            \"properties\": {},\n            \"geometry\": {\"type\": geometry_type, \"coordinates\": []},\n        }\n        feature[\"geometry\"][\"coordinates\"] = list(row[coordinates])\n        for prop in properties:\n            feature[\"properties\"][prop] = row[prop]\n\n        geojson[\"features\"].append(feature)\n\n    if output:\n        with open(output, \"w\") as f:\n            json.dump(geojson, f, indent=4)\n\n    return geojson\n</code></pre>"},{"location":"common/#beamgis.common.planet_biannual_tiles_tropical","title":"<code>planet_biannual_tiles_tropical(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  bi-annual imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>beamgis/common.py</code> <pre><code>def planet_biannual_tiles_tropical(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet  bi-annual imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    link = planet_biannual_tropical(api_key, token_name)\n    for url in link:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 15]\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"common/#beamgis.common.planet_biannual_tropical","title":"<code>planet_biannual_tropical(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet bi-annual imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>beamgis/common.py</code> <pre><code>def planet_biannual_tropical(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet bi-annual imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    dates = [\n        \"2015-12_2016-05\",\n        \"2016-06_2016-11\",\n        \"2016-12_2017-05\",\n        \"2017-06_2017-11\",\n        \"2017-12_2018-05\",\n        \"2018-06_2018-11\",\n        \"2018-12_2019-05\",\n        \"2019-06_2019-11\",\n        \"2019-12_2020-05\",\n        \"2020-06_2020-08\",\n    ]\n\n    link = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/planet_medres_normalized_analytic_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for d in dates:\n        url = f\"{prefix}{d}{subfix}{api_key}\"\n        link.append(url)\n\n    return link\n</code></pre>"},{"location":"common/#beamgis.common.planet_by_month","title":"<code>planet_by_month(year=2016, month=1, api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Gets Planet global mosaic tile url by month. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>month</code> <code>int</code> <p>The month of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The Planet API key is not provided.</p> <code>ValueError</code> <p>The year is invalid.</p> <code>ValueError</code> <p>The month is invalid.</p> <code>ValueError</code> <p>The month is invalid.</p> <p>Returns:</p> Type Description <code>str</code> <p>A Planet global mosaic tile url.</p> Source code in <code>beamgis/common.py</code> <pre><code>def planet_by_month(\n    year=2016,\n    month=1,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n):\n    \"\"\"Gets Planet global mosaic tile url by month. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: The Planet API key is not provided.\n        ValueError: The year is invalid.\n        ValueError: The month is invalid.\n        ValueError: The month is invalid.\n\n    Returns:\n        str: A Planet global mosaic tile url.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n    # quarter_now = (month_now - 1) // 3 + 1\n\n    if year &gt; year_now:\n        raise ValueError(f\"Year must be between 2016 and {year_now}.\")\n    elif year == year_now and month &gt;= month_now:\n        raise ValueError(f\"Month must be less than {month_now} for year {year_now}\")\n\n    if month &lt; 1 or month &gt; 12:\n        raise ValueError(\"Month must be between 1 and 12.\")\n\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_monthly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    m_str = str(year) + \"_\" + str(month).zfill(2)\n    url = f\"{prefix}{m_str}{subfix}{api_key}\"\n\n    return url\n</code></pre>"},{"location":"common/#beamgis.common.planet_by_quarter","title":"<code>planet_by_quarter(year=2016, quarter=1, api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Gets Planet global mosaic tile url by quarter. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>quarter</code> <code>int</code> <p>The quarter of Planet global mosaic, must be 1-4. Defaults to 1.</p> <code>1</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The Planet API key is not provided.</p> <code>ValueError</code> <p>The year is invalid.</p> <code>ValueError</code> <p>The quarter is invalid.</p> <code>ValueError</code> <p>The quarter is invalid.</p> <p>Returns:</p> Type Description <code>str</code> <p>A Planet global mosaic tile url.</p> Source code in <code>beamgis/common.py</code> <pre><code>def planet_by_quarter(\n    year=2016,\n    quarter=1,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n):\n    \"\"\"Gets Planet global mosaic tile url by quarter. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        quarter (int, optional): The quarter of Planet global mosaic, must be 1-4. Defaults to 1.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: The Planet API key is not provided.\n        ValueError: The year is invalid.\n        ValueError: The quarter is invalid.\n        ValueError: The quarter is invalid.\n\n    Returns:\n        str: A Planet global mosaic tile url.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n    quarter_now = (month_now - 1) // 3 + 1\n\n    if year &gt; year_now:\n        raise ValueError(f\"Year must be between 2016 and {year_now}.\")\n    elif year == year_now and quarter &gt;= quarter_now:\n        raise ValueError(f\"Quarter must be less than {quarter_now} for year {year_now}\")\n\n    if quarter &lt; 1 or quarter &gt; 4:\n        raise ValueError(\"Quarter must be between 1 and 4.\")\n\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_quarterly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    m_str = str(year) + \"q\" + str(quarter)\n    url = f\"{prefix}{m_str}{subfix}{api_key}\"\n\n    return url\n</code></pre>"},{"location":"common/#beamgis.common.planet_catalog","title":"<code>planet_catalog(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet bi-annual and monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>beamgis/common.py</code> <pre><code>def planet_catalog(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet bi-annual and monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    quarterly = planet_quarterly(api_key, token_name)\n    monthly = planet_monthly(api_key, token_name)\n    return quarterly + monthly\n</code></pre>"},{"location":"common/#beamgis.common.planet_catalog_tropical","title":"<code>planet_catalog_tropical(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet bi-annual and monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>beamgis/common.py</code> <pre><code>def planet_catalog_tropical(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet bi-annual and monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    biannual = planet_biannual_tropical(api_key, token_name)\n    monthly = planet_monthly_tropical(api_key, token_name)\n    return biannual + monthly\n</code></pre>"},{"location":"common/#beamgis.common.planet_monthly","title":"<code>planet_monthly(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet monthly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>beamgis/common.py</code> <pre><code>def planet_monthly(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet monthly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n\n    link = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_monthly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for year in range(2016, year_now + 1):\n        for month in range(1, 13):\n            m_str = str(year) + \"_\" + str(month).zfill(2)\n\n            if year == year_now and month &gt;= month_now:\n                break\n\n            url = f\"{prefix}{m_str}{subfix}{api_key}\"\n            link.append(url)\n\n    return link\n</code></pre>"},{"location":"common/#beamgis.common.planet_monthly_tiles","title":"<code>planet_monthly_tiles(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>beamgis/common.py</code> <pre><code>def planet_monthly_tiles(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    link = planet_monthly(api_key, token_name)\n\n    for url in link:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 7]\n\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"common/#beamgis.common.planet_monthly_tiles_tropical","title":"<code>planet_monthly_tiles_tropical(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  monthly imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>beamgis/common.py</code> <pre><code>def planet_monthly_tiles_tropical(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet  monthly imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    link = planet_monthly_tropical(api_key, token_name)\n    for url in link:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 7]\n\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"common/#beamgis.common.planet_monthly_tropical","title":"<code>planet_monthly_tropical(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>beamgis/common.py</code> <pre><code>def planet_monthly_tropical(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n\n    links = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/planet_medres_normalized_analytic_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for year in range(2020, year_now + 1):\n        for month in range(1, 13):\n            m_str = str(year) + \"-\" + str(month).zfill(2)\n\n            if year == 2020 and month &lt; 9:\n                continue\n            if year == year_now and month &gt;= month_now:\n                break\n\n            url = f\"{prefix}{m_str}{subfix}{api_key}\"\n            links.append(url)\n\n    return links\n</code></pre>"},{"location":"common/#beamgis.common.planet_quarterly","title":"<code>planet_quarterly(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet quarterly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>beamgis/common.py</code> <pre><code>def planet_quarterly(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet quarterly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n    quarter_now = (month_now - 1) // 3 + 1\n\n    link = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_quarterly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for year in range(2016, year_now + 1):\n        for quarter in range(1, 5):\n            m_str = str(year) + \"q\" + str(quarter)\n\n            if year == year_now and quarter &gt;= quarter_now:\n                break\n\n            url = f\"{prefix}{m_str}{subfix}{api_key}\"\n            link.append(url)\n\n    return link\n</code></pre>"},{"location":"common/#beamgis.common.planet_quarterly_tiles","title":"<code>planet_quarterly_tiles(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>beamgis/common.py</code> <pre><code>def planet_quarterly_tiles(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet  quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    links = planet_quarterly(api_key, token_name)\n\n    for url in links:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 6]\n\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"common/#beamgis.common.planet_tile_by_month","title":"<code>planet_tile_by_month(year=2016, month=1, name=None, api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>month</code> <code>int</code> <p>The month of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>beamgis/common.py</code> <pre><code>def planet_tile_by_month(\n    year=2016,\n    month=1,\n    name=None,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n    tile_format=\"ipyleaflet\",\n):\n    \"\"\"Generates Planet monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n        name (str, optional): The layer name to use. Defaults to None.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    url = planet_by_month(year, month, api_key, token_name)\n\n    if name is None:\n        name = \"Planet_\" + str(year) + \"_\" + str(month).zfill(2)\n\n    if tile_format == \"ipyleaflet\":\n        tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n    else:\n        tile = folium.TileLayer(\n            tiles=url,\n            attr=\"Planet\",\n            name=name,\n            overlay=True,\n            control=True,\n        )\n\n    return tile\n</code></pre>"},{"location":"common/#beamgis.common.planet_tile_by_quarter","title":"<code>planet_tile_by_quarter(year=2016, quarter=1, name=None, api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>quarter</code> <code>int</code> <p>The quarter of Planet global mosaic, must be 1-4. Defaults to 1.</p> <code>1</code> <code>name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>beamgis/common.py</code> <pre><code>def planet_tile_by_quarter(\n    year=2016,\n    quarter=1,\n    name=None,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n    tile_format=\"ipyleaflet\",\n):\n    \"\"\"Generates Planet quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        quarter (int, optional): The quarter of Planet global mosaic, must be 1-4. Defaults to 1.\n        name (str, optional): The layer name to use. Defaults to None.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    url = planet_by_quarter(year, quarter, api_key, token_name)\n\n    if name is None:\n        name = \"Planet_\" + str(year) + \"_q\" + str(quarter)\n\n    if tile_format == \"ipyleaflet\":\n        tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n    else:\n        tile = folium.TileLayer(\n            tiles=url,\n            attr=\"Planet\",\n            name=name,\n            overlay=True,\n            control=True,\n        )\n\n    return tile\n</code></pre>"},{"location":"common/#beamgis.common.planet_tiles","title":"<code>planet_tiles(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>beamgis/common.py</code> <pre><code>def planet_tiles(api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"):\n    \"\"\"Generates Planet imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    catalog = {}\n    quarterly = planet_quarterly_tiles(api_key, token_name, tile_format)\n    monthly = planet_monthly_tiles(api_key, token_name, tile_format)\n\n    for key in quarterly:\n        catalog[key] = quarterly[key]\n\n    for key in monthly:\n        catalog[key] = monthly[key]\n\n    return catalog\n</code></pre>"},{"location":"common/#beamgis.common.planet_tiles_tropical","title":"<code>planet_tiles_tropical(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  monthly imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>beamgis/common.py</code> <pre><code>def planet_tiles_tropical(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet  monthly imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    catalog = {}\n    biannul = planet_biannual_tiles_tropical(api_key, token_name, tile_format)\n    monthly = planet_monthly_tiles_tropical(api_key, token_name, tile_format)\n\n    for key in biannul:\n        catalog[key] = biannul[key]\n\n    for key in monthly:\n        catalog[key] = monthly[key]\n\n    return catalog\n</code></pre>"},{"location":"common/#beamgis.common.plot_actual_vs_predicted","title":"<code>plot_actual_vs_predicted(df, x_col='y', y_col='y_pred', xlim=None, ylim=None, title='Actual vs. Predicted Values', x_label='Actual Values', y_label='Predicted Values', marker_size=6, marker_opacity=0.7, marker_color='blue', line_color='red', line_dash='dash', width=800, height=800, showlegend=True, template='plotly_white', square_aspect=True, return_figure=False, **kwargs)</code>","text":"<p>Plots a customizable scatter plot with a reference line for actual vs. predicted values.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A pandas DataFrame with columns for actual and predicted values.</p> required <code>x_col</code> <code>str</code> <p>Column name for the x-axis (actual values).</p> <code>'y'</code> <code>y_col</code> <code>str</code> <p>Column name for the y-axis (predicted values).</p> <code>'y_pred'</code> <code>xlim</code> <code>tuple</code> <p>A tuple (min, max) for x-axis limits.</p> <code>None</code> <code>ylim</code> <code>tuple</code> <p>A tuple (min, max) for y-axis limits.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title of the plot.</p> <code>'Actual vs. Predicted Values'</code> <code>x_label</code> <code>str</code> <p>Label for the x-axis.</p> <code>'Actual Values'</code> <code>y_label</code> <code>str</code> <p>Label for the y-axis.</p> <code>'Predicted Values'</code> <code>marker_size</code> <code>int</code> <p>Size of the scatter plot markers.</p> <code>6</code> <code>marker_opacity</code> <code>float</code> <p>Opacity of the scatter plot markers.</p> <code>0.7</code> <code>marker_color</code> <code>str</code> <p>Color of the scatter plot markers.</p> <code>'blue'</code> <code>line_color</code> <code>str</code> <p>Color of the reference line.</p> <code>'red'</code> <code>line_dash</code> <code>str</code> <p>Dash style of the reference line ('dash', 'dot', etc.).</p> <code>'dash'</code> <code>width</code> <code>int</code> <p>Width of the plot in pixels.</p> <code>800</code> <code>height</code> <code>int</code> <p>Height of the plot in pixels.</p> <code>800</code> <code>showlegend</code> <code>bool</code> <p>Whether to show the legend.</p> <code>True</code> <code>template</code> <code>str</code> <p>Plotly template for styling.</p> <code>'plotly_white'</code> <code>square_aspect</code> <code>bool</code> <p>Whether to enforce a square aspect ratio.</p> <code>True</code> <code>return_figure</code> <code>bool</code> <p>Whether to return the Plotly figure object.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments for Plotly figure.</p> <code>{}</code> <p>Returns:</p> Type Description <p>A Plotly figure object.</p> Source code in <code>beamgis/common.py</code> <pre><code>def plot_actual_vs_predicted(\n    df: pd.DataFrame,\n    x_col: str = \"y\",\n    y_col: str = \"y_pred\",\n    xlim: tuple = None,\n    ylim: tuple = None,\n    title: str = \"Actual vs. Predicted Values\",\n    x_label: str = \"Actual Values\",\n    y_label: str = \"Predicted Values\",\n    marker_size: int = 6,\n    marker_opacity: float = 0.7,\n    marker_color: str = \"blue\",\n    line_color: str = \"red\",\n    line_dash: str = \"dash\",\n    width: int = 800,\n    height: int = 800,\n    showlegend: bool = True,\n    template: str = \"plotly_white\",\n    square_aspect: bool = True,\n    return_figure: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Plots a customizable scatter plot with a reference line for actual vs. predicted values.\n\n    Args:\n        df: A pandas DataFrame with columns for actual and predicted values.\n        x_col: Column name for the x-axis (actual values).\n        y_col: Column name for the y-axis (predicted values).\n        xlim: A tuple (min, max) for x-axis limits.\n        ylim: A tuple (min, max) for y-axis limits.\n        title: Title of the plot.\n        x_label: Label for the x-axis.\n        y_label: Label for the y-axis.\n        marker_size: Size of the scatter plot markers.\n        marker_opacity: Opacity of the scatter plot markers.\n        marker_color: Color of the scatter plot markers.\n        line_color: Color of the reference line.\n        line_dash: Dash style of the reference line ('dash', 'dot', etc.).\n        width: Width of the plot in pixels.\n        height: Height of the plot in pixels.\n        showlegend: Whether to show the legend.\n        template: Plotly template for styling.\n        square_aspect: Whether to enforce a square aspect ratio.\n        return_figure: Whether to return the Plotly figure object.\n        **kwargs: Additional keyword arguments for Plotly figure.\n\n    Returns:\n        A Plotly figure object.\n\n    \"\"\"\n    import plotly.graph_objects as go\n\n    # Default x and y limits if not provided\n    x_min, x_max = xlim if xlim else (df[x_col].min(), df[x_col].max())\n    y_min, y_max = ylim if ylim else (df[y_col].min(), df[y_col].max())\n\n    # Scatter plot for actual vs predicted\n    scatter = go.Scatter(\n        x=df[x_col],\n        y=df[y_col],\n        mode=\"markers\",\n        marker=dict(size=marker_size, opacity=marker_opacity, color=marker_color),\n        name=\"Predicted vs Actual\",\n    )\n\n    # Reference line y = x\n    ref_line = go.Scatter(\n        x=[x_min, x_max],\n        y=[x_min, x_max],\n        mode=\"lines\",\n        line=dict(color=line_color, dash=line_dash),\n        name=\"Reference Line\",\n    )\n\n    # Layout settings\n    layout = go.Layout(\n        title=title,\n        xaxis=dict(title=x_label, range=[x_min, x_max]),\n        yaxis=dict(title=y_label, range=[y_min, y_max]),\n        template=template,\n        showlegend=showlegend,\n        height=height,\n        width=width,\n    )\n\n    # Ensure square aspect ratio if specified\n    if square_aspect:\n        layout.update(xaxis_scaleanchor=\"y\")\n\n    # Create the figure\n    fig = go.Figure(data=[scatter, ref_line], layout=layout, **kwargs)\n    if return_figure:\n        return fig\n    else:\n        fig.show()\n</code></pre>"},{"location":"common/#beamgis.common.plot_raster","title":"<code>plot_raster(image, band=None, cmap='terrain', proj='EPSG:3857', figsize=None, open_kwargs={}, **kwargs)</code>","text":"<p>Plot a raster image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str | xarray.DataArray </code> <p>The input raster image, can be a file path, HTTP URL, or xarray.DataArray.</p> required <code>band</code> <code>int</code> <p>The band index, starting from zero. Defaults to None.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>The matplotlib colormap to use. Defaults to \"terrain\".</p> <code>'terrain'</code> <code>proj</code> <code>str</code> <p>The EPSG projection code. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>figsize</code> <code>tuple</code> <p>The figure size as a tuple, such as (10, 8). Defaults to None.</p> <code>None</code> <code>open_kwargs</code> <code>dict</code> <p>The keyword arguments to pass to rioxarray.open_rasterio. Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to xarray.DataArray.plot().</p> <code>{}</code> Source code in <code>beamgis/common.py</code> <pre><code>def plot_raster(\n    image,\n    band=None,\n    cmap=\"terrain\",\n    proj=\"EPSG:3857\",\n    figsize=None,\n    open_kwargs={},\n    **kwargs,\n):\n    \"\"\"Plot a raster image.\n\n    Args:\n        image (str | xarray.DataArray ): The input raster image, can be a file path, HTTP URL, or xarray.DataArray.\n        band (int, optional): The band index, starting from zero. Defaults to None.\n        cmap (str, optional): The matplotlib colormap to use. Defaults to \"terrain\".\n        proj (str, optional): The EPSG projection code. Defaults to \"EPSG:3857\".\n        figsize (tuple, optional): The figure size as a tuple, such as (10, 8). Defaults to None.\n        open_kwargs (dict, optional): The keyword arguments to pass to rioxarray.open_rasterio. Defaults to {}.\n        **kwargs: Additional keyword arguments to pass to xarray.DataArray.plot().\n\n    \"\"\"\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    try:\n        import pvxarray\n        import rioxarray\n        import xarray\n    except ImportError:\n        print(\n            \"pyxarray and rioxarray are required for plotting. Please install them using 'pip install rioxarray pyvista-xarray'.\"\n        )\n        return\n\n    if isinstance(image, str):\n        da = rioxarray.open_rasterio(image, **open_kwargs)\n    elif isinstance(image, xarray.DataArray):\n        da = image\n    else:\n        raise ValueError(\"image must be a string or xarray.Dataset.\")\n\n    if band is not None:\n        da = da[dict(band=band)]\n\n    da = da.rio.reproject(proj)\n    kwargs[\"cmap\"] = cmap\n    kwargs[\"figsize\"] = figsize\n    da.plot(**kwargs)\n</code></pre>"},{"location":"common/#beamgis.common.plot_raster_3d","title":"<code>plot_raster_3d(image, band=None, cmap='terrain', factor=1.0, proj='EPSG:3857', background=None, x=None, y=None, z=None, order=None, component=None, open_kwargs={}, mesh_kwargs={}, **kwargs)</code>","text":"<p>Plot a raster image in 3D.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str | xarray.DataArray</code> <p>The input raster image, can be a file path, HTTP URL, or xarray.DataArray.</p> required <code>band</code> <code>int</code> <p>The band index, starting from zero. Defaults to None.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>The matplotlib colormap to use. Defaults to \"terrain\".</p> <code>'terrain'</code> <code>factor</code> <code>float</code> <p>The scaling factor for the raster. Defaults to 1.0.</p> <code>1.0</code> <code>proj</code> <code>str</code> <p>The EPSG projection code. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>background</code> <code>str</code> <p>The background color. Defaults to None.</p> <code>None</code> <code>x</code> <code>str</code> <p>The x coordinate. Defaults to None.</p> <code>None</code> <code>y</code> <code>str</code> <p>The y coordinate. Defaults to None.</p> <code>None</code> <code>z</code> <code>str</code> <p>The z coordinate. Defaults to None.</p> <code>None</code> <code>order</code> <code>str</code> <p>The order of the coordinates. Defaults to None.</p> <code>None</code> <code>component</code> <code>str</code> <p>The component of the coordinates. Defaults to None.</p> <code>None</code> <code>open_kwargs</code> <code>dict</code> <p>The keyword arguments to pass to rioxarray.open_rasterio. Defaults to {}.</p> <code>{}</code> <code>mesh_kwargs</code> <code>dict</code> <p>The keyword arguments to pass to pyvista.mesh.warp_by_scalar(). Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to xarray.DataArray.plot().</p> <code>{}</code> Source code in <code>beamgis/common.py</code> <pre><code>def plot_raster_3d(\n    image,\n    band=None,\n    cmap=\"terrain\",\n    factor=1.0,\n    proj=\"EPSG:3857\",\n    background=None,\n    x=None,\n    y=None,\n    z=None,\n    order=None,\n    component=None,\n    open_kwargs={},\n    mesh_kwargs={},\n    **kwargs,\n):\n    \"\"\"Plot a raster image in 3D.\n\n    Args:\n        image (str | xarray.DataArray): The input raster image, can be a file path, HTTP URL, or xarray.DataArray.\n        band (int, optional): The band index, starting from zero. Defaults to None.\n        cmap (str, optional): The matplotlib colormap to use. Defaults to \"terrain\".\n        factor (float, optional): The scaling factor for the raster. Defaults to 1.0.\n        proj (str, optional): The EPSG projection code. Defaults to \"EPSG:3857\".\n        background (str, optional): The background color. Defaults to None.\n        x (str, optional): The x coordinate. Defaults to None.\n        y (str, optional): The y coordinate. Defaults to None.\n        z (str, optional): The z coordinate. Defaults to None.\n        order (str, optional): The order of the coordinates. Defaults to None.\n        component (str, optional): The component of the coordinates. Defaults to None.\n        open_kwargs (dict, optional): The keyword arguments to pass to rioxarray.open_rasterio. Defaults to {}.\n        mesh_kwargs (dict, optional): The keyword arguments to pass to pyvista.mesh.warp_by_scalar(). Defaults to {}.\n        **kwargs: Additional keyword arguments to pass to xarray.DataArray.plot().\n    \"\"\"\n    import sys\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    if \"google.colab\" in sys.modules:\n        print(\"This function is not supported in Google Colab.\")\n        return\n\n    try:\n        import pvxarray\n        import pyvista\n        import rioxarray\n        import xarray\n    except ImportError:\n        print(\n            \"pyxarray and rioxarray are required for plotting. Please install them using 'pip install rioxarray pyvista-xarray'.\"\n        )\n        return\n\n    if isinstance(background, str):\n        pyvista.global_theme.background = background\n\n    if isinstance(image, str):\n        da = rioxarray.open_rasterio(image, **open_kwargs)\n    elif isinstance(image, xarray.DataArray):\n        da = image\n    else:\n        raise ValueError(\"image must be a string or xarray.Dataset.\")\n\n    if band is not None:\n        da = da[dict(band=band)]\n\n    da = da.rio.reproject(proj)\n    mesh_kwargs[\"factor\"] = factor\n    kwargs[\"cmap\"] = cmap\n\n    coords = list(da.coords)\n\n    if x is None:\n        if \"x\" in coords:\n            x = \"x\"\n        elif \"lon\" in coords:\n            x = \"lon\"\n    if y is None:\n        if \"y\" in coords:\n            y = \"y\"\n        elif \"lat\" in coords:\n            y = \"lat\"\n    if z is None:\n        if \"z\" in coords:\n            z = \"z\"\n        elif \"elevation\" in coords:\n            z = \"elevation\"\n        elif \"band\" in coords:\n            z = \"band\"\n\n    # Grab the mesh object for use with PyVista\n    mesh = da.pyvista.mesh(x=x, y=y, z=z, order=order, component=component)\n\n    # Warp top and plot in 3D\n    mesh.warp_by_scalar(**mesh_kwargs).plot(**kwargs)\n</code></pre>"},{"location":"common/#beamgis.common.pmtiles_header","title":"<code>pmtiles_header(input_file)</code>","text":"<p>Fetch the header information from a local or remote .pmtiles file.</p> <p>This function retrieves the header from a PMTiles file, either local or hosted remotely. It deserializes the header and calculates the center and bounds of the tiles from the given metadata in the header.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the .pmtiles file, or its URL if the file is hosted remotely.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the header information, including center and bounds.</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the pmtiles library is not installed.</p> <code>ValueError</code> <p>If the input file is not a .pmtiles file or if it does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; header = pmtiles_header(\"https://example.com/path/to/tiles.pmtiles\")\n&gt;&gt;&gt; print(header[\"center\"])\n[52.5200, 13.4050]\n</code></pre> <p>Note</p> <p>If fetching a remote PMTiles file, this function only downloads the first 127 bytes of the file to retrieve the header.</p> Source code in <code>beamgis/common.py</code> <pre><code>def pmtiles_header(input_file: str):\n    \"\"\"\n    Fetch the header information from a local or remote .pmtiles file.\n\n    This function retrieves the header from a PMTiles file, either local or hosted remotely.\n    It deserializes the header and calculates the center and bounds of the tiles from the\n    given metadata in the header.\n\n    Args:\n        input_file (str): Path to the .pmtiles file, or its URL if the file is hosted remotely.\n\n    Returns:\n        dict: A dictionary containing the header information, including center and bounds.\n\n    Raises:\n        ImportError: If the pmtiles library is not installed.\n        ValueError: If the input file is not a .pmtiles file or if it does not exist.\n\n    Example:\n        &gt;&gt;&gt; header = pmtiles_header(\"https://example.com/path/to/tiles.pmtiles\")\n        &gt;&gt;&gt; print(header[\"center\"])\n        [52.5200, 13.4050]\n\n    Note:\n        If fetching a remote PMTiles file, this function only downloads the first 127 bytes\n        of the file to retrieve the header.\n    \"\"\"\n\n    import requests\n    from urllib.parse import urlparse\n\n    try:\n        from pmtiles.reader import Reader, MmapSource\n        from pmtiles.tile import deserialize_header\n    except ImportError:\n        print(\n            \"pmtiles is not installed. Please install it using `pip install pmtiles`.\"\n        )\n        return\n    if not urlparse(input_file).path.endswith(\".pmtiles\"):\n        raise ValueError(\"Input file must be a .pmtiles file.\")\n\n    if input_file.startswith(\"http\"):\n        # Fetch only the first 127 bytes\n        headers = {\"Range\": \"bytes=0-127\"}\n        response = requests.get(input_file, headers=headers)\n        header = deserialize_header(response.content)\n\n    else:\n        if not os.path.exists(input_file):\n            raise ValueError(f\"Input file {input_file} does not exist.\")\n\n        with open(input_file, \"rb\") as f:\n            reader = Reader(MmapSource(f))\n            header = reader.header()\n\n    header[\"center\"] = [header[\"center_lat_e7\"] / 1e7, header[\"center_lon_e7\"] / 1e7]\n    header[\"bounds\"] = [\n        header[\"min_lon_e7\"] / 1e7,\n        header[\"min_lat_e7\"] / 1e7,\n        header[\"max_lon_e7\"] / 1e7,\n        header[\"max_lat_e7\"] / 1e7,\n    ]\n\n    return header\n</code></pre>"},{"location":"common/#beamgis.common.pmtiles_metadata","title":"<code>pmtiles_metadata(input_file)</code>","text":"<p>Fetch the metadata from a local or remote .pmtiles file.</p> <p>This function retrieves metadata from a PMTiles file, whether it's local or hosted remotely. If it's remote, the function fetches the header to determine the range of bytes to download for obtaining the metadata. It then reads the metadata and extracts the layer names.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the .pmtiles file, or its URL if the file is hosted remotely.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the metadata information, including layer names.</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the pmtiles library is not installed.</p> <code>ValueError</code> <p>If the input file is not a .pmtiles file or if it does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; metadata = pmtiles_metadata(\"https://example.com/path/to/tiles.pmtiles\")\n&gt;&gt;&gt; print(metadata[\"layer_names\"])\n['buildings', 'roads']\n</code></pre> <p>Note</p> <p>If fetching a remote PMTiles file, this function may perform multiple requests to minimize the amount of data downloaded.</p> Source code in <code>beamgis/common.py</code> <pre><code>def pmtiles_metadata(input_file: str) -&gt; Dict[str, Union[str, int, List[str]]]:\n    \"\"\"\n    Fetch the metadata from a local or remote .pmtiles file.\n\n    This function retrieves metadata from a PMTiles file, whether it's local or hosted remotely.\n    If it's remote, the function fetches the header to determine the range of bytes to download\n    for obtaining the metadata. It then reads the metadata and extracts the layer names.\n\n    Args:\n        input_file (str): Path to the .pmtiles file, or its URL if the file is hosted remotely.\n\n    Returns:\n        dict: A dictionary containing the metadata information, including layer names.\n\n    Raises:\n        ImportError: If the pmtiles library is not installed.\n        ValueError: If the input file is not a .pmtiles file or if it does not exist.\n\n    Example:\n        &gt;&gt;&gt; metadata = pmtiles_metadata(\"https://example.com/path/to/tiles.pmtiles\")\n        &gt;&gt;&gt; print(metadata[\"layer_names\"])\n        ['buildings', 'roads']\n\n    Note:\n        If fetching a remote PMTiles file, this function may perform multiple requests to minimize\n        the amount of data downloaded.\n    \"\"\"\n\n    import json\n    import requests\n    from urllib.parse import urlparse\n\n    try:\n        from pmtiles.reader import Reader, MmapSource, MemorySource\n    except ImportError:\n        print(\n            \"pmtiles is not installed. Please install it using `pip install pmtiles`.\"\n        )\n        return\n\n    # ignore uri parameters when checking file suffix\n    if not urlparse(input_file).path.endswith(\".pmtiles\"):\n        raise ValueError(\"Input file must be a .pmtiles file.\")\n\n    header = pmtiles_header(input_file)\n    metadata_offset = header[\"metadata_offset\"]\n    metadata_length = header[\"metadata_length\"]\n\n    if input_file.startswith(\"http\"):\n        headers = {\"Range\": f\"bytes=0-{metadata_offset + metadata_length}\"}\n        response = requests.get(input_file, headers=headers)\n        content = MemorySource(response.content)\n        metadata = Reader(content).metadata()\n    else:\n        with open(input_file, \"rb\") as f:\n            reader = Reader(MmapSource(f))\n            metadata = reader.metadata()\n            if \"json\" in metadata:\n                metadata[\"vector_layers\"] = json.loads(metadata[\"json\"])[\n                    \"vector_layers\"\n                ]\n\n    vector_layers = metadata[\"vector_layers\"]\n    layer_names = [layer[\"id\"] for layer in vector_layers]\n\n    if \"tilestats\" in metadata:\n        geometries = [layer[\"geometry\"] for layer in metadata[\"tilestats\"][\"layers\"]]\n        metadata[\"geometries\"] = geometries\n\n    metadata[\"layer_names\"] = layer_names\n    metadata[\"center\"] = header[\"center\"]\n    metadata[\"bounds\"] = header[\"bounds\"]\n    return metadata\n</code></pre>"},{"location":"common/#beamgis.common.pmtiles_style","title":"<code>pmtiles_style(url, layers=None, cmap='Set3', n_class=None, opacity=0.5, circle_radius=5, line_width=1, attribution='PMTiles', **kwargs)</code>","text":"<p>Generates a Mapbox style JSON for rendering PMTiles data.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the PMTiles file.</p> required <code>layers</code> <code>str or list[str]</code> <p>The layers to include in the style. If None, all layers will be included. Defaults to None.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>The color map to use for styling the layers. Defaults to \"Set3\".</p> <code>'Set3'</code> <code>n_class</code> <code>int</code> <p>The number of classes to use for styling. If None, the number of classes will be determined automatically based on the color map. Defaults to None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The fill opacity for polygon layers. Defaults to 0.5.</p> <code>0.5</code> <code>circle_radius</code> <code>int</code> <p>The circle radius for point layers. Defaults to 5.</p> <code>5</code> <code>line_width</code> <code>int</code> <p>The line width for line layers. Defaults to 1.</p> <code>1</code> <code>attribution</code> <code>str</code> <p>The attribution text for the data source. Defaults to \"PMTiles\".</p> <code>'PMTiles'</code> <p>Returns:</p> Type Description <code>dict</code> <p>The Mapbox style JSON.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the layers argument is not a string or a list.</p> <code>ValueError</code> <p>If a layer specified in the layers argument does not exist in the PMTiles file.</p> Source code in <code>beamgis/common.py</code> <pre><code>def pmtiles_style(\n    url: str,\n    layers: Optional[Union[str, List[str]]] = None,\n    cmap: str = \"Set3\",\n    n_class: Optional[int] = None,\n    opacity: float = 0.5,\n    circle_radius: int = 5,\n    line_width: int = 1,\n    attribution: str = \"PMTiles\",\n    **kwargs,\n):\n    \"\"\"\n    Generates a Mapbox style JSON for rendering PMTiles data.\n\n    Args:\n        url (str): The URL of the PMTiles file.\n        layers (str or list[str], optional): The layers to include in the style. If None, all layers will be included.\n            Defaults to None.\n        cmap (str, optional): The color map to use for styling the layers. Defaults to \"Set3\".\n        n_class (int, optional): The number of classes to use for styling. If None, the number of classes will be\n            determined automatically based on the color map. Defaults to None.\n        opacity (float, optional): The fill opacity for polygon layers. Defaults to 0.5.\n        circle_radius (int, optional): The circle radius for point layers. Defaults to 5.\n        line_width (int, optional): The line width for line layers. Defaults to 1.\n        attribution (str, optional): The attribution text for the data source. Defaults to \"PMTiles\".\n\n    Returns:\n        dict: The Mapbox style JSON.\n\n    Raises:\n        ValueError: If the layers argument is not a string or a list.\n        ValueError: If a layer specified in the layers argument does not exist in the PMTiles file.\n    \"\"\"\n\n    if cmap == \"Set3\":\n        palette = [\n            \"#8dd3c7\",\n            \"#ffffb3\",\n            \"#bebada\",\n            \"#fb8072\",\n            \"#80b1d3\",\n            \"#fdb462\",\n            \"#b3de69\",\n            \"#fccde5\",\n            \"#d9d9d9\",\n            \"#bc80bd\",\n            \"#ccebc5\",\n            \"#ffed6f\",\n        ]\n    elif isinstance(cmap, list):\n        palette = cmap\n    else:\n        from .colormaps import get_palette\n\n        palette = [\"#\" + c for c in get_palette(cmap, n_class)]\n\n    n_class = len(palette)\n\n    metadata = pmtiles_metadata(url)\n    layer_names = metadata[\"layer_names\"]\n\n    style = {\n        \"version\": 8,\n        \"sources\": {\n            \"source\": {\n                \"type\": \"vector\",\n                \"url\": \"pmtiles://\" + url,\n                \"attribution\": attribution,\n            }\n        },\n        \"layers\": [],\n    }\n\n    if layers is None:\n        layers = layer_names\n    elif isinstance(layers, str):\n        layers = [layers]\n    elif isinstance(layers, list):\n        for layer in layers:\n            if layer not in layer_names:\n                raise ValueError(f\"Layer {layer} does not exist in the PMTiles file.\")\n    else:\n        raise ValueError(\"The layers argument must be a string or a list.\")\n\n    for i, layer_name in enumerate(layers):\n        layer_point = {\n            \"id\": f\"{layer_name}_point\",\n            \"source\": \"source\",\n            \"source-layer\": layer_name,\n            \"type\": \"circle\",\n            \"paint\": {\n                \"circle-color\": palette[i % n_class],\n                \"circle-radius\": circle_radius,\n            },\n            \"filter\": [\"==\", [\"geometry-type\"], \"Point\"],\n        }\n\n        layer_stroke = {\n            \"id\": f\"{layer_name}_stroke\",\n            \"source\": \"source\",\n            \"source-layer\": layer_name,\n            \"type\": \"line\",\n            \"paint\": {\n                \"line-color\": palette[i % n_class],\n                \"line-width\": line_width,\n            },\n            \"filter\": [\"==\", [\"geometry-type\"], \"LineString\"],\n        }\n\n        layer_fill = {\n            \"id\": f\"{layer_name}_fill\",\n            \"source\": \"source\",\n            \"source-layer\": layer_name,\n            \"type\": \"fill\",\n            \"paint\": {\n                \"fill-color\": palette[i % n_class],\n                \"fill-opacity\": opacity,\n            },\n            \"filter\": [\"==\", [\"geometry-type\"], \"Polygon\"],\n        }\n\n        style[\"layers\"].extend([layer_point, layer_stroke, layer_fill])\n\n    return style\n</code></pre>"},{"location":"common/#beamgis.common.png_to_gif","title":"<code>png_to_gif(in_dir, out_gif, fps=10, loop=0)</code>","text":"<p>Convert a list of png images to gif.</p> <p>Parameters:</p> Name Type Description Default <code>in_dir</code> <code>str</code> <p>The input directory containing png images.</p> required <code>out_gif</code> <code>str</code> <p>The output file path to the gif.</p> required <code>fps</code> <code>int</code> <p>Frames per second. Defaults to 10.</p> <code>10</code> <code>loop</code> <code>bool</code> <p>controls how many times the animation repeats. 1 means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>No png images could be found.</p> Source code in <code>beamgis/common.py</code> <pre><code>def png_to_gif(in_dir, out_gif, fps=10, loop=0):\n    \"\"\"Convert a list of png images to gif.\n\n    Args:\n        in_dir (str): The input directory containing png images.\n        out_gif (str): The output file path to the gif.\n        fps (int, optional): Frames per second. Defaults to 10.\n        loop (bool, optional): controls how many times the animation repeats. 1 means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n\n    Raises:\n        FileNotFoundError: No png images could be found.\n    \"\"\"\n    import glob\n\n    from PIL import Image\n\n    if not out_gif.endswith(\".gif\"):\n        raise ValueError(\"The out_gif must be a gif file.\")\n\n    out_gif = os.path.abspath(out_gif)\n\n    out_dir = os.path.dirname(out_gif)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    # Create the frames\n    frames = []\n    imgs = list(glob.glob(os.path.join(in_dir, \"*.png\")))\n    imgs.sort()\n\n    if len(imgs) == 0:\n        raise FileNotFoundError(f\"No png could be found in {in_dir}.\")\n\n    for i in imgs:\n        new_frame = Image.open(i)\n        frames.append(new_frame)\n\n    # Save into a GIF file that loops forever\n    frames[0].save(\n        out_gif,\n        format=\"GIF\",\n        append_images=frames[1:],\n        save_all=True,\n        duration=1000 / fps,\n        loop=loop,\n    )\n</code></pre>"},{"location":"common/#beamgis.common.point_to_gdf","title":"<code>point_to_gdf(x, y, point_crs='EPSG:4326', to_crs='EPSG:4326', **kwargs)</code>","text":"<p>Convert a point to a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X coordinate of the point.</p> required <code>y</code> <code>float</code> <p>Y coordinate of the point.</p> required <code>point_crs</code> <code>str</code> <p>Coordinate Reference System of the point.</p> <code>'EPSG:4326'</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>GeoDataFrame containing the point.</p> Source code in <code>beamgis/common.py</code> <pre><code>def point_to_gdf(x, y, point_crs=\"EPSG:4326\", to_crs=\"EPSG:4326\", **kwargs):\n    \"\"\"\n    Convert a point to a GeoDataFrame.\n\n    Args:\n        x (float): X coordinate of the point.\n        y (float): Y coordinate of the point.\n        point_crs (str): Coordinate Reference System of the point.\n\n    Returns:\n        gpd.GeoDataFrame: GeoDataFrame containing the point.\n    \"\"\"\n    import geopandas as gpd\n    from shapely.geometry import Point\n\n    # Create a Point object\n    point = Point(x, y)\n\n    # Convert the Point to a GeoDataFrame\n    gdf = gpd.GeoDataFrame([{\"geometry\": point}], crs=point_crs)\n\n    if to_crs != point_crs:\n        gdf = gdf.to_crs(to_crs)\n\n    return gdf\n</code></pre>"},{"location":"common/#beamgis.common.points_from_xy","title":"<code>points_from_xy(data, x=None, y=None, z=None, crs=None, **kwargs)</code>","text":"<p>Create a GeoPandas GeoDataFrame from a csv or Pandas DataFrame containing x, y, z values.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>A csv or Pandas DataFrame containing x, y, z values.</p> required <code>x</code> <code>str</code> <p>The column name for the x values. Defaults to \"longitude\".</p> <code>None</code> <code>y</code> <code>str</code> <p>The column name for the y values. Defaults to \"latitude\".</p> <code>None</code> <code>z</code> <code>str</code> <p>The column name for the z values. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str | int</code> <p>The coordinate reference system for the GeoDataFrame. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>A GeoPandas GeoDataFrame containing x, y, z values.</p> Source code in <code>beamgis/common.py</code> <pre><code>def points_from_xy(data, x=None, y=None, z=None, crs=None, **kwargs):\n    \"\"\"Create a GeoPandas GeoDataFrame from a csv or Pandas DataFrame containing x, y, z values.\n\n    Args:\n        data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n        x (str, optional): The column name for the x values. Defaults to \"longitude\".\n        y (str, optional): The column name for the y values. Defaults to \"latitude\".\n        z (str, optional): The column name for the z values. Defaults to None.\n        crs (str | int, optional): The coordinate reference system for the GeoDataFrame. Defaults to None.\n\n    Returns:\n        geopandas.GeoDataFrame: A GeoPandas GeoDataFrame containing x, y, z values.\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    import geopandas as gpd\n    import pandas as pd\n\n    if crs is None:\n        crs = \"epsg:4326\"\n\n    if isinstance(data, pd.DataFrame):\n        df = data\n    elif isinstance(data, str):\n        if not data.startswith(\"http\") and (not os.path.exists(data)):\n            raise FileNotFoundError(\"The specified input csv does not exist.\")\n        else:\n            df = pd.read_csv(data, **kwargs)\n    else:\n        raise TypeError(\"The data must be a pandas DataFrame or a csv file path.\")\n\n    columns = df.columns\n\n    if x is None:\n        if \"longitude\" in columns:\n            x = \"longitude\"\n        elif \"x\" in columns:\n            x = \"x\"\n        elif \"lon\" in columns:\n            x = \"lon\"\n        else:\n            raise ValueError(\"The x column could not be found.\")\n\n    if y is None:\n        if \"latitude\" in columns:\n            y = \"latitude\"\n        elif \"y\" in columns:\n            y = \"y\"\n        elif \"lat\" in columns:\n            y = \"lat\"\n        else:\n            raise ValueError(\"The y column could not be found.\")\n\n    gdf = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df[x], df[y], z=z, crs=crs))\n\n    return gdf\n</code></pre>"},{"location":"common/#beamgis.common.points_to_line","title":"<code>points_to_line(data, src_lat, src_lon, dst_lat, dst_lon, crs='EPSG:4326', **kwargs)</code>","text":"<p>Converts source and destination coordinates into a GeoDataFrame with LineString geometries.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, pd.DataFrame, gpd.GeoDataFrame]</code> <p>Input data which can be a file path or a DataFrame.</p> required <code>src_lat</code> <code>str</code> <p>Column name for source latitude.</p> required <code>src_lon</code> <code>str</code> <p>Column name for source longitude.</p> required <code>dst_lat</code> <code>str</code> <p>Column name for destination latitude.</p> required <code>dst_lon</code> <code>str</code> <p>Column name for destination longitude.</p> required <code>crs</code> <code>str</code> <p>Coordinate reference system. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the file reading functions.</p> <code>{}</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame with LineString geometries.</p> Source code in <code>beamgis/common.py</code> <pre><code>def points_to_line(\n    data: Union[str, pd.DataFrame],\n    src_lat: str,\n    src_lon: str,\n    dst_lat: str,\n    dst_lon: str,\n    crs: str = \"EPSG:4326\",\n    **kwargs: Any,\n) -&gt; \"gpd.GeoDataFrame\":\n    \"\"\"\n    Converts source and destination coordinates into a GeoDataFrame with LineString geometries.\n\n    Args:\n        data (Union[str, pd.DataFrame, gpd.GeoDataFrame]): Input data which can be a file path or a DataFrame.\n        src_lat (str): Column name for source latitude.\n        src_lon (str): Column name for source longitude.\n        dst_lat (str): Column name for destination latitude.\n        dst_lon (str): Column name for destination longitude.\n        crs (str, optional): Coordinate reference system. Defaults to \"EPSG:4326\".\n        **kwargs (Any): Additional arguments passed to the file reading functions.\n\n    Returns:\n        gpd.GeoDataFrame: A GeoDataFrame with LineString geometries.\n    \"\"\"\n    import geopandas as gpd\n    from shapely.geometry import LineString\n\n    if isinstance(data, str):\n        if data.endswith(\".parquet\"):\n            gdf = pd.read_parquet(data, **kwargs)\n        elif data.endswith(\".csv\"):\n            gdf = pd.read_csv(data, **kwargs)\n        elif data.endswith(\".json\"):\n            gdf = pd.read_json(data, **kwargs)\n        elif data.endswith(\".xlsx\"):\n            gdf = pd.read_excel(data, **kwargs)\n        else:\n            gdf = gpd.read_file(data, **kwargs)\n\n    elif isinstance(data, pd.DataFrame) or isinstance(data, gpd.GeoDataFrame):\n        gdf = data.copy()\n    else:\n        raise ValueError(\n            \"Unsupported data type. Please provide a file path or a DataFrame.\"\n        )\n\n    # Assuming you have a GeoDataFrame 'gdf' with the source and destination coordinates\n    def create_polyline(row):\n        source_point = (row[src_lon], row[src_lat])\n        dst_point = (row[dst_lon], row[dst_lat])\n        return LineString([source_point, dst_point])\n\n    # Apply the function to create the polyline geometry\n    gdf[\"geometry\"] = gdf.apply(create_polyline, axis=1)\n\n    # Set the GeoDataFrame's geometry column to the newly created geometry column\n    gdf = gdf.set_geometry(\"geometry\")\n    gdf.crs = crs\n    return gdf\n</code></pre>"},{"location":"common/#beamgis.common.random_string","title":"<code>random_string(string_length=3)</code>","text":"<p>Generates a random string of fixed length.</p> <p>Parameters:</p> Name Type Description Default <code>string_length</code> <code>int</code> <p>Fixed length. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>str</code> <p>A random string</p> Source code in <code>beamgis/common.py</code> <pre><code>def random_string(string_length: Optional[int] = 3) -&gt; str:\n    \"\"\"Generates a random string of fixed length.\n\n    Args:\n        string_length (int, optional): Fixed length. Defaults to 3.\n\n    Returns:\n        str: A random string\n    \"\"\"\n    import random\n    import string\n\n    # random.seed(1001)\n    letters = string.ascii_lowercase\n    return \"\".join(random.choice(letters) for i in range(string_length))\n</code></pre>"},{"location":"common/#beamgis.common.raster_to_vector","title":"<code>raster_to_vector(source, output, simplify_tolerance=None, dst_crs=None, open_args={}, **kwargs)</code>","text":"<p>Vectorize a raster dataset.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the tiff file.</p> required <code>output</code> <code>str</code> <p>The path to the vector file.</p> required <code>simplify_tolerance</code> <code>float</code> <p>The maximum allowed geometry displacement. The higher this value, the smaller the number of vertices in the resulting geometry.</p> <code>None</code> Source code in <code>beamgis/common.py</code> <pre><code>def raster_to_vector(\n    source, output, simplify_tolerance=None, dst_crs=None, open_args={}, **kwargs\n):\n    \"\"\"Vectorize a raster dataset.\n\n    Args:\n        source (str): The path to the tiff file.\n        output (str): The path to the vector file.\n        simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n            The higher this value, the smaller the number of vertices in the resulting geometry.\n    \"\"\"\n    import rasterio\n    import shapely\n    import geopandas as gpd\n    from rasterio import features\n\n    with rasterio.open(source, **open_args) as src:\n        band = src.read()\n\n        mask = band != 0\n        shapes = features.shapes(band, mask=mask, transform=src.transform)\n\n    fc = [\n        {\"geometry\": shapely.geometry.shape(shape), \"properties\": {\"value\": value}}\n        for shape, value in shapes\n    ]\n    if simplify_tolerance is not None:\n        for i in fc:\n            i[\"geometry\"] = i[\"geometry\"].simplify(tolerance=simplify_tolerance)\n\n    gdf = gpd.GeoDataFrame.from_features(fc)\n    if src.crs is not None:\n        gdf.set_crs(crs=src.crs, inplace=True)\n\n    if dst_crs is not None:\n        gdf = gdf.to_crs(dst_crs)\n\n    gdf.to_file(output, **kwargs)\n</code></pre>"},{"location":"common/#beamgis.common.read_file","title":"<code>read_file(data, **kwargs)</code>","text":"<p>Reads a file and returns a DataFrame or GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path or a DataFrame/GeoDataFrame.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the file reading function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[pd.DataFrame, gpd.GeoDataFrame]</code> <p>The read data as a DataFrame or GeoDataFrame.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is unsupported.</p> Source code in <code>beamgis/common.py</code> <pre><code>def read_file(data: str, **kwargs: Any) -&gt; Union[pd.DataFrame, \"gpd.GeoDataFrame\"]:\n    \"\"\"\n    Reads a file and returns a DataFrame or GeoDataFrame.\n\n    Args:\n        data (str): The file path or a DataFrame/GeoDataFrame.\n        **kwargs (Any): Additional arguments passed to the file reading function.\n\n    Returns:\n        Union[pd.DataFrame, gpd.GeoDataFrame]: The read data as a DataFrame or GeoDataFrame.\n\n    Raises:\n        ValueError: If the data type is unsupported.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        if data.endswith(\".parquet\"):\n            df = pd.read_parquet(data, **kwargs)\n        elif data.endswith(\".csv\"):\n            df = pd.read_csv(data, **kwargs)\n        elif data.endswith(\".json\"):\n            df = pd.read_json(data, **kwargs)\n        elif data.endswith(\".xlsx\"):\n            df = pd.read_excel(data, **kwargs)\n        else:\n            df = gpd.read_file(data, **kwargs)\n    elif isinstance(data, dict) or isinstance(data, list):\n        df = pd.DataFrame(data, **kwargs)\n\n    elif isinstance(data, pd.DataFrame) or isinstance(data, gpd.GeoDataFrame):\n        df = data\n    else:\n        raise ValueError(\n            \"Unsupported data type. Please provide a file path or a DataFrame.\"\n        )\n\n    return df\n</code></pre>"},{"location":"common/#beamgis.common.read_file_from_url","title":"<code>read_file_from_url(url, return_type='list', encoding='utf-8')</code>","text":"<p>Reads a file from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the file.</p> required <code>return_type</code> <code>str</code> <p>The return type, can either be string or list. Defaults to \"list\".</p> <code>'list'</code> <code>encoding</code> <code>str</code> <p>The encoding of the file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The return type must be either list or string.</p> <p>Returns:</p> Type Description <code>str | list</code> <p>The contents of the file.</p> Source code in <code>beamgis/common.py</code> <pre><code>def read_file_from_url(url, return_type=\"list\", encoding=\"utf-8\"):\n    \"\"\"Reads a file from a URL.\n\n    Args:\n        url (str): The URL of the file.\n        return_type (str, optional): The return type, can either be string or list. Defaults to \"list\".\n        encoding (str, optional): The encoding of the file. Defaults to \"utf-8\".\n\n    Raises:\n        ValueError: The return type must be either list or string.\n\n    Returns:\n        str | list: The contents of the file.\n    \"\"\"\n    from urllib.request import urlopen\n\n    if return_type == \"list\":\n        return [line.decode(encoding).rstrip() for line in urlopen(url).readlines()]\n    elif return_type == \"string\":\n        return urlopen(url).read().decode(encoding)\n    else:\n        raise ValueError(\"The return type must be either list or string.\")\n</code></pre>"},{"location":"common/#beamgis.common.read_geojson","title":"<code>read_geojson(data, **kwargs)</code>","text":"<p>Fetches and parses a GeoJSON file from a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The URL of the GeoJSON file.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the requests.get() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The parsed GeoJSON data.</p> Source code in <code>beamgis/common.py</code> <pre><code>def read_geojson(data: str, **kwargs: Any) -&gt; Dict[str, Any]:\n    \"\"\"\n    Fetches and parses a GeoJSON file from a given URL.\n\n    Args:\n        data (str): The URL of the GeoJSON file.\n        **kwargs (Any): Additional keyword arguments to pass to the requests.get() method.\n\n    Returns:\n        Dict[str, Any]: The parsed GeoJSON data.\n    \"\"\"\n\n    return requests.get(data, **kwargs).json()\n</code></pre>"},{"location":"common/#beamgis.common.read_lidar","title":"<code>read_lidar(filename, **kwargs)</code>","text":"<p>Read a LAS file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>A local file path or HTTP URL to a LAS file.</p> required <p>Returns:</p> Type Description <code>LasData</code> <p>The LasData object return by laspy.read.</p> Source code in <code>beamgis/common.py</code> <pre><code>def read_lidar(filename, **kwargs):\n    \"\"\"Read a LAS file.\n\n    Args:\n        filename (str): A local file path or HTTP URL to a LAS file.\n\n    Returns:\n        LasData: The LasData object return by laspy.read.\n    \"\"\"\n    try:\n        import laspy\n    except ImportError:\n        print(\n            \"The laspy package is required for this function. Use `pip install laspy[lazrs,laszip]` to install it.\"\n        )\n        return\n\n    if (\n        isinstance(filename, str)\n        and filename.startswith(\"http\")\n        and (filename.endswith(\".las\") or filename.endswith(\".laz\"))\n    ):\n        filename = github_raw_url(filename)\n        filename = download_file(filename)\n\n    return laspy.read(filename, **kwargs)\n</code></pre>"},{"location":"common/#beamgis.common.read_netcdf","title":"<code>read_netcdf(filename, **kwargs)</code>","text":"<p>Read a netcdf file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>File path or HTTP URL to the netcdf file.</p> required <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the xarray or rioxarray package is not installed.</p> <code>FileNotFoundError</code> <p>If the netcdf file is not found.</p> <p>Returns:</p> Type Description <code>xarray.Dataset</code> <p>The netcdf file as an xarray dataset.</p> Source code in <code>beamgis/common.py</code> <pre><code>def read_netcdf(filename, **kwargs):\n    \"\"\"Read a netcdf file.\n\n    Args:\n        filename (str): File path or HTTP URL to the netcdf file.\n\n    Raises:\n        ImportError: If the xarray or rioxarray package is not installed.\n        FileNotFoundError: If the netcdf file is not found.\n\n    Returns:\n        xarray.Dataset: The netcdf file as an xarray dataset.\n    \"\"\"\n    try:\n        import xarray as xr\n    except ImportError as e:\n        raise ImportError(e)\n\n    if filename.startswith(\"http\"):\n        filename = download_file(filename)\n\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"{filename} does not exist.\")\n\n    xds = xr.open_dataset(filename, **kwargs)\n    return xds\n</code></pre>"},{"location":"common/#beamgis.common.read_parquet","title":"<code>read_parquet(source, geometry=None, columns=None, exclude=None, db=None, table_name=None, sql=None, limit=None, src_crs=None, dst_crs=None, return_type='gdf', **kwargs)</code>","text":"<p>Read Parquet data from a source and return a GeoDataFrame or DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the Parquet file or directory containing Parquet files.</p> required <code>geometry</code> <code>str</code> <p>The name of the geometry column. Defaults to None.</p> <code>None</code> <code>columns</code> <code>str or list</code> <p>The columns to select. Defaults to None (select all columns).</p> <code>None</code> <code>exclude</code> <code>str or list</code> <p>The columns to exclude from the selection. Defaults to None.</p> <code>None</code> <code>db</code> <code>str</code> <p>The DuckDB database path or alias. Defaults to None.</p> <code>None</code> <code>table_name</code> <code>str</code> <p>The name of the table in the DuckDB database. Defaults to None.</p> <code>None</code> <code>sql</code> <code>str</code> <p>The SQL query to execute. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of rows to return. Defaults to None (return all rows).</p> <code>None</code> <code>src_crs</code> <code>str</code> <p>The source CRS (Coordinate Reference System) of the geometries. Defaults to None.</p> <code>None</code> <code>dst_crs</code> <code>str</code> <p>The target CRS to reproject the geometries. Defaults to None.</p> <code>None</code> <code>return_type</code> <code>str</code> <p>The type of object to return: - 'gdf': GeoDataFrame (default) - 'df': DataFrame - 'numpy': NumPy array - 'arrow': Arrow Table - 'polars': Polars DataFrame</p> <code>'gdf'</code> <code>**kwargs</code> <p>Additional keyword arguments that are passed to the DuckDB connection.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[gpd.GeoDataFrame, pd.DataFrame, np.ndarray]</code> <p>The loaded data.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the columns or exclude arguments are not of the correct type.</p> Source code in <code>beamgis/common.py</code> <pre><code>def read_parquet(\n    source: str,\n    geometry: Optional[str] = None,\n    columns: Optional[Union[str, list]] = None,\n    exclude: Optional[Union[str, list]] = None,\n    db: Optional[str] = None,\n    table_name: Optional[str] = None,\n    sql: Optional[str] = None,\n    limit: Optional[int] = None,\n    src_crs: Optional[str] = None,\n    dst_crs: Optional[str] = None,\n    return_type: str = \"gdf\",\n    **kwargs,\n):\n    \"\"\"\n    Read Parquet data from a source and return a GeoDataFrame or DataFrame.\n\n    Args:\n        source (str): The path to the Parquet file or directory containing Parquet files.\n        geometry (str, optional): The name of the geometry column. Defaults to None.\n        columns (str or list, optional): The columns to select. Defaults to None (select all columns).\n        exclude (str or list, optional): The columns to exclude from the selection. Defaults to None.\n        db (str, optional): The DuckDB database path or alias. Defaults to None.\n        table_name (str, optional): The name of the table in the DuckDB database. Defaults to None.\n        sql (str, optional): The SQL query to execute. Defaults to None.\n        limit (int, optional): The maximum number of rows to return. Defaults to None (return all rows).\n        src_crs (str, optional): The source CRS (Coordinate Reference System) of the geometries. Defaults to None.\n        dst_crs (str, optional): The target CRS to reproject the geometries. Defaults to None.\n        return_type (str, optional): The type of object to return:\n            - 'gdf': GeoDataFrame (default)\n            - 'df': DataFrame\n            - 'numpy': NumPy array\n            - 'arrow': Arrow Table\n            - 'polars': Polars DataFrame\n        **kwargs: Additional keyword arguments that are passed to the DuckDB connection.\n\n    Returns:\n        Union[gpd.GeoDataFrame, pd.DataFrame, np.ndarray]: The loaded data.\n\n    Raises:\n        ValueError: If the columns or exclude arguments are not of the correct type.\n\n    \"\"\"\n    import duckdb\n\n    if isinstance(db, str):\n        con = duckdb.connect(db)\n    else:\n        con = duckdb.connect()\n\n    con.install_extension(\"httpfs\")\n    con.load_extension(\"httpfs\")\n\n    con.install_extension(\"spatial\")\n    con.load_extension(\"spatial\")\n\n    if columns is None:\n        columns = \"*\"\n    elif isinstance(columns, list):\n        columns = \", \".join(columns)\n    elif not isinstance(columns, str):\n        raise ValueError(\"columns must be a list or a string.\")\n\n    if exclude is not None:\n        if isinstance(exclude, list):\n            exclude = \", \".join(exclude)\n        elif not isinstance(exclude, str):\n            raise ValueError(\"exclude_columns must be a list or a string.\")\n        columns = f\"{columns} EXCLUDE {exclude}\"\n\n    result = None\n    if return_type in [\"df\", \"numpy\", \"arrow\", \"polars\"]:\n        if sql is None:\n            sql = f\"SELECT {columns} FROM '{source}'\"\n        if limit is not None:\n            sql += f\" LIMIT {limit}\"\n\n        if return_type == \"df\":\n            result = con.sql(sql, **kwargs).df()\n        elif return_type == \"numpy\":\n            result = con.sql(sql, **kwargs).fetchnumpy()\n        elif return_type == \"arrow\":\n            result = con.sql(sql, **kwargs).arrow()\n        elif return_type == \"polars\":\n            result = con.sql(sql, **kwargs).pl()\n\n        if table_name is not None:\n            con.sql(f\"CREATE OR REPLACE TABLE {table_name} AS FROM result\", **kwargs)\n\n    elif return_type == \"gdf\":\n        if geometry is None:\n            geometry = \"geometry\"\n        if sql is None:\n            # if src_crs is not None and dst_crs is not None:\n            #     geom_sql = f\"ST_AsText(ST_Transform(ST_GeomFromWKB({geometry}), '{src_crs}', '{dst_crs}', true)) AS {geometry}\"\n            # else:\n            geom_sql = f\"ST_AsText(ST_GeomFromWKB(ST_AsWKB({geometry}))) AS {geometry}\"\n            sql = f\"SELECT {columns} EXCLUDE {geometry}, {geom_sql} FROM '{source}'\"\n        if limit is not None:\n            sql += f\" LIMIT {limit}\"\n\n        df = con.sql(sql, **kwargs).df()\n        if table_name is not None:\n            con.sql(f\"CREATE OR REPLACE TABLE {table_name} AS FROM df\", **kwargs)\n        result = df_to_gdf(df, geometry=geometry, src_crs=src_crs, dst_crs=dst_crs)\n\n    con.close()\n    return result\n</code></pre>"},{"location":"common/#beamgis.common.read_postgis","title":"<code>read_postgis(sql, con, geom_col='geom', crs=None, **kwargs)</code>","text":"<p>Reads data from a PostGIS database and returns a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>SQL query to execute in selecting entries from database, or name of the table to read from the database.</p> required <code>con</code> <code>sqlalchemy.engine.Engine</code> <p>Active connection to the database to query.</p> required <code>geom_col</code> <code>str</code> <p>Column name to convert to shapely geometries. Defaults to \"geom\".</p> <code>'geom'</code> <code>crs</code> <code>str | dict</code> <p>CRS to use for the returned GeoDataFrame; if not set, tries to determine CRS from the SRID associated with the first geometry in the database, and assigns that to all geometries. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>[type]</code> <p>[description]</p> Source code in <code>beamgis/common.py</code> <pre><code>def read_postgis(sql, con, geom_col=\"geom\", crs=None, **kwargs):\n    \"\"\"Reads data from a PostGIS database and returns a GeoDataFrame.\n\n    Args:\n        sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n        con (sqlalchemy.engine.Engine): Active connection to the database to query.\n        geom_col (str, optional): Column name to convert to shapely geometries. Defaults to \"geom\".\n        crs (str | dict, optional): CRS to use for the returned GeoDataFrame; if not set, tries to determine CRS from the SRID associated with the first geometry in the database, and assigns that to all geometries. Defaults to None.\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n\n    gdf = gpd.read_postgis(sql, con, geom_col, crs, **kwargs)\n    return gdf\n</code></pre>"},{"location":"common/#beamgis.common.read_raster","title":"<code>read_raster(source, window=None, return_array=True, coord_crs=None, request_payer='bucket-owner', env_args={}, open_args={}, **kwargs)</code>","text":"<p>Read a raster from S3.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the raster on S3.</p> required <code>window</code> <code>tuple</code> <p>The window (col_off, row_off, width, height) to read. Defaults to None.</p> <code>None</code> <code>return_array</code> <code>bool</code> <p>Whether to return a numpy array. Defaults to True.</p> <code>True</code> <code>coord_crs</code> <code>str</code> <p>The coordinate CRS of the input coordinates. Defaults to None.</p> <code>None</code> <code>request_payer</code> <code>str</code> <p>Specifies who pays for the download from S3. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>'bucket-owner'</code> <code>env_args</code> <code>dict</code> <p>Additional arguments to pass to rasterio.Env(). Defaults to {}.</p> <code>{}</code> <code>open_args</code> <code>dict</code> <p>Additional arguments to pass to rasterio.open(). Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>The raster as a numpy array.</p> Source code in <code>beamgis/common.py</code> <pre><code>def read_raster(\n    source,\n    window=None,\n    return_array=True,\n    coord_crs=None,\n    request_payer=\"bucket-owner\",\n    env_args={},\n    open_args={},\n    **kwargs,\n):\n    \"\"\"Read a raster from S3.\n\n    Args:\n        source (str): The path to the raster on S3.\n        window (tuple, optional): The window (col_off, row_off, width, height) to read. Defaults to None.\n        return_array (bool, optional): Whether to return a numpy array. Defaults to True.\n        coord_crs (str, optional): The coordinate CRS of the input coordinates. Defaults to None.\n        request_payer (str, optional): Specifies who pays for the download from S3.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        env_args (dict, optional): Additional arguments to pass to rasterio.Env(). Defaults to {}.\n        open_args (dict, optional): Additional arguments to pass to rasterio.open(). Defaults to {}.\n\n    Returns:\n        np.ndarray: The raster as a numpy array.\n    \"\"\"\n    import rasterio\n    from rasterio.windows import Window\n\n    with rasterio.Env(AWS_REQUEST_PAYER=request_payer, **env_args):\n        src = rasterio.open(source, **open_args)\n        if not return_array:\n            return src\n        else:\n            if window is None:\n                window = Window(0, 0, src.width, src.height)\n            else:\n                if isinstance(window, list):\n                    coords = coords_to_xy(\n                        source,\n                        window,\n                        coord_crs,\n                        env_args=env_args,\n                        open_args=open_args,\n                    )\n                    window = xy_to_window(coords)\n                window = Window(*window)\n\n            array = src.read(window=window, **kwargs)\n            return array\n</code></pre>"},{"location":"common/#beamgis.common.read_rasters","title":"<code>read_rasters(sources, window=None, coord_crs=None, request_payer='bucket-owner', env_args={}, open_args={}, **kwargs)</code>","text":"<p>Read a raster from S3.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>str</code> <p>The list of paths to the raster files.</p> required <code>window</code> <code>tuple</code> <p>The window (col_off, row_off, width, height) to read. Defaults to None.</p> <code>None</code> <code>coord_crs</code> <code>str</code> <p>The coordinate CRS of the input coordinates. Defaults to None.</p> <code>None</code> <code>request_payer</code> <code>str</code> <p>Specifies who pays for the download from S3. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>'bucket-owner'</code> <code>env_args</code> <code>dict</code> <p>Additional arguments to pass to rasterio.Env(). Defaults to {}.</p> <code>{}</code> <code>open_args</code> <code>dict</code> <p>Additional arguments to pass to rasterio.open(). Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>The raster as a numpy array.</p> Source code in <code>beamgis/common.py</code> <pre><code>def read_rasters(\n    sources,\n    window=None,\n    coord_crs=None,\n    request_payer=\"bucket-owner\",\n    env_args={},\n    open_args={},\n    **kwargs,\n):\n    \"\"\"Read a raster from S3.\n\n    Args:\n        sources (str): The list of paths to the raster files.\n        window (tuple, optional): The window (col_off, row_off, width, height) to read. Defaults to None.\n        coord_crs (str, optional): The coordinate CRS of the input coordinates. Defaults to None.\n        request_payer (str, optional): Specifies who pays for the download from S3.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        env_args (dict, optional): Additional arguments to pass to rasterio.Env(). Defaults to {}.\n        open_args (dict, optional): Additional arguments to pass to rasterio.open(). Defaults to {}.\n\n    Returns:\n        np.ndarray: The raster as a numpy array.\n    \"\"\"\n    import numpy as np\n\n    if not isinstance(sources, list):\n        sources = [sources]\n\n    array_list = []\n\n    for source in sources:\n        array = read_raster(\n            source,\n            window,\n            True,\n            coord_crs,\n            request_payer,\n            env_args,\n            open_args,\n            **kwargs,\n        )\n        array_list.append(array)\n\n    result = np.concatenate(array_list, axis=0)\n    return result\n</code></pre>"},{"location":"common/#beamgis.common.read_vector","title":"<code>read_vector(source, layer=None, **kwargs)</code>","text":"<p>Reads vector data from various formats including GeoParquet.</p> <p>This function dynamically determines the file type based on extension and reads it into a GeoDataFrame. It supports both local files and HTTP/HTTPS URLs.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>String path to the vector file or URL.</p> required <code>layer</code> <p>String or integer specifying which layer to read from multi-layer files (only applicable for formats like GPKG, GeoJSON, etc.). Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the underlying reader.</p> <code>{}</code> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>A GeoDataFrame containing the vector data.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the file format is not supported or source cannot be accessed.</p> <p>Examples:</p> <p>Read a local shapefile</p> <pre><code>&gt;&gt;&gt; gdf = read_vector(\"path/to/data.shp\")\n&gt;&gt;&gt;\nRead a GeoParquet file from URL\n&gt;&gt;&gt; gdf = read_vector(\"https://example.com/data.parquet\")\n&gt;&gt;&gt;\nRead a specific layer from a GeoPackage\n&gt;&gt;&gt; gdf = read_vector(\"path/to/data.gpkg\", layer=\"layer_name\")\n</code></pre> Source code in <code>beamgis/common.py</code> <pre><code>def read_vector(source, layer=None, **kwargs):\n    \"\"\"Reads vector data from various formats including GeoParquet.\n\n    This function dynamically determines the file type based on extension\n    and reads it into a GeoDataFrame. It supports both local files and HTTP/HTTPS URLs.\n\n    Args:\n        source: String path to the vector file or URL.\n        layer: String or integer specifying which layer to read from multi-layer\n            files (only applicable for formats like GPKG, GeoJSON, etc.).\n            Defaults to None.\n        **kwargs: Additional keyword arguments to pass to the underlying reader.\n\n    Returns:\n        geopandas.GeoDataFrame: A GeoDataFrame containing the vector data.\n\n    Raises:\n        ValueError: If the file format is not supported or source cannot be accessed.\n\n    Examples:\n        Read a local shapefile\n        &gt;&gt;&gt; gdf = read_vector(\"path/to/data.shp\")\n        &gt;&gt;&gt;\n        Read a GeoParquet file from URL\n        &gt;&gt;&gt; gdf = read_vector(\"https://example.com/data.parquet\")\n        &gt;&gt;&gt;\n        Read a specific layer from a GeoPackage\n        &gt;&gt;&gt; gdf = read_vector(\"path/to/data.gpkg\", layer=\"layer_name\")\n    \"\"\"\n\n    import urllib.parse\n\n    import fiona\n    import geopandas as gpd\n\n    # Determine if source is a URL or local file\n    parsed_url = urllib.parse.urlparse(source)\n    is_url = parsed_url.scheme in [\"http\", \"https\"]\n\n    # If it's a local file, check if it exists\n    if not is_url and not os.path.exists(source):\n        raise ValueError(f\"File does not exist: {source}\")\n\n    # Get file extension\n    _, ext = os.path.splitext(source)\n    ext = ext.lower()\n\n    # Handle GeoParquet files\n    if ext in [\".parquet\", \".pq\", \".geoparquet\"]:\n        return gpd.read_parquet(source, **kwargs)\n\n    # Handle common vector formats\n    if ext in [\".shp\", \".geojson\", \".json\", \".gpkg\", \".gml\", \".kml\", \".gpx\"]:\n        # For formats that might have multiple layers\n        if ext in [\".gpkg\", \".gml\"] and layer is not None:\n            return gpd.read_file(source, layer=layer, **kwargs)\n        return gpd.read_file(source, **kwargs)\n\n    # Try to use fiona to identify valid layers for formats that might have them\n    # Only attempt this for local files as fiona.listlayers might not work with URLs\n    if layer is None and ext in [\".gpkg\", \".gml\"] and not is_url:\n        try:\n            layers = fiona.listlayers(source)\n            if layers:\n                return gpd.read_file(source, layer=layers[0], **kwargs)\n        except Exception:\n            # If listing layers fails, we'll fall through to the generic read attempt\n            pass\n\n    # For other formats or when layer listing fails, attempt to read using GeoPandas\n    try:\n        return gpd.read_file(source, **kwargs)\n    except Exception as e:\n        raise ValueError(f\"Could not read from source '{source}': {str(e)}\")\n</code></pre>"},{"location":"common/#beamgis.common.reduce_gif_size","title":"<code>reduce_gif_size(in_gif, out_gif=None)</code>","text":"<p>Reduces a GIF image using ffmpeg.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The input file path to the GIF image.</p> required <code>out_gif</code> <code>str</code> <p>The output file path to the GIF image. Defaults to None.</p> <code>None</code> Source code in <code>beamgis/common.py</code> <pre><code>def reduce_gif_size(in_gif, out_gif=None):\n    \"\"\"Reduces a GIF image using ffmpeg.\n\n    Args:\n        in_gif (str): The input file path to the GIF image.\n        out_gif (str, optional): The output file path to the GIF image. Defaults to None.\n    \"\"\"\n\n    try:\n        import ffmpeg\n    except ImportError:\n        print(\"ffmpeg is not installed on your computer. Skip reducing gif size.\")\n        return\n\n    warnings.filterwarnings(\"ignore\")\n\n    if not is_tool(\"ffmpeg\"):\n        print(\"ffmpeg is not installed on your computer. Skip reducing gif size.\")\n        return\n\n    if not os.path.exists(in_gif):\n        print(\"The input gif file does not exist.\")\n        return\n\n    if out_gif is None:\n        out_gif = in_gif\n    elif not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    if in_gif == out_gif:\n        tmp_gif = in_gif.replace(\".gif\", \"_tmp.gif\")\n        shutil.copyfile(in_gif, tmp_gif)\n        stream = ffmpeg.input(tmp_gif)\n        stream = ffmpeg.output(stream, in_gif, loglevel=\"quiet\").overwrite_output()\n        ffmpeg.run(stream)\n        os.remove(tmp_gif)\n\n    else:\n        stream = ffmpeg.input(in_gif)\n        stream = ffmpeg.output(stream, out_gif, loglevel=\"quiet\").overwrite_output()\n        ffmpeg.run(stream)\n</code></pre>"},{"location":"common/#beamgis.common.regularize","title":"<code>regularize(source, output=None, crs='EPSG:4326', **kwargs)</code>","text":"<p>Regularize a polygon GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | gpd.GeoDataFrame</code> <p>The input file path or a GeoDataFrame.</p> required <code>output</code> <code>str</code> <p>The output file path. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>The output GeoDataFrame.</p> Source code in <code>beamgis/common.py</code> <pre><code>def regularize(source, output=None, crs=\"EPSG:4326\", **kwargs):\n    \"\"\"Regularize a polygon GeoDataFrame.\n\n    Args:\n        source (str | gpd.GeoDataFrame): The input file path or a GeoDataFrame.\n        output (str, optional): The output file path. Defaults to None.\n\n\n    Returns:\n        gpd.GeoDataFrame: The output GeoDataFrame.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(source, str):\n        gdf = gpd.read_file(source)\n    elif isinstance(source, gpd.GeoDataFrame):\n        gdf = source\n    else:\n        raise ValueError(\"The input source must be a GeoDataFrame or a file path.\")\n\n    polygons = gdf.geometry.apply(lambda geom: geom.minimum_rotated_rectangle)\n    result = gpd.GeoDataFrame(geometry=polygons, data=gdf.drop(\"geometry\", axis=1))\n\n    if crs is not None:\n        result.to_crs(crs, inplace=True)\n    if output is not None:\n        result.to_file(output, **kwargs)\n    else:\n        return result\n</code></pre>"},{"location":"common/#beamgis.common.remove_port_from_string","title":"<code>remove_port_from_string(data)</code>","text":"<p>Removes the port number from all URLs in the given string.</p> <p>Args::     data (str): The input string containing URLs.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string with port numbers removed from all URLs.</p> Source code in <code>beamgis/common.py</code> <pre><code>def remove_port_from_string(data: str) -&gt; str:\n    \"\"\"\n    Removes the port number from all URLs in the given string.\n\n    Args::\n        data (str): The input string containing URLs.\n\n    Returns:\n        str: The string with port numbers removed from all URLs.\n    \"\"\"\n    import re\n\n    # Regular expression to match URLs with port numbers\n    url_with_port_pattern = re.compile(r\"(http://[\\d\\w.]+):\\d+\")\n\n    # Function to remove the port from the matched URLs\n    def remove_port(match):\n        return match.group(1)\n\n    # Substitute the URLs with ports removed\n    result = url_with_port_pattern.sub(remove_port, data)\n\n    return result\n</code></pre>"},{"location":"common/#beamgis.common.replace_hyphens_in_keys","title":"<code>replace_hyphens_in_keys(d)</code>","text":"<p>Recursively replaces hyphens with underscores in dictionary keys.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Union[Dict, List, Any]</code> <p>The input dictionary, list or any other data type.</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, Any]</code> <p>The modified dictionary or list with keys having hyphens replaced with underscores, or the original input if it's not a dictionary or list.</p> Source code in <code>beamgis/common.py</code> <pre><code>def replace_hyphens_in_keys(d: Union[Dict, List, Any]) -&gt; Union[Dict, List, Any]:\n    \"\"\"\n    Recursively replaces hyphens with underscores in dictionary keys.\n\n    Args:\n        d (Union[Dict, List, Any]): The input dictionary, list or any other data type.\n\n    Returns:\n        Union[Dict, List, Any]: The modified dictionary or list with keys having hyphens replaced with underscores,\n        or the original input if it's not a dictionary or list.\n    \"\"\"\n    if isinstance(d, dict):\n        return {k.replace(\"-\", \"_\"): replace_hyphens_in_keys(v) for k, v in d.items()}\n    elif isinstance(d, list):\n        return [replace_hyphens_in_keys(i) for i in d]\n    else:\n        return d\n</code></pre>"},{"location":"common/#beamgis.common.replace_top_level_hyphens","title":"<code>replace_top_level_hyphens(d)</code>","text":"<p>Replaces hyphens with underscores in top-level dictionary keys.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Union[Dict, Any]</code> <p>The input dictionary or any other data type.</p> required <p>Returns:</p> Type Description <code>Union[Dict, Any]</code> <p>The modified dictionary with top-level keys having hyphens replaced with underscores, or the original input if it's not a dictionary.</p> Source code in <code>beamgis/common.py</code> <pre><code>def replace_top_level_hyphens(d: Union[Dict, Any]) -&gt; Union[Dict, Any]:\n    \"\"\"\n    Replaces hyphens with underscores in top-level dictionary keys.\n\n    Args:\n        d (Union[Dict, Any]): The input dictionary or any other data type.\n\n    Returns:\n        Union[Dict, Any]: The modified dictionary with top-level keys having hyphens replaced with underscores,\n        or the original input if it's not a dictionary.\n    \"\"\"\n    if isinstance(d, dict):\n        return {k.replace(\"-\", \"_\"): v for k, v in d.items()}\n    return d\n</code></pre>"},{"location":"common/#beamgis.common.replace_underscores_in_keys","title":"<code>replace_underscores_in_keys(d)</code>","text":"<p>Recursively replaces underscores with hyphens in dictionary keys.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Union[Dict, List, Any]</code> <p>The input dictionary, list or any other data type.</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, Any]</code> <p>The modified dictionary or list with keys having underscores replaced with hyphens, or the original input if it's not a dictionary or list.</p> Source code in <code>beamgis/common.py</code> <pre><code>def replace_underscores_in_keys(d: Union[Dict, List, Any]) -&gt; Union[Dict, List, Any]:\n    \"\"\"\n    Recursively replaces underscores with hyphens in dictionary keys.\n\n    Args:\n        d (Union[Dict, List, Any]): The input dictionary, list or any other data type.\n\n    Returns:\n        Union[Dict, List, Any]: The modified dictionary or list with keys having underscores replaced with hyphens,\n        or the original input if it's not a dictionary or list.\n    \"\"\"\n    if isinstance(d, dict):\n        return {\n            k.replace(\"_\", \"-\"): replace_underscores_in_keys(v) for k, v in d.items()\n        }\n    elif isinstance(d, list):\n        return [replace_underscores_in_keys(i) for i in d]\n    else:\n        return d\n</code></pre>"},{"location":"common/#beamgis.common.reproject","title":"<code>reproject(image, output, dst_crs='EPSG:4326', resampling='nearest', to_cog=True, **kwargs)</code>","text":"<p>Reprojects an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath.</p> required <code>output</code> <code>str</code> <p>The output image filepath.</p> required <code>dst_crs</code> <code>str</code> <p>The destination CRS. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>resampling</code> <code>Resampling</code> <p>The resampling method. Defaults to \"nearest\".</p> <code>'nearest'</code> <code>to_cog</code> <code>bool</code> <p>Whether to convert the output image to a Cloud Optimized GeoTIFF. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to rasterio.open.</p> <code>{}</code> Source code in <code>beamgis/common.py</code> <pre><code>def reproject(\n    image, output, dst_crs=\"EPSG:4326\", resampling=\"nearest\", to_cog=True, **kwargs\n):\n    \"\"\"Reprojects an image.\n\n    Args:\n        image (str): The input image filepath.\n        output (str): The output image filepath.\n        dst_crs (str, optional): The destination CRS. Defaults to \"EPSG:4326\".\n        resampling (Resampling, optional): The resampling method. Defaults to \"nearest\".\n        to_cog (bool, optional): Whether to convert the output image to a Cloud Optimized GeoTIFF. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to rasterio.open.\n\n    \"\"\"\n    import rasterio as rio\n    from rasterio.warp import calculate_default_transform, reproject, Resampling\n\n    if isinstance(resampling, str):\n        resampling = getattr(Resampling, resampling)\n\n    image = os.path.abspath(image)\n    output = os.path.abspath(output)\n\n    if not os.path.exists(os.path.dirname(output)):\n        os.makedirs(os.path.dirname(output))\n\n    with rio.open(image, **kwargs) as src:\n        transform, width, height = calculate_default_transform(\n            src.crs, dst_crs, src.width, src.height, *src.bounds\n        )\n        kwargs = src.meta.copy()\n        kwargs.update(\n            {\n                \"crs\": dst_crs,\n                \"transform\": transform,\n                \"width\": width,\n                \"height\": height,\n            }\n        )\n\n        with rio.open(output, \"w\", **kwargs) as dst:\n            for i in range(1, src.count + 1):\n                reproject(\n                    source=rio.band(src, i),\n                    destination=rio.band(dst, i),\n                    src_transform=src.transform,\n                    src_crs=src.crs,\n                    dst_transform=transform,\n                    dst_crs=dst_crs,\n                    resampling=resampling,\n                    **kwargs,\n                )\n\n    if to_cog:\n        image_to_cog(output, output)\n</code></pre>"},{"location":"common/#beamgis.common.rgb_to_hex","title":"<code>rgb_to_hex(rgb=(255, 255, 255))</code>","text":"<p>Converts RGB to hex color. In RGB color R stands for Red, G stands for Green, and B stands for Blue, and it ranges from the decimal value of 0 \u2013 255.</p> <p>Parameters:</p> Name Type Description Default <code>rgb</code> <code>tuple</code> <p>RGB color code as a tuple of (red, green, blue). Defaults to (255, 255, 255).</p> <code>(255, 255, 255)</code> <p>Returns:</p> Type Description <code>str</code> <p>hex color code</p> Source code in <code>beamgis/common.py</code> <pre><code>def rgb_to_hex(rgb: Optional[Tuple[int, int, int]] = (255, 255, 255)) -&gt; str:\n    \"\"\"Converts RGB to hex color. In RGB color R stands for Red, G stands for Green, and B stands for Blue, and it ranges from the decimal value of 0 \u2013 255.\n\n    Args:\n        rgb (tuple, optional): RGB color code as a tuple of (red, green, blue). Defaults to (255, 255, 255).\n\n    Returns:\n        str: hex color code\n    \"\"\"\n    return \"%02x%02x%02x\" % rgb\n</code></pre>"},{"location":"common/#beamgis.common.s3_download_file","title":"<code>s3_download_file(filename=None, bucket=None, key=None, outfile=None, **kwargs)</code>","text":"<p>Download a file from S3.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The full path to the file. Defaults to None.</p> <code>None</code> <code>bucket</code> <code>str</code> <p>The name of the bucket. Defaults to None.</p> <code>None</code> <code>key</code> <code>str</code> <p>The key of the file. Defaults to None.</p> <code>None</code> <code>outfile</code> <code>str</code> <p>The name of the output file. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If boto3 is not installed.</p> Source code in <code>beamgis/common.py</code> <pre><code>def s3_download_file(filename=None, bucket=None, key=None, outfile=None, **kwargs):\n    \"\"\"Download a file from S3.\n\n    Args:\n        filename (str, optional): The full path to the file. Defaults to None.\n        bucket (str, optional): The name of the bucket. Defaults to None.\n        key (str, optional): The key of the file. Defaults to None.\n        outfile (str, optional): The name of the output file. Defaults to None.\n    Raises:\n        ImportError: If boto3 is not installed.\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    try:\n        import boto3\n    except ImportError:\n        raise ImportError(\"boto3 is not installed. Install it with pip install boto3\")\n\n    client = boto3.client(\"s3\", **kwargs)\n\n    if filename is not None:\n        bucket = filename.split(\"/\")[2]\n        key = \"/\".join(filename.split(\"/\")[3:])\n\n    if outfile is None:\n        outfile = key.split(\"/\")[-1]\n\n    if not os.path.exists(outfile):\n        client.download_file(bucket, key, outfile)\n    else:\n        print(f\"File already exists: {outfile}\")\n</code></pre>"},{"location":"common/#beamgis.common.s3_download_files","title":"<code>s3_download_files(filenames=None, bucket=None, keys=None, outdir=None, quiet=False, **kwargs)</code>","text":"<p>Download multiple files from S3.</p> <p>Parameters:</p> Name Type Description Default <code>filenames</code> <code>list</code> <p>A list of filenames. Defaults to None.</p> <code>None</code> <code>bucket</code> <code>str</code> <p>The name of the bucket. Defaults to None.</p> <code>None</code> <code>keys</code> <code>list</code> <p>A list of keys. Defaults to None.</p> <code>None</code> <code>outdir</code> <code>str</code> <p>The name of the output directory. Defaults to None.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If neither filenames or keys are provided.</p> Source code in <code>beamgis/common.py</code> <pre><code>def s3_download_files(\n    filenames=None, bucket=None, keys=None, outdir=None, quiet=False, **kwargs\n):\n    \"\"\"Download multiple files from S3.\n\n    Args:\n        filenames (list, optional): A list of filenames. Defaults to None.\n        bucket (str, optional): The name of the bucket. Defaults to None.\n        keys (list, optional): A list of keys. Defaults to None.\n        outdir (str, optional): The name of the output directory. Defaults to None.\n        quiet (bool, optional): Suppress output. Defaults to False.\n\n    Raises:\n        ValueError: If neither filenames or keys are provided.\n    \"\"\"\n\n    if keys is None:\n        keys = []\n\n    if filenames is not None:\n        if isinstance(filenames, list):\n            for filename in filenames:\n                bucket = filename.split(\"/\")[2]\n                key = \"/\".join(filename.split(\"/\")[3:])\n                keys.append(key)\n    elif filenames is None and keys is None:\n        raise ValueError(\"Either filenames or keys must be provided\")\n\n    for index, key in enumerate(keys):\n        if outdir is not None:\n            if not os.path.exists(outdir):\n                os.makedirs(outdir)\n            outfile = os.path.join(outdir, key.split(\"/\")[-1])\n        else:\n            outfile = key.split(\"/\")[-1]\n\n        if not quiet:\n            print(f\"Downloading {index+1} of {len(keys)}: {outfile}\")\n        s3_download_file(bucket=bucket, key=key, outfile=outfile, **kwargs)\n</code></pre>"},{"location":"common/#beamgis.common.s3_get_object","title":"<code>s3_get_object(bucket, key, output=None, chunk_size=1048576, request_payer='bucket-owner', quiet=False, client_args={}, **kwargs)</code>","text":"<p>Download a file from S3.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the bucket.</p> required <code>key</code> <code>key</code> <p>The key of the file.</p> required <code>output</code> <code>str</code> <p>The name of the output file. Defaults to None.</p> <code>None</code> <code>chunk_size</code> <code>int</code> <p>The chunk size in bytes. Defaults to 1024 * 1024.</p> <code>1048576</code> <code>request_payer</code> <code>str</code> <p>Specifies who pays for the download from S3.</p> <code>'bucket-owner'</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to False. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>False</code> <code>client_args</code> <code>dict</code> <p>Additional arguments to pass to boto3.client(). Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <p>Additional arguments to pass to boto3.client().get_object().</p> <code>{}</code> Source code in <code>beamgis/common.py</code> <pre><code>def s3_get_object(\n    bucket,\n    key,\n    output=None,\n    chunk_size=1024 * 1024,\n    request_payer=\"bucket-owner\",\n    quiet=False,\n    client_args={},\n    **kwargs,\n):\n    \"\"\"Download a file from S3.\n\n    Args:\n        bucket (str): The name of the bucket.\n        key (key): The key of the file.\n        output (str, optional): The name of the output file. Defaults to None.\n        chunk_size (int, optional): The chunk size in bytes. Defaults to 1024 * 1024.\n        request_payer (str, optional): Specifies who pays for the download from S3.\n        quiet (bool, optional): Suppress output. Defaults to False.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        client_args (dict, optional): Additional arguments to pass to boto3.client(). Defaults to {}.\n        **kwargs: Additional arguments to pass to boto3.client().get_object().\n    \"\"\"\n\n    try:\n        import boto3\n    except ImportError:\n        raise ImportError(\"boto3 is not installed. Install it with pip install boto3\")\n\n    # Set up the S3 client\n    s3 = boto3.client(\"s3\", **client_args)\n\n    if output is None:\n        output = key.split(\"/\")[-1]\n\n    out_dir = os.path.dirname(os.path.abspath(output))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    # Set up the progress bar\n    def progress_callback(bytes_amount):\n        # This function will be called by the StreamingBody object\n        # to report the number of bytes downloaded so far\n        total_size = int(response[\"ContentLength\"])\n        progress_percent = int(bytes_amount / total_size * 100)\n        if not quiet:\n            print(f\"\\rDownloading: {progress_percent}% complete.\", end=\"\")\n\n    # Download the file\n    response = s3.get_object(\n        Bucket=bucket, Key=key, RequestPayer=request_payer, **kwargs\n    )\n\n    # Save the file to disk\n    with open(output, \"wb\") as f:\n        # Use the StreamingBody object to read the file in chunks\n        # and track the download progress\n        body = response[\"Body\"]\n        downloaded_bytes = 0\n        for chunk in body.iter_chunks(chunk_size=chunk_size):\n            f.write(chunk)\n            downloaded_bytes += len(chunk)\n            progress_callback(downloaded_bytes)\n</code></pre>"},{"location":"common/#beamgis.common.s3_get_objects","title":"<code>s3_get_objects(bucket, keys=None, out_dir=None, prefix=None, limit=None, ext=None, chunk_size=1048576, request_payer='bucket-owner', quiet=True, client_args={}, **kwargs)</code>","text":"<p>Download multiple files from S3.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the bucket.</p> required <code>keys</code> <code>list</code> <p>A list of keys. Defaults to None.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The name of the output directory. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>Limits the response to keys that begin with the specified prefix. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of keys returned in the response body.</p> <code>None</code> <code>ext</code> <code>str</code> <p>Filter by file extension. Defaults to None.</p> <code>None</code> <code>chunk_size</code> <code>int</code> <p>The chunk size in bytes. Defaults to 1024 * 1024.</p> <code>1048576</code> <code>request_payer</code> <code>str</code> <p>Specifies who pays for the download from S3. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>'bucket-owner'</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to True.</p> <code>True</code> <code>client_args</code> <code>dict</code> <p>Additional arguments to pass to boto3.client(). Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <p>Additional arguments to pass to boto3.client().get_object().</p> <code>{}</code> Source code in <code>beamgis/common.py</code> <pre><code>def s3_get_objects(\n    bucket,\n    keys=None,\n    out_dir=None,\n    prefix=None,\n    limit=None,\n    ext=None,\n    chunk_size=1024 * 1024,\n    request_payer=\"bucket-owner\",\n    quiet=True,\n    client_args={},\n    **kwargs,\n):\n    \"\"\"Download multiple files from S3.\n\n    Args:\n        bucket (str): The name of the bucket.\n        keys (list, optional): A list of keys. Defaults to None.\n        out_dir (str, optional): The name of the output directory. Defaults to None.\n        prefix (str, optional): Limits the response to keys that begin with the specified prefix. Defaults to None.\n        limit (int, optional): The maximum number of keys returned in the response body.\n        ext (str, optional): Filter by file extension. Defaults to None.\n        chunk_size (int, optional): The chunk size in bytes. Defaults to 1024 * 1024.\n        request_payer (str, optional): Specifies who pays for the download from S3.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        quiet (bool, optional): Suppress output. Defaults to True.\n        client_args (dict, optional): Additional arguments to pass to boto3.client(). Defaults to {}.\n        **kwargs: Additional arguments to pass to boto3.client().get_object().\n\n    \"\"\"\n\n    try:\n        import boto3\n    except ImportError:\n        raise ImportError(\"boto3 is not installed. Install it with pip install boto3\")\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if keys is None:\n        fullpath = False\n        keys = s3_list_objects(\n            bucket, prefix, limit, ext, fullpath, request_payer, client_args, **kwargs\n        )\n\n    for index, key in enumerate(keys):\n        print(f\"Downloading {index+1} of {len(keys)}: {key}\")\n        output = os.path.join(out_dir, key.split(\"/\")[-1])\n        s3_get_object(\n            bucket, key, output, chunk_size, request_payer, quiet, client_args, **kwargs\n        )\n</code></pre>"},{"location":"common/#beamgis.common.s3_list_objects","title":"<code>s3_list_objects(bucket, prefix=None, limit=None, ext=None, fullpath=True, request_payer='bucket-owner', client_args={}, **kwargs)</code>","text":"<p>List objects in a S3 bucket</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the bucket.</p> required <code>prefix</code> <code>str</code> <p>Limits the response to keys that begin with the specified prefix. Defaults to None.</p> <code>None</code> <code>limit</code> <code>init</code> <p>The maximum number of keys returned in the response body.</p> <code>None</code> <code>ext</code> <code>str</code> <p>Filter by file extension. Defaults to None.</p> <code>None</code> <code>fullpath</code> <code>bool</code> <p>Return full path. Defaults to True.</p> <code>True</code> <code>request_payer</code> <code>str</code> <p>Specifies who pays for the download from S3. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>'bucket-owner'</code> <code>client_args</code> <code>dict</code> <p>Additional arguments to pass to boto3.client(). Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>List of objects.</p> Source code in <code>beamgis/common.py</code> <pre><code>def s3_list_objects(\n    bucket,\n    prefix=None,\n    limit=None,\n    ext=None,\n    fullpath=True,\n    request_payer=\"bucket-owner\",\n    client_args={},\n    **kwargs,\n):\n    \"\"\"List objects in a S3 bucket\n\n    Args:\n        bucket (str): The name of the bucket.\n        prefix (str, optional): Limits the response to keys that begin with the specified prefix. Defaults to None.\n        limit (init, optional): The maximum number of keys returned in the response body.\n        ext (str, optional): Filter by file extension. Defaults to None.\n        fullpath (bool, optional): Return full path. Defaults to True.\n        request_payer (str, optional): Specifies who pays for the download from S3.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        client_args (dict, optional): Additional arguments to pass to boto3.client(). Defaults to {}.\n\n    Returns:\n        list: List of objects.\n    \"\"\"\n    try:\n        import boto3\n    except ImportError:\n        raise ImportError(\"boto3 is not installed. Install it with pip install boto3\")\n\n    client = boto3.client(\"s3\", **client_args)\n\n    if prefix is not None:\n        kwargs[\"Prefix\"] = prefix\n\n    files = []\n    kwargs[\"RequestPayer\"] = request_payer\n    if isinstance(limit, int) and limit &lt; 1000:\n        kwargs[\"MaxKeys\"] = limit\n        response = client.list_objects_v2(Bucket=bucket, **kwargs)\n        for obj in response[\"Contents\"]:\n            files.append(obj)\n    else:\n        paginator = client.get_paginator(\"list_objects_v2\")\n        pages = paginator.paginate(Bucket=bucket, **kwargs)\n\n        for page in pages:\n            files.extend(page.get(\"Contents\", []))\n\n    if ext is not None:\n        files = [f for f in files if f[\"Key\"].endswith(ext)]\n\n    if fullpath:\n        return [f\"s3://{bucket}/{r['Key']}\" for r in files]\n    else:\n        return [r[\"Key\"] for r in files]\n</code></pre>"},{"location":"common/#beamgis.common.save_colorbar","title":"<code>save_colorbar(out_fig=None, width=4.0, height=0.3, vmin=0, vmax=1.0, palette=None, vis_params=None, cmap='gray', discrete=False, label=None, label_size=10, label_weight='normal', tick_size=8, bg_color='white', orientation='horizontal', dpi='figure', transparent=False, show_colorbar=True, **kwargs)</code>","text":"<p>Create a standalone colorbar and save it as an image.</p> <p>Parameters:</p> Name Type Description Default <code>out_fig</code> <code>str</code> <p>Path to the output image.</p> <code>None</code> <code>width</code> <code>float</code> <p>Width of the colorbar in inches. Default is 4.0.</p> <code>4.0</code> <code>height</code> <code>float</code> <p>Height of the colorbar in inches. Default is 0.3.</p> <code>0.3</code> <code>vmin</code> <code>float</code> <p>Minimum value of the colorbar. Default is 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>Maximum value of the colorbar. Default is 1.0.</p> <code>1.0</code> <code>palette</code> <code>list</code> <p>List of colors to use for the colorbar. It can also be a cmap name, such as ndvi, ndwi, dem, coolwarm. Default is None.</p> <code>None</code> <code>vis_params</code> <code>dict</code> <p>Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.</p> <code>'gray'</code> <code>discrete</code> <code>bool</code> <p>Whether to create a discrete colorbar. Defaults to False.</p> <code>False</code> <code>label</code> <code>str</code> <p>Label for the colorbar. Defaults to None.</p> <code>None</code> <code>label_size</code> <code>int</code> <p>Font size for the colorbar label. Defaults to 12.</p> <code>10</code> <code>label_weight</code> <code>str</code> <p>Font weight for the colorbar label, can be \"normal\", \"bold\", etc. Defaults to \"normal\".</p> <code>'normal'</code> <code>tick_size</code> <code>int</code> <p>Font size for the colorbar tick labels. Defaults to 10.</p> <code>8</code> <code>bg_color</code> <code>str</code> <p>Background color for the colorbar. Defaults to \"white\".</p> <code>'white'</code> <code>orientation</code> <code>str</code> <p>Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".</p> <code>'horizontal'</code> <code>dpi</code> <code>float | str</code> <p>The resolution in dots per inch.  If 'figure', use the figure's dpi value. Defaults to \"figure\".</p> <code>'figure'</code> <code>transparent</code> <code>bool</code> <p>Whether to make the background transparent. Defaults to False.</p> <code>False</code> <code>show_colorbar</code> <code>bool</code> <p>Whether to show the colorbar. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Other keyword arguments to pass to matplotlib.pyplot.savefig().</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the output image.</p> Source code in <code>beamgis/common.py</code> <pre><code>def save_colorbar(\n    out_fig=None,\n    width=4.0,\n    height=0.3,\n    vmin=0,\n    vmax=1.0,\n    palette=None,\n    vis_params=None,\n    cmap=\"gray\",\n    discrete=False,\n    label=None,\n    label_size=10,\n    label_weight=\"normal\",\n    tick_size=8,\n    bg_color=\"white\",\n    orientation=\"horizontal\",\n    dpi=\"figure\",\n    transparent=False,\n    show_colorbar=True,\n    **kwargs,\n):\n    \"\"\"Create a standalone colorbar and save it as an image.\n\n    Args:\n        out_fig (str): Path to the output image.\n        width (float): Width of the colorbar in inches. Default is 4.0.\n        height (float): Height of the colorbar in inches. Default is 0.3.\n        vmin (float): Minimum value of the colorbar. Default is 0.\n        vmax (float): Maximum value of the colorbar. Default is 1.0.\n        palette (list): List of colors to use for the colorbar. It can also be a cmap name, such as ndvi, ndwi, dem, coolwarm. Default is None.\n        vis_params (dict): Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.\n        cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.\n        discrete (bool, optional): Whether to create a discrete colorbar. Defaults to False.\n        label (str, optional): Label for the colorbar. Defaults to None.\n        label_size (int, optional): Font size for the colorbar label. Defaults to 12.\n        label_weight (str, optional): Font weight for the colorbar label, can be \"normal\", \"bold\", etc. Defaults to \"normal\".\n        tick_size (int, optional): Font size for the colorbar tick labels. Defaults to 10.\n        bg_color (str, optional): Background color for the colorbar. Defaults to \"white\".\n        orientation (str, optional): Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".\n        dpi (float | str, optional): The resolution in dots per inch.  If 'figure', use the figure's dpi value. Defaults to \"figure\".\n        transparent (bool, optional): Whether to make the background transparent. Defaults to False.\n        show_colorbar (bool, optional): Whether to show the colorbar. Defaults to True.\n        **kwargs: Other keyword arguments to pass to matplotlib.pyplot.savefig().\n\n    Returns:\n        str: Path to the output image.\n    \"\"\"\n    import matplotlib as mpl\n    import matplotlib.pyplot as plt\n    import numpy as np\n    from .colormaps import palettes, get_palette\n\n    if out_fig is None:\n        out_fig = temp_file_path(\"png\")\n    else:\n        out_fig = check_file_path(out_fig)\n\n    if vis_params is None:\n        vis_params = {}\n    elif not isinstance(vis_params, dict):\n        raise TypeError(\"The vis_params must be a dictionary.\")\n\n    if palette is not None:\n        if palette in [\"ndvi\", \"ndwi\", \"dem\"]:\n            palette = palettes[palette]\n        elif palette in list(palettes.keys()):\n            palette = get_palette(palette)\n        vis_params[\"palette\"] = palette\n\n    orientation = orientation.lower()\n    if orientation not in [\"horizontal\", \"vertical\"]:\n        raise ValueError(\"The orientation must be either horizontal or vertical.\")\n\n    if \"opacity\" in vis_params:\n        alpha = vis_params[\"opacity\"]\n        if type(alpha) not in (int, float):\n            raise ValueError(\"The provided opacity value must be type scalar.\")\n    else:\n        alpha = 1\n\n    if \"palette\" in vis_params:\n        hexcodes = to_hex_colors(vis_params[\"palette\"])\n        if discrete:\n            cmap = mpl.colors.ListedColormap(hexcodes)\n            vals = np.linspace(vmin, vmax, cmap.N + 1)\n            norm = mpl.colors.BoundaryNorm(vals, cmap.N)\n\n        else:\n            cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                \"custom\", hexcodes, N=256\n            )\n            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n    elif cmap is not None:\n        cmap = mpl.colormaps[cmap]\n        norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n    else:\n        raise ValueError(\n            'cmap keyword or \"palette\" key in vis_params must be provided.'\n        )\n\n    fig, ax = plt.subplots(figsize=(width, height))\n    cb = mpl.colorbar.ColorbarBase(\n        ax, norm=norm, alpha=alpha, cmap=cmap, orientation=orientation, **kwargs\n    )\n    if label is not None:\n        cb.set_label(label=label, size=label_size, weight=label_weight)\n    cb.ax.tick_params(labelsize=tick_size)\n\n    if transparent:\n        bg_color = None\n\n    if bg_color is not None:\n        kwargs[\"facecolor\"] = bg_color\n    if \"bbox_inches\" not in kwargs:\n        kwargs[\"bbox_inches\"] = \"tight\"\n\n    fig.savefig(out_fig, dpi=dpi, transparent=transparent, **kwargs)\n    if not show_colorbar:\n        plt.close(fig)\n    return out_fig\n</code></pre>"},{"location":"common/#beamgis.common.save_data","title":"<code>save_data(data, file_ext=None, file_name=None)</code>","text":"<p>Save data in the memory to a file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>object</code> <p>The data to be saved.</p> required <code>file_ext</code> <code>str</code> <p>The file extension of the file.</p> <code>None</code> <code>file_name</code> <code>str</code> <p>The name of the file to be saved. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The path of the file.</p> Source code in <code>beamgis/common.py</code> <pre><code>def save_data(data, file_ext=None, file_name=None):\n    \"\"\"Save data in the memory to a file.\n\n    Args:\n        data (object): The data to be saved.\n        file_ext (str): The file extension of the file.\n        file_name (str, optional): The name of the file to be saved. Defaults to None.\n\n    Returns:\n        str: The path of the file.\n    \"\"\"\n    import tempfile\n    import uuid\n\n    try:\n        if file_ext is None:\n            if hasattr(data, \"name\"):\n                _, file_ext = os.path.splitext(data.name)\n        else:\n            if not file_ext.startswith(\".\"):\n                file_ext = \".\" + file_ext\n\n        if file_name is not None:\n            file_path = os.path.abspath(file_name)\n            if not file_path.endswith(file_ext):\n                file_path = file_path + file_ext\n        else:\n            file_id = str(uuid.uuid4())\n            file_path = os.path.join(tempfile.gettempdir(), f\"{file_id}{file_ext}\")\n\n        with open(file_path, \"wb\") as file:\n            file.write(data.getbuffer())\n        return file_path\n    except Exception as e:\n        print(e)\n        return None\n</code></pre>"},{"location":"common/#beamgis.common.screen_capture","title":"<code>screen_capture(outfile, monitor=1)</code>","text":"<p>Takes a full screenshot of the selected monitor.</p> <p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>str</code> <p>The output file path to the screenshot.</p> required <code>monitor</code> <code>int</code> <p>The monitor to take the screenshot. Defaults to 1.</p> <code>1</code> Source code in <code>beamgis/common.py</code> <pre><code>def screen_capture(outfile, monitor=1):\n    \"\"\"Takes a full screenshot of the selected monitor.\n\n    Args:\n        outfile (str): The output file path to the screenshot.\n        monitor (int, optional): The monitor to take the screenshot. Defaults to 1.\n    \"\"\"\n    try:\n        from mss import mss\n    except ImportError:\n        raise ImportError(\"Please install mss using 'pip install mss'\")\n\n    out_dir = os.path.dirname(outfile)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if not isinstance(monitor, int):\n        print(\"The monitor number must be an integer.\")\n        return\n\n    try:\n        with mss() as sct:\n            sct.shot(output=outfile, mon=monitor)\n            return outfile\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.search_mapillary_images","title":"<code>search_mapillary_images(lon=None, lat=None, radius=5e-05, bbox=None, limit=2000, access_token=None)</code>","text":"<p>Retrieves Mapillary image IDs near the specified test point within a bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Longitude of the test point. Defaults to None.</p> <code>None</code> <code>lat</code> <code>float</code> <p>Latitude of the test point. Defaults to None.</p> <code>None</code> <code>radius</code> <code>float</code> <p>Radius to create the bounding box. Defaults to 0.00005.</p> <code>5e-05</code> <code>bbox</code> <code>Union[str, List[float]]</code> <p>Bounding box coordinates. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of image IDs to retrieve. Defaults to 2000.</p> <code>2000</code> <code>access_token</code> <code>str</code> <p>Mapillary API access token. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>JSON response from the Mapillary API containing image IDs.</p> Source code in <code>beamgis/common.py</code> <pre><code>def search_mapillary_images(\n    lon: Optional[float] = None,\n    lat: Optional[float] = None,\n    radius: float = 0.00005,\n    bbox: Optional[Union[str, List[float]]] = None,\n    limit: int = 2000,\n    access_token: Optional[str] = None,\n) -&gt; List[str]:\n    \"\"\"\n    Retrieves Mapillary image IDs near the specified test point within a bounding box.\n\n    Args:\n        lon (float, optional): Longitude of the test point. Defaults to None.\n        lat (float, optional): Latitude of the test point. Defaults to None.\n        radius (float, optional): Radius to create the bounding box. Defaults to 0.00005.\n        bbox (Union[str, List[float]], optional): Bounding box coordinates. Defaults to None.\n        limit (int, optional): Maximum number of image IDs to retrieve. Defaults to 2000.\n        access_token (str, optional): Mapillary API access token. Defaults to None.\n\n    Returns:\n        List[str]: JSON response from the Mapillary API containing image IDs.\n    \"\"\"\n\n    if access_token is None:\n        access_token = get_api_key(\"MAPILLARY_API_KEY\")\n\n    if access_token is None:\n        raise ValueError(\n            \"Mapillary API access token is required. Set it using the 'access_token' parameter.\"\n        )\n\n    metadata_endpoint = \"https://graph.mapillary.com\"\n    headers = {\"Authorization\": f\"OAuth {access_token}\"}\n\n    if bbox is None:\n        if lon is None or lat is None:\n            raise ValueError(\"Longitude and latitude are required.\")\n        bbox = f\"{lon - radius},{lat - radius},{lon + radius},{lat + radius}\"\n    else:\n        if isinstance(bbox, list):\n            bbox = \",\".join(str(x) for x in bbox)\n\n    # Construct the bounding box for the API call\n    url_imagesearch = f\"{metadata_endpoint}/images?fields=id&amp;bbox={bbox}&amp;limit={limit}\"\n\n    try:\n        response = requests.get(url_imagesearch, headers=headers)\n        response.raise_for_status()  # Raise an HTTPError for bad responses\n        return [image[\"id\"] for image in response.json()[\"data\"]]\n    except requests.exceptions.RequestException as e:\n        print(f\"An error occurred: {e}\")\n        return []\n</code></pre>"},{"location":"common/#beamgis.common.search_qms","title":"<code>search_qms(keyword, limit=10, list_only=True, add_prefix=True)</code>","text":"<p>Search for QMS tile providers from Quick Map Services.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for.</p> required <code>limit</code> <code>int</code> <p>The maximum number of results to return. Defaults to 10.</p> <code>10</code> <code>list_only</code> <code>bool</code> <p>If True, only the list of services will be returned. Defaults to True.</p> <code>True</code> <code>add_prefix</code> <code>bool</code> <p>If True, the prefix \"qms.\" will be added to the service name. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of QMS tile providers.</p> Source code in <code>beamgis/common.py</code> <pre><code>def search_qms(keyword, limit=10, list_only=True, add_prefix=True):\n    \"\"\"Search for QMS tile providers from Quick Map Services.\n\n    Args:\n        keyword (str): The keyword to search for.\n        limit (int, optional): The maximum number of results to return. Defaults to 10.\n        list_only (bool, optional): If True, only the list of services will be returned. Defaults to True.\n        add_prefix (bool, optional): If True, the prefix \"qms.\" will be added to the service name. Defaults to True.\n\n    Returns:\n        list: A list of QMS tile providers.\n    \"\"\"\n\n    QMS_API = \"https://qms.nextgis.com/api/v1/geoservices\"\n    services = requests.get(\n        f\"{QMS_API}/?search={keyword}&amp;type=tms&amp;epsg=3857&amp;limit={limit}\"\n    )\n    services = services.json()\n    if services[\"results\"]:\n        providers = services[\"results\"]\n        if list_only:\n            if add_prefix:\n                return [\"qms.\" + provider[\"name\"] for provider in providers]\n            else:\n                return [provider[\"name\"] for provider in providers]\n        else:\n            return providers\n    else:\n        return None\n</code></pre>"},{"location":"common/#beamgis.common.search_xyz_services","title":"<code>search_xyz_services(keyword, name=None, list_only=True, add_prefix=True)</code>","text":"<p>Search for XYZ tile providers from xyzservices.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for.</p> required <code>name</code> <code>str</code> <p>The name of the xyz tile. Defaults to None.</p> <code>None</code> <code>list_only</code> <code>bool</code> <p>If True, only the list of services will be returned. Defaults to True.</p> <code>True</code> <code>add_prefix</code> <code>bool</code> <p>If True, the prefix \"xyz.\" will be added to the service name. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of XYZ tile providers.</p> Source code in <code>beamgis/common.py</code> <pre><code>def search_xyz_services(keyword, name=None, list_only=True, add_prefix=True):\n    \"\"\"Search for XYZ tile providers from xyzservices.\n\n    Args:\n        keyword (str): The keyword to search for.\n        name (str, optional): The name of the xyz tile. Defaults to None.\n        list_only (bool, optional): If True, only the list of services will be returned. Defaults to True.\n        add_prefix (bool, optional): If True, the prefix \"xyz.\" will be added to the service name. Defaults to True.\n\n    Returns:\n        list: A list of XYZ tile providers.\n    \"\"\"\n\n    import xyzservices.providers as xyz\n\n    if name is None:\n        providers = xyz.filter(keyword=keyword).flatten()\n    else:\n        providers = xyz.filter(name=name).flatten()\n\n    if list_only:\n        if add_prefix:\n            return [\"xyz.\" + provider for provider in providers]\n        else:\n            return [provider for provider in providers]\n    else:\n        return providers\n</code></pre>"},{"location":"common/#beamgis.common.select_largest","title":"<code>select_largest(source, column, count=1, output=None, **kwargs)</code>","text":"<p>Select the largest features in a GeoDataFrame based on a column.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | gpd.GeoDataFrame</code> <p>The path to the vector file or a GeoDataFrame.</p> required <code>column</code> <code>str</code> <p>The column to sort by.</p> required <code>count</code> <code>int</code> <p>The number of features to select. Defaults to 1.</p> <code>1</code> <code>output</code> <code>str</code> <p>The path to the output vector file. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The path to the output vector file.</p> Source code in <code>beamgis/common.py</code> <pre><code>def select_largest(source, column, count=1, output=None, **kwargs):\n    \"\"\"Select the largest features in a GeoDataFrame based on a column.\n\n    Args:\n        source (str | gpd.GeoDataFrame): The path to the vector file or a GeoDataFrame.\n        column (str): The column to sort by.\n        count (int, optional): The number of features to select. Defaults to 1.\n        output (str, optional): The path to the output vector file. Defaults to None.\n\n    Returns:\n        str: The path to the output vector file.\n    \"\"\"\n\n    import geopandas as gpd\n\n    if isinstance(source, str):\n        gdf = gpd.read_file(source, **kwargs)\n    else:\n        gdf = source\n\n    if not isinstance(gdf, gpd.GeoDataFrame):\n        raise TypeError(\"source must be a GeoDataFrame or a file path\")\n\n    gdf = gdf.sort_values(column, ascending=False).head(count)\n\n    if output is not None:\n        gdf.to_file(output)\n\n    else:\n        return gdf\n</code></pre>"},{"location":"common/#beamgis.common.set_api_key","title":"<code>set_api_key(key, name='GOOGLE_MAPS_API_KEY')</code>","text":"<p>Sets the Google Maps API key. You can generate one from https://bit.ly/3sw0THG.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The Google Maps API key.</p> required <code>name</code> <code>str</code> <p>The name of the environment variable. Defaults to \"GOOGLE_MAPS_API_KEY\".</p> <code>'GOOGLE_MAPS_API_KEY'</code> Source code in <code>beamgis/common.py</code> <pre><code>def set_api_key(key: str, name: str = \"GOOGLE_MAPS_API_KEY\"):\n    \"\"\"Sets the Google Maps API key. You can generate one from https://bit.ly/3sw0THG.\n\n    Args:\n        key (str): The Google Maps API key.\n        name (str, optional): The name of the environment variable. Defaults to \"GOOGLE_MAPS_API_KEY\".\n    \"\"\"\n    os.environ[name] = key\n</code></pre>"},{"location":"common/#beamgis.common.set_proj_lib_path","title":"<code>set_proj_lib_path(verbose=False)</code>","text":"<p>Set the PROJ_LIB and GDAL_DATA environment variables based on the current conda environment.</p> <p>This function attempts to locate and set the correct paths for PROJ_LIB and GDAL_DATA by checking multiple possible locations within the conda environment structure.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, print additional information during the process.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if both paths were set successfully, False otherwise.</p> Source code in <code>beamgis/common.py</code> <pre><code>def set_proj_lib_path(verbose=False):\n    \"\"\"\n    Set the PROJ_LIB and GDAL_DATA environment variables based on the current conda environment.\n\n    This function attempts to locate and set the correct paths for PROJ_LIB and GDAL_DATA\n    by checking multiple possible locations within the conda environment structure.\n\n    Args:\n        verbose (bool): If True, print additional information during the process.\n\n    Returns:\n        bool: True if both paths were set successfully, False otherwise.\n    \"\"\"\n    import sys\n\n    try:\n        from rasterio.env import set_gdal_config\n\n        # Get conda environment path\n        conda_env_path = os.environ.get(\"CONDA_PREFIX\") or sys.prefix\n\n        # Define possible paths for PROJ_LIB\n        possible_proj_paths = [\n            os.path.join(conda_env_path, \"share\", \"proj\"),\n            os.path.join(conda_env_path, \"Library\", \"share\", \"proj\"),\n            os.path.join(conda_env_path, \"Library\", \"share\"),\n        ]\n\n        # Define possible paths for GDAL_DATA\n        possible_gdal_paths = [\n            os.path.join(conda_env_path, \"share\", \"gdal\"),\n            os.path.join(conda_env_path, \"Library\", \"share\", \"gdal\"),\n            os.path.join(conda_env_path, \"Library\", \"data\", \"gdal\"),\n            os.path.join(conda_env_path, \"Library\", \"share\"),\n        ]\n\n        # Set PROJ_LIB environment variable\n        proj_set = False\n        for proj_path in possible_proj_paths:\n            if os.path.exists(proj_path) and os.path.isdir(proj_path):\n                # Verify it contains projection data\n                if os.path.exists(os.path.join(proj_path, \"proj.db\")):\n                    os.environ[\"PROJ_LIB\"] = proj_path\n                    if verbose:\n                        print(f\"PROJ_LIB set to: {proj_path}\")\n                    proj_set = True\n                    break\n\n        # Set GDAL_DATA environment variable\n        gdal_set = False\n        for gdal_path in possible_gdal_paths:\n            if os.path.exists(gdal_path) and os.path.isdir(gdal_path):\n                # Verify it contains the header.dxf file or other critical GDAL files\n                if os.path.exists(\n                    os.path.join(gdal_path, \"header.dxf\")\n                ) or os.path.exists(os.path.join(gdal_path, \"gcs.csv\")):\n                    os.environ[\"GDAL_DATA\"] = gdal_path\n                    if verbose:\n                        print(f\"GDAL_DATA set to: {gdal_path}\")\n                    gdal_set = True\n                    break\n\n        # If paths still not found, try a last-resort approach\n        if not proj_set or not gdal_set:\n            # Try a deep search in the conda environment\n            for root, dirs, files in os.walk(conda_env_path):\n                if not gdal_set and \"header.dxf\" in files:\n                    os.environ[\"GDAL_DATA\"] = root\n                    if verbose:\n                        print(f\"GDAL_DATA set to: {root} (deep search)\")\n                    gdal_set = True\n\n                if not proj_set and \"proj.db\" in files:\n                    os.environ[\"PROJ_LIB\"] = root\n                    if verbose:\n                        print(f\"PROJ_LIB set to: {root} (deep search)\")\n                    proj_set = True\n\n                if proj_set and gdal_set:\n                    break\n\n        set_gdal_config(\"PROJ_LIB\", os.environ[\"PROJ_LIB\"])\n        set_gdal_config(\"GDAL_DATA\", os.environ[\"GDAL_DATA\"])\n\n    except Exception as e:\n        print(f\"Error setting projection library paths: {e}\")\n        return\n</code></pre>"},{"location":"common/#beamgis.common.set_proxy","title":"<code>set_proxy(port=1080, ip='http://127.0.0.1')</code>","text":"<p>Sets proxy if needed. This is only needed for countries where Google services are not available.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The proxy port number. Defaults to 1080.</p> <code>1080</code> <code>ip</code> <code>str</code> <p>The IP address. Defaults to 'http://127.0.0.1'.</p> <code>'http://127.0.0.1'</code> Source code in <code>beamgis/common.py</code> <pre><code>def set_proxy(\n    port: Optional[int] = 1080, ip: Optional[str] = \"http://127.0.0.1\"\n) -&gt; None:\n    \"\"\"Sets proxy if needed. This is only needed for countries where Google services are not available.\n\n    Args:\n        port (int, optional): The proxy port number. Defaults to 1080.\n        ip (str, optional): The IP address. Defaults to 'http://127.0.0.1'.\n    \"\"\"\n\n    if not ip.startswith(\"http://\") and not ip.startswith(\"https://\"):\n        ip = f\"http://{ip}\"\n    proxy = f\"{ip}:{port}\"\n\n    os.environ[\"HTTP_PROXY\"] = proxy\n    os.environ[\"HTTPS_PROXY\"] = proxy\n\n    try:\n        response = requests.get(\"https://google.com\")\n        response.raise_for_status()\n    except requests.exceptions.RequestException as e:\n        print(\n            \"Failed to connect to Google Services. \"\n            \"Please double check the port number and IP address.\"\n        )\n        print(f\"Error: {e}\")\n</code></pre>"},{"location":"common/#beamgis.common.show_html","title":"<code>show_html(html)</code>","text":"<p>Shows HTML within Jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>File path or HTML string.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <p>Returns:</p> Type Description <code>ipywidgets.HTML</code> <p>HTML widget.</p> Source code in <code>beamgis/common.py</code> <pre><code>def show_html(html: str):\n    \"\"\"Shows HTML within Jupyter notebook.\n\n    Args:\n        html (str): File path or HTML string.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n\n    Returns:\n        ipywidgets.HTML: HTML widget.\n    \"\"\"\n    if os.path.exists(html):\n        with open(html, \"r\") as f:\n            content = f.read()\n\n        widget = widgets.HTML(value=content)\n        return widget\n    else:\n        try:\n            widget = widgets.HTML(value=html)\n            return widget\n        except Exception as e:\n            raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.show_image","title":"<code>show_image(img_path, width=None, height=None)</code>","text":"<p>Shows an image within Jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>The image file path.</p> required <code>width</code> <code>int</code> <p>Width of the image in pixels. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the image in pixels. Defaults to None.</p> <code>None</code> Source code in <code>beamgis/common.py</code> <pre><code>def show_image(\n    img_path: str, width: Optional[int] = None, height: Optional[int] = None\n):\n    \"\"\"Shows an image within Jupyter notebook.\n\n    Args:\n        img_path (str): The image file path.\n        width (int, optional): Width of the image in pixels. Defaults to None.\n        height (int, optional): Height of the image in pixels. Defaults to None.\n\n    \"\"\"\n    from IPython.display import display\n\n    try:\n        out = widgets.Output()\n        # layout={'border': '1px solid black'})\n        # layout={'border': '1px solid black', 'width': str(width + 20) + 'px', 'height': str(height + 10) + 'px'},)\n        out.outputs = ()\n        display(out)\n        with out:\n            file = open(img_path, \"rb\")\n            image = file.read()\n            if (width is None) and (height is None):\n                display(widgets.Image(value=image))\n            elif (width is not None) and (height is not None):\n                display(widgets.Image(value=image, width=width, height=height))\n            else:\n                print(\"You need set both width and height.\")\n                return\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#beamgis.common.show_youtube_video","title":"<code>show_youtube_video(url, width=800, height=450, allow_autoplay=False, **kwargs)</code>","text":"<p>Displays a Youtube video in a Jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>string</code> <p>a link to a Youtube video.</p> required <code>width</code> <code>int</code> <p>the width of the video. Defaults to 800.</p> <code>800</code> <code>height</code> <code>int</code> <p>the height of the video. Defaults to 600.</p> <code>450</code> <code>allow_autoplay</code> <code>bool</code> <p>whether to allow autoplay. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>further arguments for IPython.display.YouTubeVideo</p> <code>{}</code> <p>Returns:</p> Type Description <code>YouTubeVideo</code> <p>a video that is displayed in your notebook.</p> Source code in <code>beamgis/common.py</code> <pre><code>def show_youtube_video(url, width=800, height=450, allow_autoplay=False, **kwargs):\n    \"\"\"\n    Displays a Youtube video in a Jupyter notebook.\n\n    Args:\n        url (string): a link to a Youtube video.\n        width (int, optional): the width of the video. Defaults to 800.\n        height (int, optional): the height of the video. Defaults to 600.\n        allow_autoplay (bool, optional): whether to allow autoplay. Defaults to False.\n        **kwargs: further arguments for IPython.display.YouTubeVideo\n\n    Returns:\n        YouTubeVideo: a video that is displayed in your notebook.\n    \"\"\"\n    import re\n    from IPython.display import YouTubeVideo\n\n    if not isinstance(url, str):\n        raise TypeError(\"URL must be a string\")\n\n    match = re.match(\n        r\"^https?:\\/\\/(?:www\\.)?youtube\\.com\\/watch\\?(?=.*v=([^\\s&amp;]+)).*$|^https?:\\/\\/(?:www\\.)?youtu\\.be\\/([^\\s&amp;]+).*$\",\n        url,\n    )\n    if not match:\n        raise ValueError(\"Invalid YouTube video URL\")\n\n    video_id = match.group(1) if match.group(1) else match.group(2)\n\n    return YouTubeVideo(\n        video_id, width=width, height=height, allow_autoplay=allow_autoplay, **kwargs\n    )\n</code></pre>"},{"location":"common/#beamgis.common.shp_to_gdf","title":"<code>shp_to_gdf(in_shp)</code>","text":"<p>Converts a shapefile to Geopandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>File path to the input shapefile.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided shp could not be found.</p> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>geopandas.GeoDataFrame</p> Source code in <code>beamgis/common.py</code> <pre><code>def shp_to_gdf(in_shp):\n    \"\"\"Converts a shapefile to Geopandas dataframe.\n\n    Args:\n        in_shp (str): File path to the input shapefile.\n\n    Raises:\n        FileNotFoundError: The provided shp could not be found.\n\n    Returns:\n        gpd.GeoDataFrame: geopandas.GeoDataFrame\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    in_shp = os.path.abspath(in_shp)\n    if not os.path.exists(in_shp):\n        raise FileNotFoundError(\"The provided shp could not be found.\")\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n\n    try:\n        return gpd.read_file(in_shp)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.shp_to_geojson","title":"<code>shp_to_geojson(in_shp, output=None, encoding='utf-8', crs='EPSG:4326', **kwargs)</code>","text":"<p>Converts a shapefile to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>File path of the input shapefile.</p> required <code>output</code> <code>str</code> <p>File path of the output GeoJSON. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>The json object representing the shapefile.</p> Source code in <code>beamgis/common.py</code> <pre><code>def shp_to_geojson(in_shp, output=None, encoding=\"utf-8\", crs=\"EPSG:4326\", **kwargs):\n    \"\"\"Converts a shapefile to GeoJSON.\n\n    Args:\n        in_shp (str): File path of the input shapefile.\n        output (str, optional): File path of the output GeoJSON. Defaults to None.\n\n    Returns:\n        object: The json object representing the shapefile.\n    \"\"\"\n    try:\n        import geopandas as gpd\n\n        gdf = gpd.read_file(in_shp, **kwargs)\n        gdf.to_crs(crs, inplace=True)\n        if output is None:\n            return gdf.__geo_interface__\n        else:\n            gdf.to_file(output, driver=\"GeoJSON\")\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.skip_mkdocs_build","title":"<code>skip_mkdocs_build()</code>","text":"<p>Skips the MkDocs build if the USE_MKDOCS environment variable is set.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether to skip the MkDocs build.</p> Source code in <code>beamgis/common.py</code> <pre><code>def skip_mkdocs_build():\n    \"\"\"Skips the MkDocs build if the USE_MKDOCS environment variable is set.\n\n    Returns:\n        bool: Whether to skip the MkDocs build.\n    \"\"\"\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"common/#beamgis.common.split_parquet_by_geometries","title":"<code>split_parquet_by_geometries(input_parquet, output_dir, input_vector, column, filename_prefix='', filename_suffix='', driver='PARQUET', verbose=True)</code>","text":"<p>Split a Parquet file containing geometries based on intersection with features from a vector file.</p> <p>Parameters:</p> Name Type Description Default <code>input_parquet</code> <code>str</code> <p>Path to the input Parquet file containing geometries.</p> required <code>output_dir</code> <code>str</code> <p>Directory to save the split files.</p> required <code>input_vector</code> <code>str</code> <p>Path to the vector file containing geometries to split by.</p> required <code>column</code> <code>str</code> <p>Column name in the vector file to use for splitting.</p> required <code>filename_prefix</code> <code>str</code> <p>Prefix for output filenames.</p> <code>''</code> <code>filename_suffix</code> <code>str</code> <p>Suffix for output filenames.</p> <code>''</code> <code>driver</code> <code>str</code> <p>Output format driver (e.g., \"PARQUET\", \"GPKG\").</p> <code>'PARQUET'</code> <code>verbose</code> <code>bool</code> <p>Whether to print progress information.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments.</p> required <p>Exceptions:</p> Type Description <code>ParserException</code> <p>If there's a syntax error in the SQL query.</p> Source code in <code>beamgis/common.py</code> <pre><code>def split_parquet_by_geometries(\n    input_parquet,\n    output_dir,\n    input_vector,\n    column,\n    filename_prefix=\"\",\n    filename_suffix=\"\",\n    driver=\"PARQUET\",\n    verbose=True,\n):\n    \"\"\"\n    Split a Parquet file containing geometries based on intersection with features from a vector file.\n\n    Args:\n        input_parquet (str): Path to the input Parquet file containing geometries.\n        output_dir (str): Directory to save the split files.\n        input_vector (str): Path to the vector file containing geometries to split by.\n        column (str): Column name in the vector file to use for splitting.\n        filename_prefix (str): Prefix for output filenames.\n        filename_suffix (str): Suffix for output filenames.\n        driver (str): Output format driver (e.g., \"PARQUET\", \"GPKG\").\n        verbose (bool): Whether to print progress information.\n        **kwargs: Additional arguments.\n\n    Raises:\n        ParserException: If there's a syntax error in the SQL query.\n    \"\"\"\n    import duckdb\n\n    # Connect to DuckDB\n    con = duckdb.connect()\n\n    # Load spatial extension\n    con.execute(\"INSTALL spatial;\")\n    con.execute(\"LOAD spatial;\")\n\n    if driver.upper() == \"PARQUET\":\n        fmt = \"FORMAT PARQUET\"\n    else:\n        fmt = f\"FORMAT GDAL, DRIVER '{driver}'\"\n\n    os.makedirs(output_dir, exist_ok=True)\n\n    if input_vector.endswith(\".parquet\"):\n        read_str = f\"'{input_vector}'\"\n    else:\n        read_str = f\"ST_Read('{input_vector}')\"\n\n    # Get all state IDs from the parquet file\n    state_ids = con.execute(\n        f\"\"\"\n        SELECT {column} FROM {read_str}\n        \"\"\"\n    ).fetchall()\n\n    state_ids.sort()\n\n    geometry = \"geometry\"\n\n    column_names = get_vector_column_names(input_vector, db_con=con)\n    if \"geometry\" not in column_names:\n        if \"geom\" in column_names:\n            geometry = \"geom\"  # Fallback to geom if geometry is not available\n        else:\n            raise ValueError(\n                f\"The input vector file does not contain a geometry column. Available columns: {column_names}\"\n            )\n\n    # Loop through each state and save buildings\n    for index, (state_id,) in enumerate(state_ids):\n        if verbose:\n            print(\n                f\"Processing {index + 1}/{len(state_ids)}: Extracting geometries for '{state_id}'...\"\n            )\n\n        output_path = os.path.join(\n            output_dir, f\"{filename_prefix}{state_id}{filename_suffix}.{driver.lower()}\"\n        )\n\n        # Use proper path formatting\n        query = f\"\"\"\n        COPY (\n            WITH bbox AS (\n                SELECT {geometry} AS geom2\n                FROM {read_str}\n                WHERE {column} = '{state_id}'\n            )\n            SELECT * FROM '{input_parquet}'\n            WHERE ST_Intersects({geometry}, (SELECT geom2 FROM bbox))\n        ) TO '{output_path}' ({fmt});\n        \"\"\"\n\n        con.execute(query)\n\n    con.close()\n    print(\"Done!\")\n</code></pre>"},{"location":"common/#beamgis.common.split_raster","title":"<code>split_raster(filename, out_dir, tile_size=256, overlap=0, prefix='tile')</code>","text":"<p>Split a raster into tiles.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path or http URL to the raster file.</p> required <code>out_dir</code> <code>str</code> <p>The path to the output directory.</p> required <code>tile_size</code> <code>int | tuple</code> <p>The size of the tiles. Can be an integer or a tuple of (width, height). Defaults to 256.</p> <code>256</code> <code>overlap</code> <code>int</code> <p>The number of pixels to overlap between tiles. Defaults to 0.</p> <code>0</code> <code>prefix</code> <code>str</code> <p>The prefix of the output tiles. Defaults to \"tile\".</p> <code>'tile'</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>Raised if GDAL is not installed.</p> Source code in <code>beamgis/common.py</code> <pre><code>def split_raster(filename, out_dir, tile_size=256, overlap=0, prefix=\"tile\"):\n    \"\"\"Split a raster into tiles.\n\n    Args:\n        filename (str): The path or http URL to the raster file.\n        out_dir (str): The path to the output directory.\n        tile_size (int | tuple, optional): The size of the tiles. Can be an integer or a tuple of (width, height). Defaults to 256.\n        overlap (int, optional): The number of pixels to overlap between tiles. Defaults to 0.\n        prefix (str, optional): The prefix of the output tiles. Defaults to \"tile\".\n\n    Raises:\n        ImportError: Raised if GDAL is not installed.\n    \"\"\"\n\n    try:\n        from osgeo import gdal\n    except ImportError:\n        raise ImportError(\n            \"GDAL is required to use this function. Install it with `conda install gdal -c conda-forge`\"\n        )\n\n    if isinstance(filename, str):\n        if filename.startswith(\"http\"):\n            output = filename.split(\"/\")[-1]\n            download_file(filename, output)\n            filename = output\n\n    # Open the input GeoTIFF file\n    ds = gdal.Open(filename)\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if isinstance(tile_size, int):\n        tile_width = tile_size\n        tile_height = tile_size\n    elif isinstance(tile_size, tuple):\n        tile_width = tile_size[0]\n        tile_height = tile_size[1]\n    else:\n        raise ValueError(\"tile_size must be an integer or a tuple of (width, height)\")\n\n    # Get the size of the input raster\n    width = ds.RasterXSize\n    height = ds.RasterYSize\n\n    # Calculate the number of tiles needed in both directions, taking into account the overlap\n    num_tiles_x = (width - overlap) // (tile_width - overlap) + int(\n        (width - overlap) % (tile_width - overlap) &gt; 0\n    )\n    num_tiles_y = (height - overlap) // (tile_height - overlap) + int(\n        (height - overlap) % (tile_height - overlap) &gt; 0\n    )\n\n    # Get the georeferencing information of the input raster\n    geotransform = ds.GetGeoTransform()\n\n    # Loop over all the tiles\n    for i in range(num_tiles_x):\n        for j in range(num_tiles_y):\n            # Calculate the pixel coordinates of the tile, taking into account the overlap and clamping to the edge of the raster\n            x_min = i * (tile_width - overlap)\n            y_min = j * (tile_height - overlap)\n            x_max = min(x_min + tile_width, width)\n            y_max = min(y_min + tile_height, height)\n\n            # Adjust the size of the last tile in each row and column to include any remaining pixels\n            if i == num_tiles_x - 1:\n                x_min = max(x_max - tile_width, 0)\n            if j == num_tiles_y - 1:\n                y_min = max(y_max - tile_height, 0)\n\n            # Calculate the size of the tile, taking into account the overlap\n            tile_width = x_max - x_min\n            tile_height = y_max - y_min\n\n            # Set the output file name\n            output_file = f\"{out_dir}/{prefix}_{i}_{j}.tif\"\n\n            # Create a new dataset for the tile\n            driver = gdal.GetDriverByName(\"GTiff\")\n            tile_ds = driver.Create(\n                output_file,\n                tile_width,\n                tile_height,\n                ds.RasterCount,\n                ds.GetRasterBand(1).DataType,\n            )\n\n            # Calculate the georeferencing information for the output tile\n            tile_geotransform = (\n                geotransform[0] + x_min * geotransform[1],\n                geotransform[1],\n                0,\n                geotransform[3] + y_min * geotransform[5],\n                0,\n                geotransform[5],\n            )\n\n            # Set the geotransform and projection of the tile\n            tile_ds.SetGeoTransform(tile_geotransform)\n            tile_ds.SetProjection(ds.GetProjection())\n\n            # Read the data from the input raster band(s) and write it to the tile band(s)\n            for k in range(ds.RasterCount):\n                band = ds.GetRasterBand(k + 1)\n                tile_band = tile_ds.GetRasterBand(k + 1)\n                tile_data = band.ReadAsArray(x_min, y_min, tile_width, tile_height)\n                tile_band.WriteArray(tile_data)\n\n            # Close the tile dataset\n            tile_ds = None\n\n    # Close the input dataset\n    ds = None\n</code></pre>"},{"location":"common/#beamgis.common.st_download_button","title":"<code>st_download_button(label, data, file_name=None, mime=None, key=None, help=None, on_click=None, args=None, csv_sep=',', **kwargs)</code>","text":"<p>Streamlit function to create a download button.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>A short label explaining to the user what this button is for..</p> required <code>data</code> <code>str | list</code> <p>The contents of the file to be downloaded. See example below for caching techniques to avoid recomputing this data unnecessarily.</p> required <code>file_name</code> <code>str</code> <p>An optional string to use as the name of the file to be downloaded, such as 'my_file.csv'. If not specified, the name will be automatically generated. Defaults to None.</p> <code>None</code> <code>mime</code> <code>str</code> <p>The MIME type of the data. If None, defaults to \"text/plain\" (if data is of type str or is a textual file) or \"application/octet-stream\" (if data is of type bytes or is a binary file). Defaults to None.</p> <code>None</code> <code>key</code> <code>str</code> <p>An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. Multiple widgets of the same type may not share the same key. Defaults to None.</p> <code>None</code> <code>help</code> <code>str</code> <p>An optional tooltip that gets displayed when the button is hovered over. Defaults to None.</p> <code>None</code> <code>on_click</code> <code>str</code> <p>An optional callback invoked when this button is clicked. Defaults to None.</p> <code>None</code> <code>args</code> <code>list</code> <p>An optional tuple of args to pass to the callback. Defaults to None.</p> <code>None</code> <code>kwargs</code> <code>dict</code> <p>An optional tuple of args to pass to the callback.</p> <code>{}</code> Source code in <code>beamgis/common.py</code> <pre><code>def st_download_button(\n    label,\n    data,\n    file_name=None,\n    mime=None,\n    key=None,\n    help=None,\n    on_click=None,\n    args=None,\n    csv_sep=\",\",\n    **kwargs,\n):\n    \"\"\"Streamlit function to create a download button.\n\n    Args:\n        label (str): A short label explaining to the user what this button is for..\n        data (str | list): The contents of the file to be downloaded. See example below for caching techniques to avoid recomputing this data unnecessarily.\n        file_name (str, optional): An optional string to use as the name of the file to be downloaded, such as 'my_file.csv'. If not specified, the name will be automatically generated. Defaults to None.\n        mime (str, optional): The MIME type of the data. If None, defaults to \"text/plain\" (if data is of type str or is a textual file) or \"application/octet-stream\" (if data is of type bytes or is a binary file). Defaults to None.\n        key (str, optional): An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. Multiple widgets of the same type may not share the same key. Defaults to None.\n        help (str, optional): An optional tooltip that gets displayed when the button is hovered over. Defaults to None.\n        on_click (str, optional): An optional callback invoked when this button is clicked. Defaults to None.\n        args (list, optional): An optional tuple of args to pass to the callback. Defaults to None.\n        kwargs (dict, optional): An optional tuple of args to pass to the callback.\n\n    \"\"\"\n    try:\n        import streamlit as st\n        import pandas as pd\n\n        if key is None:\n            key = random_string(6)\n\n        if isinstance(data, str):\n            if file_name is None:\n                file_name = data.split(\"/\")[-1]\n\n            if data.endswith(\".csv\"):\n                data = pd.read_csv(data).to_csv(sep=csv_sep, index=False)\n                if mime is None:\n                    mime = \"text/csv\"\n                return st.download_button(\n                    label, data, file_name, mime, key, help, on_click, args, **kwargs\n                )\n            elif (\n                data.endswith(\".gif\") or data.endswith(\".png\") or data.endswith(\".jpg\")\n            ):\n                if mime is None:\n                    mime = f\"image/{os.path.splitext(data)[1][1:]}\"\n\n                with open(data, \"rb\") as file:\n                    return st.download_button(\n                        label,\n                        file,\n                        file_name,\n                        mime,\n                        key,\n                        help,\n                        on_click,\n                        args,\n                        **kwargs,\n                    )\n        elif isinstance(data, pd.DataFrame):\n            if file_name is None:\n                file_name = \"data.csv\"\n\n            data = data.to_csv(sep=csv_sep, index=False)\n            if mime is None:\n                mime = \"text/csv\"\n            return st.download_button(\n                label, data, file_name, mime, key, help, on_click, args, **kwargs\n            )\n\n        else:\n            # if mime is None:\n            #     mime = \"application/pdf\"\n            return st.download_button(\n                label,\n                data,\n                file_name,\n                mime,\n                key,\n                help,\n                on_click,\n                args,\n                **kwargs,\n            )\n\n    except ImportError:\n        print(\"Streamlit is not installed. Please run 'pip install streamlit'.\")\n        return\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.start_server","title":"<code>start_server(directory=None, port=8000, background=True, quiet=True)</code>","text":"<p>Start a simple web server to serve files from the specified directory with directory listing and CORS support. Optionally, run the server asynchronously in a background thread.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>The directory from which files will be served.</p> <code>None</code> <code>port</code> <code>int</code> <p>The port on which the web server will run. Defaults to 8000.</p> <code>8000</code> <code>background</code> <code>bool</code> <p>Whether to run the server in a separate background thread.                          Defaults to True.</p> <code>True</code> <code>quiet</code> <code>bool</code> <p>If True, suppress the log output. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If required modules are not found.</p> <code>Exception</code> <p>Catches other unexpected errors during execution.</p> <p>Returns:</p> Type Description <code>None</code> <p>None. The function runs the server indefinitely until manually stopped.</p> Source code in <code>beamgis/common.py</code> <pre><code>def start_server(\n    directory: str = None, port: int = 8000, background: bool = True, quiet: bool = True\n) -&gt; None:\n    \"\"\"\n    Start a simple web server to serve files from the specified directory\n    with directory listing and CORS support. Optionally, run the server\n    asynchronously in a background thread.\n\n    Args:\n        directory (str): The directory from which files will be served.\n        port (int, optional): The port on which the web server will run. Defaults to 8000.\n        background (bool, optional): Whether to run the server in a separate background thread.\n                                     Defaults to True.\n        quiet (bool, optional): If True, suppress the log output. Defaults to True.\n\n    Raises:\n        ImportError: If required modules are not found.\n        Exception: Catches other unexpected errors during execution.\n\n    Returns:\n        None. The function runs the server indefinitely until manually stopped.\n    \"\"\"\n\n    # If no directory is specified, use the current working directory\n    if directory is None:\n        directory = os.getcwd()\n\n    def run_flask():\n        try:\n            from flask import Flask, send_from_directory, render_template_string\n            from flask_cors import CORS\n\n            app = Flask(__name__, static_folder=directory)\n            CORS(app)  # Enable CORS for all routes\n\n            if quiet:\n                # This will disable Flask's logging\n                import logging\n\n                log = logging.getLogger(\"werkzeug\")\n                log.disabled = True\n                app.logger.disabled = True\n\n            @app.route(\"/&lt;path:path&gt;\", methods=[\"GET\"])\n            def serve_file(path):\n                return send_from_directory(directory, path)\n\n            @app.route(\"/\", methods=[\"GET\"])\n            def index():\n                # List files and directories under the specified directory\n                items = os.listdir(directory)\n                items.sort()\n                # Generate an HTML representation of the directory listing\n                listing_template = \"\"\"\n                &lt;h2&gt;Directory listing for /&lt;/h2&gt;\n                &lt;hr&gt;\n                &lt;ul&gt;\n                    {% for item in items %}\n                        &lt;li&gt;&lt;a href=\"{{ item }}\"&gt;{{ item }}&lt;/a&gt;&lt;/li&gt;\n                    {% endfor %}\n                &lt;/ul&gt;\n                \"\"\"\n                return render_template_string(listing_template, items=items)\n\n            print(f\"Server is running at http://127.0.0.1:{port}/\")\n            app.run(port=port)\n\n        except ImportError as e:\n            print(f\"Error importing module: {e}\")\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n\n    if background:\n        import threading\n\n        # Start the Flask server in a new background thread\n        t = threading.Thread(target=run_flask)\n        t.start()\n    else:\n        # Run the Flask server in the main thread\n        run_flask()\n</code></pre>"},{"location":"common/#beamgis.common.streamlit_legend","title":"<code>streamlit_legend(html, width=None, height=None, scrolling=True)</code>","text":"<p>Streamlit function to display a legend.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>The HTML string of the legend.</p> required <code>width</code> <code>str</code> <p>The width of the legend. Defaults to None.</p> <code>None</code> <code>height</code> <code>str</code> <p>The height of the legend. Defaults to None.</p> <code>None</code> <code>scrolling</code> <code>bool</code> <p>Whether to allow scrolling in the legend. Defaults to True.</p> <code>True</code> Source code in <code>beamgis/common.py</code> <pre><code>def streamlit_legend(html, width=None, height=None, scrolling=True):\n    \"\"\"Streamlit function to display a legend.\n\n    Args:\n        html (str): The HTML string of the legend.\n        width (str, optional): The width of the legend. Defaults to None.\n        height (str, optional): The height of the legend. Defaults to None.\n        scrolling (bool, optional): Whether to allow scrolling in the legend. Defaults to True.\n\n    \"\"\"\n\n    try:\n        import streamlit.components.v1 as components\n\n        components.html(html, width=width, height=height, scrolling=scrolling)\n\n    except ImportError:\n        print(\"Streamlit is not installed. Please run 'pip install streamlit'.\")\n        return\n</code></pre>"},{"location":"common/#beamgis.common.system_fonts","title":"<code>system_fonts(show_full_path=False)</code>","text":"<p>Gets a list of system fonts</p> <pre><code># Common font locations:\n# Linux: /usr/share/fonts/TTF/\n# Windows: C:/Windows/Fonts\n# macOS:  System &gt; Library &gt; Fonts\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>show_full_path</code> <code>bool</code> <p>Whether to show the full path of each system font. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of system fonts.</p> Source code in <code>beamgis/common.py</code> <pre><code>def system_fonts(show_full_path: Optional[bool] = False) -&gt; List:\n    \"\"\"Gets a list of system fonts\n\n        # Common font locations:\n        # Linux: /usr/share/fonts/TTF/\n        # Windows: C:/Windows/Fonts\n        # macOS:  System &gt; Library &gt; Fonts\n\n    Args:\n        show_full_path (bool, optional): Whether to show the full path of each system font. Defaults to False.\n\n    Returns:\n        list: A list of system fonts.\n    \"\"\"\n    try:\n        import matplotlib.font_manager\n\n        font_list = matplotlib.font_manager.findSystemFonts(\n            fontpaths=None, fontext=\"ttf\"\n        )\n        font_list.sort()\n\n        font_names = [os.path.basename(f) for f in font_list]\n        font_names.sort()\n\n        if show_full_path:\n            return font_list\n        else:\n            return font_names\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.temp_file_path","title":"<code>temp_file_path(extension)</code>","text":"<p>Returns a temporary file path.</p> <p>Parameters:</p> Name Type Description Default <code>extension</code> <code>str</code> <p>The file extension.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The temporary file path.</p> Source code in <code>beamgis/common.py</code> <pre><code>def temp_file_path(extension):\n    \"\"\"Returns a temporary file path.\n\n    Args:\n        extension (str): The file extension.\n\n    Returns:\n        str: The temporary file path.\n    \"\"\"\n\n    import tempfile\n    import uuid\n\n    if not extension.startswith(\".\"):\n        extension = \".\" + extension\n    file_id = str(uuid.uuid4())\n    file_path = os.path.join(tempfile.gettempdir(), f\"{file_id}{extension}\")\n\n    return file_path\n</code></pre>"},{"location":"common/#beamgis.common.tif_to_jp2","title":"<code>tif_to_jp2(filename, output, creationOptions=None)</code>","text":"<p>Converts a GeoTIFF to JPEG2000.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the GeoTIFF file.</p> required <code>output</code> <code>str</code> <p>The path to the output JPEG2000 file.</p> required <code>creationOptions</code> <code>list</code> <p>A list of creation options for the JPEG2000 file. See https://gdal.org/drivers/raster/jp2openjpeg.html. For example, to specify the compression ratio, use <code>[\"QUALITY=20\"]</code>. A value of 20 means the file will be 20% of the size in comparison to uncompressed data.</p> <code>None</code> Source code in <code>beamgis/common.py</code> <pre><code>def tif_to_jp2(filename, output, creationOptions=None):\n    \"\"\"Converts a GeoTIFF to JPEG2000.\n\n    Args:\n        filename (str): The path to the GeoTIFF file.\n        output (str): The path to the output JPEG2000 file.\n        creationOptions (list): A list of creation options for the JPEG2000 file. See\n            https://gdal.org/drivers/raster/jp2openjpeg.html. For example, to specify the compression\n            ratio, use ``[\"QUALITY=20\"]``. A value of 20 means the file will be 20% of the size in comparison\n            to uncompressed data.\n\n    \"\"\"\n\n    if not os.path.exists(filename):\n        raise Exception(f\"File {filename} does not exist\")\n\n    if not output.endswith(\".jp2\"):\n        output += \".jp2\"\n\n    from osgeo import gdal\n\n    in_ds = gdal.Open(filename)\n    gdal.Translate(output, in_ds, format=\"JP2OpenJPEG\", creationOptions=creationOptions)\n    in_ds = None\n</code></pre>"},{"location":"common/#beamgis.common.tms_to_geotiff","title":"<code>tms_to_geotiff(output, bbox, zoom=None, resolution=None, source='OpenStreetMap', crs='EPSG:3857', to_cog=False, quiet=False, **kwargs)</code>","text":"<p>Download map tiles and convert them to a GeoTIFF. The source is adapted from https://github.com/gumblex/tms2geotiff.     Credits to the GitHub user @gumblex.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The output GeoTIFF file.</p> required <code>bbox</code> <code>list</code> <p>The bounding box [minx, miny, maxx, maxy] coordinates in EPSG:4326, e.g., [-122.5216, 37.733, -122.3661, 37.8095]</p> required <code>zoom</code> <code>int</code> <p>The map zoom level. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>float</code> <p>The resolution in meters. Defaults to None.</p> <code>None</code> <code>source</code> <code>str</code> <p>The tile source. It can be one of the following: \"OPENSTREETMAP\", \"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or an HTTP URL. Defaults to \"OpenStreetMap\".</p> <code>'OpenStreetMap'</code> <code>crs</code> <code>str</code> <p>The coordinate reference system. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>to_cog</code> <code>bool</code> <p>Convert to Cloud Optimized GeoTIFF. Defaults to False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments to pass to gdal.GetDriverByName(\"GTiff\").Create().</p> <code>{}</code> Source code in <code>beamgis/common.py</code> <pre><code>def map_tiles_to_geotiff(\n    output,\n    bbox,\n    zoom=None,\n    resolution=None,\n    source=\"OpenStreetMap\",\n    crs=\"EPSG:3857\",\n    to_cog=False,\n    quiet=False,\n    **kwargs,\n):\n    \"\"\"Download map tiles and convert them to a GeoTIFF. The source is adapted from https://github.com/gumblex/tms2geotiff.\n        Credits to the GitHub user @gumblex.\n\n    Args:\n        output (str): The output GeoTIFF file.\n        bbox (list): The bounding box [minx, miny, maxx, maxy] coordinates in EPSG:4326, e.g., [-122.5216, 37.733, -122.3661, 37.8095]\n        zoom (int, optional): The map zoom level. Defaults to None.\n        resolution (float, optional): The resolution in meters. Defaults to None.\n        source (str, optional): The tile source. It can be one of the following: \"OPENSTREETMAP\", \"ROADMAP\",\n            \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or an HTTP URL. Defaults to \"OpenStreetMap\".\n        crs (str, optional): The coordinate reference system. Defaults to \"EPSG:3857\".\n        to_cog (bool, optional): Convert to Cloud Optimized GeoTIFF. Defaults to False.\n        quiet (bool, optional): Suppress output. Defaults to False.\n        **kwargs: Additional arguments to pass to gdal.GetDriverByName(\"GTiff\").Create().\n\n    \"\"\"\n    import re\n    import io\n    import math\n    import itertools\n    import concurrent.futures\n\n    import numpy\n    from PIL import Image\n\n    try:\n        from osgeo import gdal, osr\n    except ImportError:\n        raise ImportError(\"GDAL is not installed. Install it with pip install GDAL\")\n\n    try:\n        import httpx\n\n        SESSION = httpx.Client()\n    except ImportError:\n        import requests\n\n        SESSION = requests.Session()\n\n    SESSION.headers.update(\n        {\n            \"Accept\": \"*/*\",\n            \"Accept-Encoding\": \"gzip, deflate\",\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0\",\n        }\n    )\n\n    xyz_tiles = {\n        \"OPENSTREETMAP\": {\n            \"url\": \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            \"attribution\": \"OpenStreetMap\",\n            \"name\": \"OpenStreetMap\",\n        },\n        \"ROADMAP\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Maps\",\n        },\n        \"SATELLITE\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Satellite\",\n        },\n        \"TERRAIN\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Terrain\",\n        },\n        \"HYBRID\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Satellite\",\n        },\n    }\n\n    if isinstance(source, str) and source.upper() in xyz_tiles:\n        source = xyz_tiles[source.upper()][\"url\"]\n    elif isinstance(source, str) and source.startswith(\"http\"):\n        pass\n    elif isinstance(source, str):\n        tiles = basemap_xyz_tiles()\n        if source in tiles:\n            source = tiles[source].url\n    else:\n        raise ValueError(\n            'source must be one of \"OpenStreetMap\", \"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or a URL'\n        )\n\n    # Web Mercator tile size in meters at zoom level 0\n    MERCATOR_ZOOM_0_RESOLUTION_M = 156543.03392804097\n\n    def resolution_to_zoom_level(resolution):\n        \"\"\"\n        Convert map resolution in meters to zoom level for Web Mercator (EPSG:3857) tiles.\n        \"\"\"\n        initial_resolution = MERCATOR_ZOOM_0_RESOLUTION_M\n\n        # Calculate the zoom level\n        zoom_level = math.log2(initial_resolution / resolution)\n\n        return int(zoom_level)\n\n    def zoom_level_to_resolution(zoom):\n        \"\"\"\n        Convert map zoom level to resolution in meters for Web Mercator (EPSG:3857) tiles.\n        \"\"\"\n        initial_resolution = MERCATOR_ZOOM_0_RESOLUTION_M\n\n        # Calculate resolution\n        resolution_m = initial_resolution / (2**zoom)\n\n        return resolution_m\n\n    if isinstance(bbox, list) and len(bbox) == 4:\n        west, south, east, north = bbox\n    else:\n        raise ValueError(\n            \"bbox must be a list of 4 coordinates in the format of [xmin, ymin, xmax, ymax]\"\n        )\n\n    if (zoom is None) and (resolution is None):\n        raise ValueError(\"Either zoom or resolution must be provided\")\n\n    elif (zoom is not None) and (resolution is not None):\n        raise ValueError(\"Only one of zoom or resolution can be provided\")\n\n    elif (zoom is None) and (resolution is not None):\n        zoom = resolution_to_zoom_level(resolution)\n    else:\n        # condition: (resolution is None) and (zoom is not None):\n        resolution = zoom_level_to_resolution(zoom)\n\n    EARTH_EQUATORIAL_RADIUS = 6378137.0\n\n    Image.MAX_IMAGE_PIXELS = None\n\n    gdal.UseExceptions()\n    web_mercator = osr.SpatialReference()\n    try:\n        web_mercator.ImportFromEPSG(3857)\n    except RuntimeError as e:\n        # https://github.com/PDAL/PDAL/issues/2544#issuecomment-637995923\n        if \"PROJ\" in str(e):\n            pattern = r\"/[\\w/]+\"\n            match = re.search(pattern, str(e))\n            if match:\n                file_path = match.group(0)\n                os.environ[\"PROJ_LIB\"] = file_path\n                os.environ[\"GDAL_DATA\"] = file_path.replace(\"proj\", \"gdal\")\n                web_mercator.ImportFromEPSG(3857)\n\n    WKT_3857 = web_mercator.ExportToWkt()\n\n    def from4326_to3857(lat, lon):\n        xtile = math.radians(lon) * EARTH_EQUATORIAL_RADIUS\n        ytile = (\n            math.log(math.tan(math.radians(45 + lat / 2.0))) * EARTH_EQUATORIAL_RADIUS\n        )\n        return (xtile, ytile)\n\n    def deg2num(lat, lon, zoom):\n        lat_r = math.radians(lat)\n        n = 2**zoom\n        xtile = (lon + 180) / 360 * n\n        ytile = (1 - math.log(math.tan(lat_r) + 1 / math.cos(lat_r)) / math.pi) / 2 * n\n        return (xtile, ytile)\n\n    def is_empty(im):\n        extrema = im.getextrema()\n        if len(extrema) &gt;= 3:\n            if len(extrema) &gt; 3 and extrema[-1] == (0, 0):\n                return True\n            for ext in extrema[:3]:\n                if ext != (0, 0):\n                    return False\n            return True\n        else:\n            return extrema[0] == (0, 0)\n\n    def paste_tile(bigim, base_size, tile, corner_xy, bbox):\n        if tile is None:\n            return bigim\n        im = Image.open(io.BytesIO(tile))\n        mode = \"RGB\" if im.mode == \"RGB\" else \"RGBA\"\n        size = im.size\n        if bigim is None:\n            base_size[0] = size[0]\n            base_size[1] = size[1]\n            newim = Image.new(\n                mode, (size[0] * (bbox[2] - bbox[0]), size[1] * (bbox[3] - bbox[1]))\n            )\n        else:\n            newim = bigim\n\n        dx = abs(corner_xy[0] - bbox[0])\n        dy = abs(corner_xy[1] - bbox[1])\n        xy0 = (size[0] * dx, size[1] * dy)\n        if mode == \"RGB\":\n            newim.paste(im, xy0)\n        else:\n            if im.mode != mode:\n                im = im.convert(mode)\n            if not is_empty(im):\n                newim.paste(im, xy0)\n        im.close()\n        return newim\n\n    def finish_picture(bigim, base_size, bbox, x0, y0, x1, y1):\n        xfrac = x0 - bbox[0]\n        yfrac = y0 - bbox[1]\n        x2 = round(base_size[0] * xfrac)\n        y2 = round(base_size[1] * yfrac)\n        imgw = round(base_size[0] * (x1 - x0))\n        imgh = round(base_size[1] * (y1 - y0))\n        retim = bigim.crop((x2, y2, x2 + imgw, y2 + imgh))\n        if retim.mode == \"RGBA\" and retim.getextrema()[3] == (255, 255):\n            retim = retim.convert(\"RGB\")\n        bigim.close()\n        return retim\n\n    def get_tile(url):\n        retry = 3\n        while 1:\n            try:\n                r = SESSION.get(url, timeout=60)\n                break\n            except Exception:\n                retry -= 1\n                if not retry:\n                    raise\n        if r.status_code == 404:\n            return None\n        elif not r.content:\n            return None\n        r.raise_for_status()\n        return r.content\n\n    def draw_tile(\n        source, lat0, lon0, lat1, lon1, zoom, filename, quiet=False, **kwargs\n    ):\n        x0, y0 = deg2num(lat0, lon0, zoom)\n        x1, y1 = deg2num(lat1, lon1, zoom)\n        x0, x1 = sorted([x0, x1])\n        y0, y1 = sorted([y0, y1])\n        corners = tuple(\n            itertools.product(\n                range(math.floor(x0), math.ceil(x1)),\n                range(math.floor(y0), math.ceil(y1)),\n            )\n        )\n        totalnum = len(corners)\n        futures = []\n        with concurrent.futures.ThreadPoolExecutor(5) as executor:\n            for x, y in corners:\n                futures.append(\n                    executor.submit(get_tile, source.format(z=zoom, x=x, y=y))\n                )\n            bbox = (math.floor(x0), math.floor(y0), math.ceil(x1), math.ceil(y1))\n            bigim = None\n            base_size = [256, 256]\n            for k, (fut, corner_xy) in enumerate(zip(futures, corners), 1):\n                bigim = paste_tile(bigim, base_size, fut.result(), corner_xy, bbox)\n                if not quiet:\n                    print(\"Downloaded image %d/%d\" % (k, totalnum))\n\n        if not quiet:\n            print(\"Saving GeoTIFF. Please wait...\")\n        img = finish_picture(bigim, base_size, bbox, x0, y0, x1, y1)\n        imgbands = len(img.getbands())\n        driver = gdal.GetDriverByName(\"GTiff\")\n\n        if \"options\" not in kwargs:\n            kwargs[\"options\"] = [\n                \"COMPRESS=DEFLATE\",\n                \"PREDICTOR=2\",\n                \"ZLEVEL=9\",\n                \"TILED=YES\",\n            ]\n\n        kwargs.pop(\"overwrite\", None)\n        gtiff = driver.Create(\n            filename,\n            img.size[0],\n            img.size[1],\n            imgbands,\n            gdal.GDT_Byte,\n            **kwargs,\n        )\n\n        gtiff.SetMetadata({\"ZOOM_LEVEL\": str(zoom), \"RESOLUTION_M\": str(resolution)})\n\n        xp0, yp0 = from4326_to3857(lat0, lon0)\n        xp1, yp1 = from4326_to3857(lat1, lon1)\n        pwidth = abs(xp1 - xp0) / img.size[0]\n        pheight = abs(yp1 - yp0) / img.size[1]\n        gtiff.SetGeoTransform((min(xp0, xp1), pwidth, 0, max(yp0, yp1), 0, -pheight))\n        gtiff.SetProjection(WKT_3857)\n        for band in range(imgbands):\n            array = np.array(img.getdata(band), dtype=\"u8\")\n            array = array.reshape((img.size[1], img.size[0]))\n            band = gtiff.GetRasterBand(band + 1)\n            band.WriteArray(array)\n        gtiff.FlushCache()\n\n        if not quiet:\n            print(f\"Image saved to {filename}\")\n        return img\n\n    try:\n        draw_tile(source, south, west, north, east, zoom, output, quiet, **kwargs)\n        if crs.upper() != \"EPSG:3857\":\n            reproject(image=output, output=output, dst_crs=crs, to_cog=to_cog)\n        elif to_cog:\n            image_to_cog(source=output, dst_path=output)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.to_hex_colors","title":"<code>to_hex_colors(colors)</code>","text":"<p>Adds # to a list of hex color codes.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>list</code> <p>A list of hex color codes.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of hex color codes prefixed with #.</p> Source code in <code>beamgis/common.py</code> <pre><code>def to_hex_colors(colors):\n    \"\"\"Adds # to a list of hex color codes.\n\n    Args:\n        colors (list): A list of hex color codes.\n\n    Returns:\n        list: A list of hex color codes prefixed with #.\n    \"\"\"\n    result = all([len(color.strip()) == 6 for color in colors])\n    if result:\n        return [\"#\" + color.strip() for color in colors]\n    else:\n        return colors\n</code></pre>"},{"location":"common/#beamgis.common.transform_bbox_coords","title":"<code>transform_bbox_coords(bbox, src_crs, dst_crs, **kwargs)</code>","text":"<p>Transforms the coordinates of a bounding box [x1, y1, x2, y2] from one CRS to another.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list | tuple</code> <p>The bounding box [x1, y1, x2, y2] coordinates.</p> required <code>src_crs</code> <code>str</code> <p>The source CRS, e.g., \"EPSG:4326\".</p> required <code>dst_crs</code> <code>str</code> <p>The destination CRS, e.g., \"EPSG:3857\".</p> required <p>Returns:</p> Type Description <code>list</code> <p>The transformed bounding box [x1, y1, x2, y2] coordinates.</p> Source code in <code>beamgis/common.py</code> <pre><code>def transform_bbox_coords(bbox, src_crs, dst_crs, **kwargs):\n    \"\"\"Transforms the coordinates of a bounding box [x1, y1, x2, y2] from one CRS to another.\n\n    Args:\n        bbox (list | tuple): The bounding box [x1, y1, x2, y2] coordinates.\n        src_crs (str): The source CRS, e.g., \"EPSG:4326\".\n        dst_crs (str): The destination CRS, e.g., \"EPSG:3857\".\n\n    Returns:\n        list: The transformed bounding box [x1, y1, x2, y2] coordinates.\n    \"\"\"\n    x1, y1, x2, y2 = bbox\n\n    x1, y1 = transform_coords(\n        x1, y1, src_crs, dst_crs, **kwargs\n    )  # pylint: disable=E0633\n    x2, y2 = transform_coords(\n        x2, y2, src_crs, dst_crs, **kwargs\n    )  # pylint: disable=E0633\n\n    return [x1, y1, x2, y2]\n</code></pre>"},{"location":"common/#beamgis.common.transform_coords","title":"<code>transform_coords(x, y, src_crs, dst_crs, **kwargs)</code>","text":"<p>Transform coordinates from one CRS to another.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x coordinate.</p> required <code>y</code> <code>float</code> <p>The y coordinate.</p> required <code>src_crs</code> <code>str</code> <p>The source CRS, e.g., \"EPSG:4326\".</p> required <code>dst_crs</code> <code>str</code> <p>The destination CRS, e.g., \"EPSG:3857\".</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The transformed coordinates in the format of (x, y)</p> Source code in <code>beamgis/common.py</code> <pre><code>def transform_coords(x, y, src_crs, dst_crs, **kwargs):\n    \"\"\"Transform coordinates from one CRS to another.\n\n    Args:\n        x (float): The x coordinate.\n        y (float): The y coordinate.\n        src_crs (str): The source CRS, e.g., \"EPSG:4326\".\n        dst_crs (str): The destination CRS, e.g., \"EPSG:3857\".\n\n    Returns:\n        dict: The transformed coordinates in the format of (x, y)\n    \"\"\"\n    import pyproj\n\n    transformer = pyproj.Transformer.from_crs(\n        src_crs, dst_crs, always_xy=True, **kwargs\n    )\n    return transformer.transform(x, y)\n</code></pre>"},{"location":"common/#beamgis.common.update_package","title":"<code>update_package()</code>","text":"<p>Updates the leafmap package from the leafmap GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package.</p> Source code in <code>beamgis/common.py</code> <pre><code>def update_package() -&gt; None:\n    \"\"\"Updates the leafmap package from the leafmap GitHub repository without the need to use pip or conda.\n    In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package.\n\n    \"\"\"\n\n    download_dir = Path.home() / \"Downloads\"\n    download_dir.mkdir(parents=True, exist_ok=True)\n    _clone_repo(out_dir=str(download_dir))\n    pkg_dir = download_dir / \"leafmap-master\"\n    work_dir = Path.cwd()\n\n    os.chdir(pkg_dir)\n    try:\n        if shutil.which(\"pip\"):\n            cmd = [\"pip\", \"install\", \".\"]\n        else:\n            cmd = [\"pip3\", \"install\", \".\"]\n        subprocess.run(cmd, check=True)\n    except subprocess.CalledProcessError as error:\n        print(f\"Failed to install the package: {error}\")\n    finally:\n        os.chdir(work_dir)\n\n    print(\n        \"\\nPlease comment out 'leafmap.update_package()' and restart kernel to take effect:\\n\"\n        \"Jupyter menu -&gt; Kernel -&gt; Restart &amp; Clear Output\"\n    )\n</code></pre>"},{"location":"common/#beamgis.common.upload_to_imgur","title":"<code>upload_to_imgur(in_gif)</code>","text":"<p>Uploads an image to imgur.com</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The file path to the image.</p> required Source code in <code>beamgis/common.py</code> <pre><code>def upload_to_imgur(in_gif: str):\n    \"\"\"Uploads an image to imgur.com\n\n    Args:\n        in_gif (str): The file path to the image.\n    \"\"\"\n    import subprocess\n\n    pkg_name = \"imgur-uploader\"\n    if not _is_tool(pkg_name):\n        _check_install(pkg_name)\n\n    try:\n        IMGUR_API_ID = os.environ.get(\"IMGUR_API_ID\", None)\n        IMGUR_API_SECRET = os.environ.get(\"IMGUR_API_SECRET\", None)\n        credentials_path = os.path.join(\n            os.path.expanduser(\"~\"), \".config/imgur_uploader/uploader.cfg\"\n        )\n\n        if (\n            (IMGUR_API_ID is not None) and (IMGUR_API_SECRET is not None)\n        ) or os.path.exists(credentials_path):\n            proc = subprocess.Popen([\"imgur-uploader\", in_gif], stdout=subprocess.PIPE)\n            for _ in range(0, 2):\n                line = proc.stdout.readline()\n                print(line.rstrip().decode(\"utf-8\"))\n            # while True:\n            #     line = proc.stdout.readline()\n            #     if not line:\n            #         break\n            #     print(line.rstrip().decode(\"utf-8\"))\n        else:\n            print(\n                \"Imgur API credentials could not be found. Please check https://pypi.org/project/imgur-uploader/ for instructions on how to get Imgur API credentials\"\n            )\n            return\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.vector_area","title":"<code>vector_area(vector, unit='m2', crs='epsg:3857')</code>","text":"<p>Calculate the area of a vector.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>str</code> <p>A local path or HTTP URL to a vector.</p> required <code>unit</code> <code>str</code> <p>The unit of the area, can be 'm2', 'km2', 'ha', or 'acres'. Defaults to 'm2'.</p> <code>'m2'</code> <p>Returns:</p> Type Description <code>float</code> <p>The area of the vector.</p> Source code in <code>beamgis/common.py</code> <pre><code>def vector_area(vector, unit=\"m2\", crs=\"epsg:3857\"):\n    \"\"\"Calculate the area of a vector.\n\n    Args:\n        vector (str): A local path or HTTP URL to a vector.\n        unit (str, optional): The unit of the area, can be 'm2', 'km2', 'ha', or 'acres'. Defaults to 'm2'.\n\n    Returns:\n        float: The area of the vector.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(vector, str):\n        gdf = gpd.read_file(vector)\n    elif isinstance(vector, gpd.GeoDataFrame):\n        gdf = vector\n    else:\n        gdf = None\n        raise ValueError(\"Invalid input vector.\")\n\n    area = gdf.to_crs(crs).area.sum()\n\n    if unit == \"m2\":\n        return area\n    elif unit == \"km2\":\n        return area / 1000000\n    elif unit == \"ha\":\n        return area / 10000\n    elif unit == \"acres\":\n        return area / 4046.8564224\n    else:\n        raise ValueError(\"Invalid unit.\")\n</code></pre>"},{"location":"common/#beamgis.common.vector_col_names","title":"<code>vector_col_names(filename, **kwargs)</code>","text":"<p>Retrieves the column names of a vector attribute table.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The input file path.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The list of column names.</p> Source code in <code>beamgis/common.py</code> <pre><code>def vector_col_names(filename, **kwargs):\n    \"\"\"Retrieves the column names of a vector attribute table.\n\n    Args:\n        filename (str): The input file path.\n\n    Returns:\n        list: The list of column names.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    import geopandas as gpd\n    import fiona\n\n    if not filename.startswith(\"http\"):\n        filename = os.path.abspath(filename)\n    ext = os.path.splitext(filename)[1].lower()\n    if ext == \".kml\":\n        fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n        gdf = gpd.read_file(filename, driver=\"KML\", **kwargs)\n    else:\n        gdf = gpd.read_file(filename, **kwargs)\n    col_names = gdf.columns.values.tolist()\n    return col_names\n</code></pre>"},{"location":"common/#beamgis.common.vector_geom_type","title":"<code>vector_geom_type(data, first_only=True, **kwargs)</code>","text":"<p>Returns the geometry type of a vector dataset.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>first_only</code> <code>bool</code> <p>Whether to return the geometry type of the first feature in the GeoDataFrame. Defaults to True.</p> <code>True</code> <code>kwargs</code> <p>Additional keyword arguments to pass to the geopandas.read_file function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The geometry type of the GeoDataFrame, such as Point, LineString,     Polygon, MultiPoint, MultiLineString, MultiPolygon.     For more info, see https://shapely.readthedocs.io/en/stable/manual.html</p> Source code in <code>beamgis/common.py</code> <pre><code>def vector_geom_type(data, first_only=True, **kwargs):\n    \"\"\"Returns the geometry type of a vector dataset.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        first_only (bool, optional): Whether to return the geometry type of the\n            first feature in the GeoDataFrame. Defaults to True.\n        kwargs: Additional keyword arguments to pass to the geopandas.read_file function.\n\n\n    Returns:\n        str: The geometry type of the GeoDataFrame, such as Point, LineString,\n            Polygon, MultiPoint, MultiLineString, MultiPolygon.\n            For more info, see https://shapely.readthedocs.io/en/stable/manual.html\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str) or isinstance(data, dict):\n        gdf = gpd.read_file(data, **kwargs)\n\n    if first_only:\n        return gdf.geometry.type[0]\n    else:\n        return gdf.geometry.type\n</code></pre>"},{"location":"common/#beamgis.common.vector_set_crs","title":"<code>vector_set_crs(source, output=None, crs='EPSG:4326', **kwargs)</code>","text":"<p>Set CRS of a vector file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | gpd.GeoDataFrame</code> <p>The path to the vector file or a GeoDataFrame.</p> required <code>output</code> <code>str</code> <p>The path to the output vector file. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The CRS to set. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>The GeoDataFrame with the new CRS.</p> Source code in <code>beamgis/common.py</code> <pre><code>def vector_set_crs(source, output=None, crs=\"EPSG:4326\", **kwargs):\n    \"\"\"Set CRS of a vector file.\n\n    Args:\n        source (str | gpd.GeoDataFrame): The path to the vector file or a GeoDataFrame.\n        output (str, optional): The path to the output vector file. Defaults to None.\n        crs (str, optional): The CRS to set. Defaults to \"EPSG:4326\".\n\n\n    Returns:\n        gpd.GeoDataFrame: The GeoDataFrame with the new CRS.\n    \"\"\"\n\n    import geopandas as gpd\n\n    if isinstance(source, str):\n        source = gpd.read_file(source, **kwargs)\n\n    if not isinstance(source, gpd.GeoDataFrame):\n        raise TypeError(\"source must be a GeoDataFrame or a file path\")\n\n    gdf = source.set_crs(crs)\n\n    if output is not None:\n        gdf.to_file(output)\n    else:\n        return gdf\n</code></pre>"},{"location":"common/#beamgis.common.vector_to_geojson","title":"<code>vector_to_geojson(filename, out_geojson=None, bbox=None, mask=None, rows=None, epsg='4326', encoding='utf-8', **kwargs)</code>","text":"<p>Converts any geopandas-supported vector dataset to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).</p> required <code>out_geojson</code> <code>str</code> <p>The file path to the output GeoJSON. Defaults to None.</p> <code>None</code> <code>bbox</code> <code>tuple | GeoDataFrame or GeoSeries | shapely Geometry</code> <p>Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.</p> <code>None</code> <code>mask</code> <code>dict | GeoDataFrame or GeoSeries | shapely Geometry</code> <p>Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.</p> <code>None</code> <code>rows</code> <code>int or slice</code> <p>Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.</p> <code>None</code> <code>epsg</code> <code>str</code> <p>The EPSG number to convert to. Defaults to \"4326\".</p> <code>'4326'</code> <code>encoding</code> <code>str</code> <p>The encoding of the input file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>When the output file path is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the GeoJSON.</p> Source code in <code>beamgis/common.py</code> <pre><code>def vector_to_geojson(\n    filename,\n    out_geojson=None,\n    bbox=None,\n    mask=None,\n    rows=None,\n    epsg=\"4326\",\n    encoding=\"utf-8\",\n    **kwargs,\n):\n    \"\"\"Converts any geopandas-supported vector dataset to GeoJSON.\n\n    Args:\n        filename (str): Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).\n        out_geojson (str, optional): The file path to the output GeoJSON. Defaults to None.\n        bbox (tuple | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.\n        mask (dict | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.\n        rows (int or slice, optional): Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.\n        epsg (str, optional): The EPSG number to convert to. Defaults to \"4326\".\n        encoding (str, optional): The encoding of the input file. Defaults to \"utf-8\".\n\n\n    Raises:\n        ValueError: When the output file path is invalid.\n\n    Returns:\n        dict: A dictionary containing the GeoJSON.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    import geopandas as gpd\n    import fiona\n\n    if not filename.startswith(\"http\"):\n        filename = os.path.abspath(filename)\n        if filename.endswith(\".zip\"):\n            filename = \"zip://\" + filename\n    ext = os.path.splitext(filename)[1].lower()\n    if ext == \".kml\":\n        fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n        df = gpd.read_file(\n            filename,\n            bbox=bbox,\n            mask=mask,\n            rows=rows,\n            driver=\"KML\",\n            encoding=encoding,\n            **kwargs,\n        )\n    else:\n        df = gpd.read_file(\n            filename, bbox=bbox, mask=mask, rows=rows, encoding=encoding, **kwargs\n        )\n    gdf = df.to_crs(epsg=epsg)\n\n    if out_geojson is not None:\n        if not out_geojson.lower().endswith(\".geojson\"):\n            raise ValueError(\"The output file must have a geojson file extension.\")\n\n        out_geojson = os.path.abspath(out_geojson)\n        out_dir = os.path.dirname(out_geojson)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n        gdf.to_file(out_geojson, driver=\"GeoJSON\")\n\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"common/#beamgis.common.vector_to_geojson_batch","title":"<code>vector_to_geojson_batch(input_dir, output_dir=None, file_ext='.shp', **kwargs)</code>","text":"<p>Converts all vector files in a directory to GeoJSON format in batch.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>str</code> <p>The directory containing the input vector files.</p> required <code>output_dir</code> <code>str</code> <p>The directory to save the converted GeoPackage files. If not provided, the input directory will be used. Defaults to None.</p> <code>None</code> <code>file_ext</code> <code>str</code> <p>The file extension of the input vector files (e.g., \".shp\"). Defaults to \".shp\".</p> <code>'.shp'</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the glob.glob function for file matching.</p> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; vector_to_geojson_batch(\"input_directory\", \"output_directory\", \".shp\")\n</code></pre> Source code in <code>beamgis/common.py</code> <pre><code>def vector_to_geojson_batch(input_dir, output_dir=None, file_ext=\".shp\", **kwargs):\n    \"\"\"\n    Converts all vector files in a directory to GeoJSON format in batch.\n\n    Args:\n        input_dir (str): The directory containing the input vector files.\n        output_dir (str, optional): The directory to save the converted GeoPackage files.\n            If not provided, the input directory will be used. Defaults to None.\n        file_ext (str): The file extension of the input vector files (e.g., \".shp\"). Defaults to \".shp\".\n        **kwargs: Additional keyword arguments to be passed to the glob.glob function for file matching.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; vector_to_geojson_batch(\"input_directory\", \"output_directory\", \".shp\")\n    \"\"\"\n    import glob\n    import duckdb\n\n    # Set output directory\n    if output_dir is None:\n        output_dir = input_dir\n\n    # Create output directory if it doesn't exist\n    os.makedirs(output_dir, exist_ok=True)\n\n    # Initialize DuckDB connection\n    conn = duckdb.connect(database=\":memory:\")\n\n    # Install and load required extensions\n    conn.execute(\"INSTALL spatial\")\n    conn.execute(\"LOAD spatial\")\n\n    # Get all GeoJSON files in the input directory\n    files = glob.glob(os.path.join(input_dir, f\"*.{file_ext.lstrip('.')}\"), **kwargs)\n\n    # Process each file\n    for index, file in enumerate(files):\n        # Get base filename without extension\n        base_name = os.path.basename(file)\n        file_name_without_ext = os.path.splitext(base_name)[0]\n\n        # Define output path\n        gpkg_file = os.path.join(output_dir, f\"{file_name_without_ext}.geojson\")\n\n        print(f\"Converting {index + 1}/{len(files)}: {base_name} to GeoJSON...\")\n\n        try:\n            # Execute the conversion\n            conn.execute(\n                f\"\"\"\n                COPY (\n                    SELECT * FROM ST_Read('{file}')\n                ) TO '{gpkg_file}' (FORMAT GDAL, DRIVER 'GeoJSON')\n            \"\"\"\n            )\n        except Exception as e:\n            print(f\"Error converting {base_name}: {str(e)}\")\n\n    # Close connection\n    conn.close()\n    print(\"All conversions complete!\")\n</code></pre>"},{"location":"common/#beamgis.common.vector_to_gif","title":"<code>vector_to_gif(filename, out_gif, colname, vmin=None, vmax=None, step=1, facecolor='black', figsize=(10, 8), padding=3, title=None, add_text=True, xy=('1%', '1%'), fontsize=20, add_progress_bar=True, progress_bar_color='blue', progress_bar_height=5, dpi=300, fps=10, loop=0, mp4=False, keep_png=False, verbose=True, open_args={}, plot_args={})</code>","text":"<p>Convert a vector to a gif. This function was inspired by by Johannes Uhl's shapefile2gif repo at         https://github.com/johannesuhl/shapefile2gif. Credits to Johannes Uhl.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The input vector file. Can be a directory path or http URL, e.g., \"https://i.imgur.com/ZWSZC5z.gif\"</p> required <code>out_gif</code> <code>str</code> <p>The output gif file.</p> required <code>colname</code> <code>str</code> <p>The column name of the vector that contains numerical values.</p> required <code>vmin</code> <code>float</code> <p>The minimum value to filter the data. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to filter the data. Defaults to None.</p> <code>None</code> <code>step</code> <code>float</code> <p>The step to filter the data. Defaults to 1.</p> <code>1</code> <code>facecolor</code> <code>str</code> <p>The color to visualize the data. Defaults to \"black\".</p> <code>'black'</code> <code>figsize</code> <code>tuple</code> <p>The figure size. Defaults to (10, 8).</p> <code>(10, 8)</code> <code>padding</code> <code>int</code> <p>The padding of the figure tight_layout. Defaults to 3.</p> <code>3</code> <code>title</code> <code>str</code> <p>The title of the figure. Defaults to None.</p> <code>None</code> <code>add_text</code> <code>bool</code> <p>Whether to add text to the figure. Defaults to True.</p> <code>True</code> <code>xy</code> <code>tuple</code> <p>The position of the text from the lower-left corner. Defaults to (\"1%\", \"1%\").</p> <code>('1%', '1%')</code> <code>fontsize</code> <code>int</code> <p>The font size of the text. Defaults to 20.</p> <code>20</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar to the figure. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>The color of the progress bar. Defaults to \"blue\".</p> <code>'blue'</code> <code>progress_bar_height</code> <code>int</code> <p>The height of the progress bar. Defaults to 5.</p> <code>5</code> <code>dpi</code> <code>int</code> <p>The dpi of the figure. Defaults to 300.</p> <code>300</code> <code>fps</code> <code>int</code> <p>The frames per second (fps) of the gif. Defaults to 10.</p> <code>10</code> <code>loop</code> <code>int</code> <p>The number of loops of the gif. Defaults to 0, infinite loop.</p> <code>0</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the gif to mp4. Defaults to False.</p> <code>False</code> <code>keep_png</code> <code>bool</code> <p>Whether to keep the png files. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print the progress. Defaults to True.</p> <code>True</code> <code>open_args</code> <code>dict</code> <p>The arguments for the geopandas.read_file() function. Defaults to {}.</p> <code>{}</code> <code>plot_args</code> <code>dict</code> <p>The arguments for the geopandas.GeoDataFrame.plot() function. Defaults to {}.</p> <code>{}</code> Source code in <code>beamgis/common.py</code> <pre><code>def vector_to_gif(\n    filename,\n    out_gif,\n    colname,\n    vmin=None,\n    vmax=None,\n    step=1,\n    facecolor=\"black\",\n    figsize=(10, 8),\n    padding=3,\n    title=None,\n    add_text=True,\n    xy=(\"1%\", \"1%\"),\n    fontsize=20,\n    add_progress_bar=True,\n    progress_bar_color=\"blue\",\n    progress_bar_height=5,\n    dpi=300,\n    fps=10,\n    loop=0,\n    mp4=False,\n    keep_png=False,\n    verbose=True,\n    open_args={},\n    plot_args={},\n):\n    \"\"\"Convert a vector to a gif. This function was inspired by by Johannes Uhl's shapefile2gif repo at\n            https://github.com/johannesuhl/shapefile2gif. Credits to Johannes Uhl.\n\n    Args:\n        filename (str): The input vector file. Can be a directory path or http URL, e.g., \"https://i.imgur.com/ZWSZC5z.gif\"\n        out_gif (str): The output gif file.\n        colname (str): The column name of the vector that contains numerical values.\n        vmin (float, optional): The minimum value to filter the data. Defaults to None.\n        vmax (float, optional): The maximum value to filter the data. Defaults to None.\n        step (float, optional): The step to filter the data. Defaults to 1.\n        facecolor (str, optional): The color to visualize the data. Defaults to \"black\".\n        figsize (tuple, optional): The figure size. Defaults to (10, 8).\n        padding (int, optional): The padding of the figure tight_layout. Defaults to 3.\n        title (str, optional): The title of the figure. Defaults to None.\n        add_text (bool, optional): Whether to add text to the figure. Defaults to True.\n        xy (tuple, optional): The position of the text from the lower-left corner. Defaults to (\"1%\", \"1%\").\n        fontsize (int, optional): The font size of the text. Defaults to 20.\n        add_progress_bar (bool, optional): Whether to add a progress bar to the figure. Defaults to True.\n        progress_bar_color (str, optional): The color of the progress bar. Defaults to \"blue\".\n        progress_bar_height (int, optional): The height of the progress bar. Defaults to 5.\n        dpi (int, optional): The dpi of the figure. Defaults to 300.\n        fps (int, optional): The frames per second (fps) of the gif. Defaults to 10.\n        loop (int, optional): The number of loops of the gif. Defaults to 0, infinite loop.\n        mp4 (bool, optional): Whether to convert the gif to mp4. Defaults to False.\n        keep_png (bool, optional): Whether to keep the png files. Defaults to False.\n        verbose (bool, optional): Whether to print the progress. Defaults to True.\n        open_args (dict, optional): The arguments for the geopandas.read_file() function. Defaults to {}.\n        plot_args (dict, optional): The arguments for the geopandas.GeoDataFrame.plot() function. Defaults to {}.\n\n    \"\"\"\n    import geopandas as gpd\n    import matplotlib.pyplot as plt\n\n    out_dir = os.path.dirname(out_gif)\n    tmp_dir = os.path.join(out_dir, \"tmp_png\")\n    if not os.path.exists(tmp_dir):\n        os.makedirs(tmp_dir)\n\n    if isinstance(filename, str):\n        gdf = gpd.read_file(filename, **open_args)\n    elif isinstance(filename, gpd.GeoDataFrame):\n        gdf = filename\n    else:\n        raise ValueError(\n            \"filename must be a string or a geopandas.GeoDataFrame object.\"\n        )\n\n    bbox = gdf.total_bounds\n\n    if colname not in gdf.columns:\n        raise Exception(\n            f\"{colname} is not in the columns of the GeoDataFrame. It must be one of {gdf.columns}\"\n        )\n\n    values = gdf[colname].unique().tolist()\n    values.sort()\n\n    if vmin is None:\n        vmin = values[0]\n    if vmax is None:\n        vmax = values[-1]\n\n    options = range(vmin, vmax + step, step)\n\n    W = bbox[2] - bbox[0]\n    H = bbox[3] - bbox[1]\n\n    if xy is None:\n        # default text location is 5% width and 5% height of the image.\n        xy = (int(0.05 * W), int(0.05 * H))\n    elif (xy is not None) and (not isinstance(xy, tuple)) and (len(xy) == 2):\n        raise Exception(\"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\")\n\n    elif all(isinstance(item, int) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (x &gt; 0) and (x &lt; W) and (y &gt; 0) and (y &lt; H):\n            pass\n        else:\n            print(\n                f\"xy is out of bounds. x must be within [0, {W}], and y must be within [0, {H}]\"\n            )\n            return\n    elif all(isinstance(item, str) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (\"%\" in x) and (\"%\" in y):\n            try:\n                x = float(x.replace(\"%\", \"\")) / 100.0 * W\n                y = float(y.replace(\"%\", \"\")) / 100.0 * H\n            except Exception:\n                raise Exception(\n                    \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\"\n                )\n    else:\n        raise Exception(\n            \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\"\n        )\n\n    x = bbox[0] + x\n    y = bbox[1] + y\n\n    for index, v in enumerate(options):\n        if verbose:\n            print(f\"Processing {index+1}/{len(options)}: {v}...\")\n        yrdf = gdf[gdf[colname] &lt;= v]\n        fig, ax = plt.subplots()\n        ax = yrdf.plot(facecolor=facecolor, figsize=figsize, **plot_args)\n        ax.set_title(title, fontsize=fontsize)\n        ax.set_axis_off()\n        ax.set_xlim([bbox[0], bbox[2]])\n        ax.set_ylim([bbox[1], bbox[3]])\n        if add_text:\n            ax.text(x, y, v, fontsize=fontsize)\n        fig = ax.get_figure()\n        plt.tight_layout(pad=padding)\n        fig.savefig(tmp_dir + os.sep + \"%s.png\" % v, dpi=dpi)\n        plt.clf()\n        plt.close(\"all\")\n\n    png_to_gif(tmp_dir, out_gif, fps=fps, loop=loop)\n\n    if add_progress_bar:\n        add_progress_bar_to_gif(\n            out_gif,\n            out_gif,\n            progress_bar_color,\n            progress_bar_height,\n            duration=1000 / fps,\n            loop=loop,\n        )\n\n    if mp4:\n        gif_to_mp4(out_gif, out_gif.replace(\".gif\", \".mp4\"))\n\n    if not keep_png:\n        shutil.rmtree(tmp_dir)\n\n    if verbose:\n        print(f\"Done. The GIF is saved to {out_gif}.\")\n</code></pre>"},{"location":"common/#beamgis.common.vector_to_gpkg_batch","title":"<code>vector_to_gpkg_batch(input_dir, output_dir=None, file_ext='.geojson', **kwargs)</code>","text":"<p>Converts all vector files in a directory to GeoPackage format in batch.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>str</code> <p>The directory containing the input vector files.</p> required <code>output_dir</code> <code>str</code> <p>The directory to save the converted GeoPackage files. If not provided, the input directory will be used. Defaults to None.</p> <code>None</code> <code>file_ext</code> <code>str</code> <p>The file extension of the input vector files (e.g., \".geojson\"). Defaults to \".geojson\".</p> <code>'.geojson'</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the glob.glob function for file matching.</p> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; vector_to_gpkg_batch(\"input_directory\", \"output_directory\", \".geojson\")\n</code></pre> Source code in <code>beamgis/common.py</code> <pre><code>def vector_to_gpkg_batch(input_dir, output_dir=None, file_ext=\".geojson\", **kwargs):\n    \"\"\"\n    Converts all vector files in a directory to GeoPackage format in batch.\n\n    Args:\n        input_dir (str): The directory containing the input vector files.\n        output_dir (str, optional): The directory to save the converted GeoPackage files.\n            If not provided, the input directory will be used. Defaults to None.\n        file_ext (str): The file extension of the input vector files (e.g., \".geojson\"). Defaults to \".geojson\".\n        **kwargs: Additional keyword arguments to be passed to the glob.glob function for file matching.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; vector_to_gpkg_batch(\"input_directory\", \"output_directory\", \".geojson\")\n    \"\"\"\n    import glob\n    import duckdb\n\n    # Set output directory\n    if output_dir is None:\n        output_dir = input_dir\n\n    # Create output directory if it doesn't exist\n    os.makedirs(output_dir, exist_ok=True)\n\n    # Initialize DuckDB connection\n    conn = duckdb.connect(database=\":memory:\")\n\n    # Install and load required extensions\n    conn.execute(\"INSTALL spatial\")\n    conn.execute(\"LOAD spatial\")\n\n    # Get all GeoJSON files in the input directory\n    files = glob.glob(os.path.join(input_dir, f\"*.{file_ext.lstrip('.')}\"), **kwargs)\n\n    # Process each file\n    for index, file in enumerate(files):\n        # Get base filename without extension\n        base_name = os.path.basename(file)\n        file_name_without_ext = os.path.splitext(base_name)[0]\n\n        # Define output path\n        gpkg_file = os.path.join(output_dir, f\"{file_name_without_ext}.gpkg\")\n\n        print(f\"Converting {index + 1}/{len(files)}: {base_name} to GeoPackage...\")\n\n        try:\n            # Execute the conversion\n            conn.execute(\n                f\"\"\"\n                COPY (\n                    SELECT * FROM ST_Read('{file}')\n                ) TO '{gpkg_file}' (FORMAT GDAL, DRIVER 'GPKG')\n            \"\"\"\n            )\n        except Exception as e:\n            print(f\"Error converting {base_name}: {str(e)}\")\n\n    # Close connection\n    conn.close()\n    print(\"All conversions complete!\")\n</code></pre>"},{"location":"common/#beamgis.common.vector_to_mbtiles","title":"<code>vector_to_mbtiles(source_path, target_path, max_zoom=5, name=None, **kwargs)</code>","text":"<p>Convert a vector dataset to MBTiles format using the ogr2ogr command-line tool.</p> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>str</code> <p>The path to the source vector dataset (GeoPackage, Shapefile, etc.).</p> required <code>target_path</code> <code>str</code> <p>The path to the target MBTiles file to be created.</p> required <code>max_zoom</code> <code>int</code> <p>The maximum zoom level for the MBTiles dataset. Defaults to 5.</p> <code>5</code> <code>name</code> <code>str</code> <p>The name of the MBTiles dataset. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional options to be passed as keyword arguments. These options will be used as -dsco options       when calling ogr2ogr. See https://gdal.org/drivers/raster/mbtiles.html for a list of options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Exceptions:</p> Type Description <code>subprocess.CalledProcessError</code> <p>If the ogr2ogr command fails to execute.</p> <p>Examples:</p> <p>source_path = \"countries.gpkg\" target_path = \"target.mbtiles\" name = \"My MBTiles\" max_zoom = 5 vector_to_mbtiles(source_path, target_path, name=name, max_zoom=max_zoom)</p> Source code in <code>beamgis/common.py</code> <pre><code>def vector_to_mbtiles(\n    source_path: str, target_path: str, max_zoom: int = 5, name: str = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Convert a vector dataset to MBTiles format using the ogr2ogr command-line tool.\n\n    Args:\n        source_path (str): The path to the source vector dataset (GeoPackage, Shapefile, etc.).\n        target_path (str): The path to the target MBTiles file to be created.\n        max_zoom (int, optional): The maximum zoom level for the MBTiles dataset. Defaults to 5.\n        name (str, optional): The name of the MBTiles dataset. Defaults to None.\n        **kwargs: Additional options to be passed as keyword arguments. These options will be used as -dsco options\n                  when calling ogr2ogr. See https://gdal.org/drivers/raster/mbtiles.html for a list of options.\n\n    Returns:\n        None\n\n    Raises:\n        subprocess.CalledProcessError: If the ogr2ogr command fails to execute.\n\n    Example:\n        source_path = \"countries.gpkg\"\n        target_path = \"target.mbtiles\"\n        name = \"My MBTiles\"\n        max_zoom = 5\n        vector_to_mbtiles(source_path, target_path, name=name, max_zoom=max_zoom)\n    \"\"\"\n    import subprocess\n\n    command = [\n        \"ogr2ogr\",\n        \"-f\",\n        \"MBTILES\",\n        target_path,\n        source_path,\n        \"-dsco\",\n        f\"MAXZOOM={max_zoom}\",\n    ]\n\n    if name:\n        command.extend([\"-dsco\", f\"NAME={name}\"])\n\n    for key, value in kwargs.items():\n        command.extend([\"-dsco\", f\"{key.upper()}={value}\"])\n\n    try:\n        subprocess.run(command, check=True)\n    except subprocess.CalledProcessError as e:\n        raise e\n</code></pre>"},{"location":"common/#beamgis.common.vector_to_parquet","title":"<code>vector_to_parquet(source, output, crs=None, overwrite=False, **kwargs)</code>","text":"<p>Convert a GeoDataFrame or a file containing vector data to Parquet format.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[gpd.GeoDataFrame, str]</code> <p>The source data to convert. It can be either a GeoDataFrame or a file path to the vector data file.</p> required <code>output</code> <code>str</code> <p>The file path where the Parquet file will be saved.</p> required <code>crs</code> <code>str</code> <p>The coordinate reference system (CRS) to use for the output file. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the existing output file. Default is False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the <code>to_parquet</code> function of GeoDataFrame.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>beamgis/common.py</code> <pre><code>def vector_to_parquet(\n    source: str, output: str, crs=None, overwrite=False, **kwargs\n) -&gt; None:\n    \"\"\"\n    Convert a GeoDataFrame or a file containing vector data to Parquet format.\n\n    Args:\n        source (Union[gpd.GeoDataFrame, str]): The source data to convert. It can be either a GeoDataFrame\n            or a file path to the vector data file.\n        output (str): The file path where the Parquet file will be saved.\n        crs (str, optional): The coordinate reference system (CRS) to use for the output file. Defaults to None.\n        overwrite (bool): Whether to overwrite the existing output file. Default is False.\n        **kwargs: Additional keyword arguments to be passed to the `to_parquet` function of GeoDataFrame.\n\n    Returns:\n        None\n    \"\"\"\n\n    import geopandas as gpd\n\n    if os.path.exists(output) and not overwrite:\n        print(f\"File {output} already exists. Skipping...\")\n        return\n\n    if isinstance(source, gpd.GeoDataFrame):\n        gdf = source\n    else:\n        gdf = gpd.read_file(source)\n\n    if crs is not None:\n        gdf = gdf.to_crs(crs)\n\n    out_dir = os.path.dirname(os.path.abspath(output))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    gdf.to_parquet(output, **kwargs)\n</code></pre>"},{"location":"common/#beamgis.common.vector_to_parquet_batch","title":"<code>vector_to_parquet_batch(input_dir, output_dir=None, file_ext='.geojson', **kwargs)</code>","text":"<p>Converts all vector files in a directory to Parquet format in batch.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>str</code> <p>The directory containing the input vector files.</p> required <code>output_dir</code> <code>str</code> <p>The directory to save the converted Parquet files. If not provided, the input directory will be used. Defaults to None.</p> <code>None</code> <code>file_ext</code> <code>str</code> <p>The file extension of the input vector files (e.g., \".geojson\"). Defaults to \".geojson\".</p> <code>'.geojson'</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the glob.glob function for file matching.</p> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; vector_to_parquet_batch(\"input_directory\", \"output_directory\", \".geojson\")\n</code></pre> Source code in <code>beamgis/common.py</code> <pre><code>def vector_to_parquet_batch(input_dir, output_dir=None, file_ext=\".geojson\", **kwargs):\n    \"\"\"\n    Converts all vector files in a directory to Parquet format in batch.\n\n    Args:\n        input_dir (str): The directory containing the input vector files.\n        output_dir (str, optional): The directory to save the converted Parquet files.\n            If not provided, the input directory will be used. Defaults to None.\n        file_ext (str): The file extension of the input vector files (e.g., \".geojson\"). Defaults to \".geojson\".\n        **kwargs: Additional keyword arguments to be passed to the glob.glob function for file matching.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; vector_to_parquet_batch(\"input_directory\", \"output_directory\", \".geojson\")\n    \"\"\"\n    import glob\n    import duckdb\n\n    # Set output directory\n    if output_dir is None:\n        output_dir = input_dir\n\n    # Create output directory if it doesn't exist\n    os.makedirs(output_dir, exist_ok=True)\n\n    # Initialize DuckDB connection\n    conn = duckdb.connect(database=\":memory:\")\n\n    # Install and load required extensions\n    conn.execute(\"INSTALL spatial\")\n    conn.execute(\"LOAD spatial\")\n\n    # Get all GeoJSON files in the input directory\n    files = glob.glob(os.path.join(input_dir, f\"*.{file_ext.lstrip('.')}\"), **kwargs)\n\n    # Process each file\n    for index, file in enumerate(files):\n        # Get base filename without extension\n        base_name = os.path.basename(file)\n        file_name_without_ext = os.path.splitext(base_name)[0]\n\n        # Define output path\n        parquet_file = os.path.join(output_dir, f\"{file_name_without_ext}.parquet\")\n\n        print(f\"Converting {index + 1}/{len(files)}: {base_name} to Parquet...\")\n\n        try:\n            # Execute the conversion\n            conn.execute(\n                f\"\"\"\n                COPY (\n                    SELECT * FROM ST_Read('{file}')\n                ) TO '{parquet_file}' (FORMAT PARQUET)\n            \"\"\"\n            )\n        except Exception as e:\n            print(f\"Error converting {base_name}: {str(e)}\")\n\n    # Close connection\n    conn.close()\n    print(\"All conversions complete!\")\n</code></pre>"},{"location":"common/#beamgis.common.vector_to_pmtiles","title":"<code>vector_to_pmtiles(source_path, target_path, max_zoom=5, name=None, **kwargs)</code>","text":"<p>Converts a vector file to PMTiles format.</p> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>str</code> <p>Path to the source vector file.</p> required <code>target_path</code> <code>str</code> <p>Path to the target PMTiles file.</p> required <code>max_zoom</code> <code>int</code> <p>Maximum zoom level for the PMTiles. Defaults to 5.</p> <code>5</code> <code>name</code> <code>str</code> <p>Name of the PMTiles dataset. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the underlying conversion functions.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the target file does not have a .pmtiles extension.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>beamgis/common.py</code> <pre><code>def vector_to_pmtiles(\n    source_path: str, target_path: str, max_zoom: int = 5, name: str = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Converts a vector file to PMTiles format.\n\n    Args:\n        source_path (str): Path to the source vector file.\n        target_path (str): Path to the target PMTiles file.\n        max_zoom (int, optional): Maximum zoom level for the PMTiles. Defaults to 5.\n        name (str, optional): Name of the PMTiles dataset. Defaults to None.\n        **kwargs: Additional keyword arguments to be passed to the underlying conversion functions.\n\n    Raises:\n        ValueError: If the target file does not have a .pmtiles extension.\n\n    Returns:\n        None\n    \"\"\"\n    if not target_path.endswith(\".pmtiles\"):\n        raise ValueError(\"Error: target file must be a .pmtiles file.\")\n    mbtiles = target_path.replace(\".pmtiles\", \".mbtiles\")\n    vector_to_mbtiles(source_path, mbtiles, max_zoom=max_zoom, name=name, **kwargs)\n    mbtiles_to_pmtiles(mbtiles, target_path)\n    os.remove(mbtiles)\n</code></pre>"},{"location":"common/#beamgis.common.vector_to_raster","title":"<code>vector_to_raster(vector, output, field='FID', assign='last', nodata=True, cell_size=None, base=None, callback=None, verbose=False, to_epsg=None)</code>","text":"<p>Convert a vector to a raster.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>str | GeoPandas.GeoDataFrame</code> <p>The input vector data, can be a file path or a GeoDataFrame.</p> required <code>output</code> <code>str</code> <p>The output raster file path.</p> required <code>field</code> <code>str</code> <p>Input field name in attribute table. Defaults to 'FID'.</p> <code>'FID'</code> <code>assign</code> <code>str</code> <p>Assignment operation, where multiple points are in the same grid cell; options include 'first', 'last' (default), 'min', 'max', 'sum', 'number'. Defaults to 'last'.</p> <code>'last'</code> <code>nodata</code> <code>bool</code> <p>Background value to set to NoData. Without this flag, it will be set to 0.0.</p> <code>True</code> <code>cell_size</code> <code>float</code> <p>Optionally specified cell size of output raster. Not used when base raster is specified</p> <code>None</code> <code>base</code> <code>str</code> <p>Optionally specified input base raster file. Not used when a cell size is specified. Defaults to None.</p> <code>None</code> <code>callback</code> <code>fuct</code> <p>A callback function to report progress. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print progress to the console. Defaults to False.</p> <code>False</code> <code>to_epsg</code> <code>integer</code> <p>Optionally specified the EPSG code to reproject the raster to. Defaults to None.</p> <code>None</code> Source code in <code>beamgis/common.py</code> <pre><code>def vector_to_raster(\n    vector,\n    output,\n    field=\"FID\",\n    assign=\"last\",\n    nodata=True,\n    cell_size=None,\n    base=None,\n    callback=None,\n    verbose=False,\n    to_epsg=None,\n):\n    \"\"\"Convert a vector to a raster.\n\n    Args:\n        vector (str | GeoPandas.GeoDataFrame): The input vector data, can be a file path or a GeoDataFrame.\n        output (str): The output raster file path.\n        field (str, optional): Input field name in attribute table. Defaults to 'FID'.\n        assign (str, optional): Assignment operation, where multiple points are in the same grid cell; options\n            include 'first', 'last' (default), 'min', 'max', 'sum', 'number'. Defaults to 'last'.\n        nodata (bool, optional): Background value to set to NoData. Without this flag, it will be set to 0.0.\n        cell_size (float, optional): Optionally specified cell size of output raster. Not used when base raster is specified\n        base (str, optional): Optionally specified input base raster file. Not used when a cell size is specified. Defaults to None.\n        callback (fuct, optional): A callback function to report progress. Defaults to None.\n        verbose (bool, optional): Whether to print progress to the console. Defaults to False.\n        to_epsg (integer, optional): Optionally specified the EPSG code to reproject the raster to. Defaults to None.\n\n    \"\"\"\n    import geopandas as gpd\n    import whitebox\n\n    output = os.path.abspath(output)\n\n    if isinstance(vector, str):\n        gdf = gpd.read_file(vector)\n    elif isinstance(vector, gpd.GeoDataFrame):\n        gdf = vector\n    else:\n        raise TypeError(\"vector must be a file path or a GeoDataFrame\")\n\n    if to_epsg is None:\n        to_epsg = 3857\n\n    if to_epsg == 4326:\n        raise ValueError(\"to_epsg cannot be 4326\")\n\n    if gdf.crs.is_geographic:\n        gdf = gdf.to_crs(epsg=to_epsg)\n        vector = temp_file_path(extension=\".shp\")\n        gdf.to_file(vector)\n    else:\n        to_epsg = gdf.crs.to_epsg()\n\n    wbt = whitebox.WhiteboxTools()\n    wbt.verbose = verbose\n\n    goem_type = gdf.geom_type[0]\n\n    if goem_type == \"LineString\":\n        wbt.vector_lines_to_raster(\n            vector, output, field, nodata, cell_size, base, callback\n        )\n    elif goem_type == \"Polygon\":\n        wbt.vector_polygons_to_raster(\n            vector, output, field, nodata, cell_size, base, callback\n        )\n    else:\n        wbt.vector_points_to_raster(\n            vector, output, field, assign, nodata, cell_size, base, callback\n        )\n\n    image_set_crs(output, to_epsg)\n</code></pre>"},{"location":"common/#beamgis.common.view_lidar","title":"<code>view_lidar(filename, cmap='terrain', backend='pyvista', background=None, eye_dome_lighting=False, **kwargs)</code>","text":"<p>View LiDAR data in 3D.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filepath to the LiDAR data.</p> required <code>cmap</code> <code>str</code> <p>The colormap to use. Defaults to \"terrain\". cmap currently does not work for the open3d backend.</p> <code>'terrain'</code> <code>backend</code> <code>str</code> <p>The plotting backend to use, can be pyvista, ipygany, panel, and open3d. Defaults to \"pyvista\".</p> <code>'pyvista'</code> <code>background</code> <code>str</code> <p>The background color to use. Defaults to None.</p> <code>None</code> <code>eye_dome_lighting</code> <code>bool</code> <p>Whether to use eye dome lighting. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>ValueError</code> <p>If the backend is not supported.</p> Source code in <code>beamgis/common.py</code> <pre><code>def view_lidar(\n    filename,\n    cmap=\"terrain\",\n    backend=\"pyvista\",\n    background=None,\n    eye_dome_lighting=False,\n    **kwargs,\n):\n    \"\"\"View LiDAR data in 3D.\n\n    Args:\n        filename (str): The filepath to the LiDAR data.\n        cmap (str, optional): The colormap to use. Defaults to \"terrain\". cmap currently does not work for the open3d backend.\n        backend (str, optional): The plotting backend to use, can be pyvista, ipygany, panel, and open3d. Defaults to \"pyvista\".\n        background (str, optional): The background color to use. Defaults to None.\n        eye_dome_lighting (bool, optional): Whether to use eye dome lighting. Defaults to False.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n        ValueError: If the backend is not supported.\n    \"\"\"\n\n    import sys\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    if \"google.colab\" in sys.modules:\n        print(\"This function is not supported in Google Colab.\")\n        return\n\n    warnings.filterwarnings(\"ignore\")\n    filename = os.path.abspath(filename)\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"{filename} does not exist.\")\n\n    backend = backend.lower()\n    if backend in [\"pyvista\", \"ipygany\", \"panel\"]:\n        try:\n            import pyntcloud\n        except ImportError:\n            print(\n                \"The pyvista and pyntcloud packages are required for this function. Use pip install leafmap[lidar] to install them.\"\n            )\n            return\n\n        try:\n            if backend == \"pyvista\":\n                backend = None\n            if backend == \"ipygany\":\n                cmap = None\n            data = pyntcloud.PyntCloud.from_file(filename)\n            mesh = data.to_instance(\"pyvista\", mesh=False)\n            mesh = mesh.elevation()\n            mesh.plot(\n                scalars=\"Elevation\",\n                cmap=cmap,\n                jupyter_backend=backend,\n                background=background,\n                eye_dome_lighting=eye_dome_lighting,\n                **kwargs,\n            )\n\n        except Exception as e:\n            print(\"Something went wrong.\")\n            print(e)\n            return\n\n    elif backend == \"open3d\":\n        try:\n            import laspy\n            import open3d as o3d\n            import numpy as np\n        except ImportError:\n            print(\n                \"The laspy and open3d packages are required for this function. Use pip install laspy open3d to install them.\"\n            )\n            return\n\n        try:\n            las = laspy.read(filename)\n            point_data = np.stack([las.X, las.Y, las.Z], axis=0).transpose((1, 0))\n            geom = o3d.geometry.PointCloud()\n            geom.points = o3d.utility.Vector3dVector(point_data)\n            # geom.colors =  o3d.utility.Vector3dVector(colors)  # need to add colors. A list in the form of [[r,g,b], [r,g,b]] with value range 0-1. https://github.com/isl-org/Open3D/issues/614\n            o3d.visualization.draw_geometries([geom], **kwargs)\n\n        except Exception as e:\n            print(\"Something went wrong.\")\n            print(e)\n            return\n\n    else:\n        raise ValueError(f\"{backend} is not a valid backend.\")\n</code></pre>"},{"location":"common/#beamgis.common.whiteboxgui","title":"<code>whiteboxgui(verbose=True, tree=False, reset=False, sandbox_path=None)</code>","text":"<p>Shows the WhiteboxTools GUI.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Whether to show progress info when the tool is running. Defaults to True.</p> <code>True</code> <code>tree</code> <code>bool</code> <p>Whether to use the tree mode toolbox built using ipytree rather than ipywidgets. Defaults to False.</p> <code>False</code> <code>reset</code> <code>bool</code> <p>Whether to regenerate the json file with the dictionary containing the information for all tools. Defaults to False.</p> <code>False</code> <code>sandbox_path</code> <code>str</code> <p>The path to the sandbox folder. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>A toolbox GUI.</p> Source code in <code>beamgis/common.py</code> <pre><code>def whiteboxgui(\n    verbose: Optional[bool] = True,\n    tree: Optional[bool] = False,\n    reset: Optional[bool] = False,\n    sandbox_path: Optional[str] = None,\n) -&gt; dict:\n    \"\"\"Shows the WhiteboxTools GUI.\n\n    Args:\n        verbose (bool, optional): Whether to show progress info when the tool is running. Defaults to True.\n        tree (bool, optional): Whether to use the tree mode toolbox built using ipytree rather than ipywidgets. Defaults to False.\n        reset (bool, optional): Whether to regenerate the json file with the dictionary containing the information for all tools. Defaults to False.\n        sandbox_path (str, optional): The path to the sandbox folder. Defaults to None.\n\n    Returns:\n        object: A toolbox GUI.\n    \"\"\"\n    import whiteboxgui\n\n    return whiteboxgui.show(verbose, tree, reset, sandbox_path)\n</code></pre>"},{"location":"common/#beamgis.common.widget_template","title":"<code>widget_template(widget=None, opened=True, show_close_button=True, widget_icon='gear', close_button_icon='times', widget_args={}, close_button_args={}, display_widget=None, m=None, position='topright')</code>","text":"<p>Create a widget template.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>ipywidgets.Widget</code> <p>The widget to be displayed. Defaults to None.</p> <code>None</code> <code>opened</code> <code>bool</code> <p>Whether to open the toolbar. Defaults to True.</p> <code>True</code> <code>show_close_button</code> <code>bool</code> <p>Whether to show the close button. Defaults to True.</p> <code>True</code> <code>widget_icon</code> <code>str</code> <p>The icon name for the toolbar button. Defaults to 'gear'.</p> <code>'gear'</code> <code>close_button_icon</code> <code>str</code> <p>The icon name for the close button. Defaults to \"times\".</p> <code>'times'</code> <code>widget_args</code> <code>dict</code> <p>Additional arguments to pass to the toolbar button. Defaults to {}.</p> <code>{}</code> <code>close_button_args</code> <code>dict</code> <p>Additional arguments to pass to the close button. Defaults to {}.</p> <code>{}</code> <code>display_widget</code> <code>ipywidgets.Widget</code> <p>The widget to be displayed when the toolbar is clicked.</p> <code>None</code> <code>m</code> <code>geemap.Map</code> <p>The geemap.Map instance. Defaults to None.</p> <code>None</code> <code>position</code> <code>str</code> <p>The position of the toolbar. Defaults to \"topright\".</p> <code>'topright'</code> Source code in <code>beamgis/common.py</code> <pre><code>def widget_template(\n    widget=None,\n    opened=True,\n    show_close_button=True,\n    widget_icon=\"gear\",\n    close_button_icon=\"times\",\n    widget_args={},\n    close_button_args={},\n    display_widget=None,\n    m=None,\n    position=\"topright\",\n):\n    \"\"\"Create a widget template.\n\n    Args:\n        widget (ipywidgets.Widget, optional): The widget to be displayed. Defaults to None.\n        opened (bool, optional): Whether to open the toolbar. Defaults to True.\n        show_close_button (bool, optional): Whether to show the close button. Defaults to True.\n        widget_icon (str, optional): The icon name for the toolbar button. Defaults to 'gear'.\n        close_button_icon (str, optional): The icon name for the close button. Defaults to \"times\".\n        widget_args (dict, optional): Additional arguments to pass to the toolbar button. Defaults to {}.\n        close_button_args (dict, optional): Additional arguments to pass to the close button. Defaults to {}.\n        display_widget (ipywidgets.Widget, optional): The widget to be displayed when the toolbar is clicked.\n        m (geemap.Map, optional): The geemap.Map instance. Defaults to None.\n        position (str, optional): The position of the toolbar. Defaults to \"topright\".\n    \"\"\"\n\n    name = \"_\" + random_string()  # a random attribute name\n\n    if \"value\" not in widget_args:\n        widget_args[\"value\"] = False\n    if \"tooltip\" not in widget_args:\n        widget_args[\"tooltip\"] = \"Toolbar\"\n    if \"layout\" not in widget_args:\n        widget_args[\"layout\"] = widgets.Layout(\n            width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"\n        )\n    widget_args[\"icon\"] = widget_icon\n\n    if \"value\" not in close_button_args:\n        close_button_args[\"value\"] = False\n    if \"tooltip\" not in close_button_args:\n        close_button_args[\"tooltip\"] = \"Close the tool\"\n    if \"button_style\" not in close_button_args:\n        close_button_args[\"button_style\"] = \"primary\"\n    if \"layout\" not in close_button_args:\n        close_button_args[\"layout\"] = widgets.Layout(\n            height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"\n        )\n    close_button_args[\"icon\"] = close_button_icon\n\n    toolbar_button = widgets.ToggleButton(**widget_args)\n\n    close_button = widgets.ToggleButton(**close_button_args)\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    if show_close_button:\n        toolbar_header.children = [close_button, toolbar_button]\n    else:\n        toolbar_header.children = [toolbar_button]\n    toolbar_footer = widgets.VBox()\n\n    if widget is not None:\n        toolbar_footer.children = [\n            widget,\n        ]\n    else:\n        toolbar_footer.children = []\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n            if display_widget is not None:\n                widget.outputs = ()\n                with widget:\n                    display(display_widget)\n        else:\n            toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                control = getattr(m, name)\n                if control is not None and control in m.controls:\n                    m.remove_control(control)\n                    delattr(m, name)\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    toolbar_button.value = opened\n    if m is not None:\n        import ipyleaflet\n\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=position\n        )\n\n        if toolbar_control not in m.controls:\n            m.add_control(toolbar_control)\n\n            setattr(m, name, toolbar_control)\n\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"common/#beamgis.common.write_image_colormap","title":"<code>write_image_colormap(image, colormap, output_path=None)</code>","text":"<p>Apply or update a colormap to a raster image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str, rasterio.io.DatasetReader, rioxarray.DataArray</code> <p>The input image. It can be: - A file path to a raster image (string). - A rasterio dataset. - A rioxarray DataArray.</p> required <code>colormap</code> <code>dict</code> <p>A dictionary defining the colormap (value: (R, G, B, A)).</p> required <code>output_path</code> <code>str</code> <p>Path to save the updated raster image. If None, the original file is updated in-memory.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the updated raster image.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the input image type is unsupported.</p> Source code in <code>beamgis/common.py</code> <pre><code>def write_image_colormap(image, colormap, output_path=None):\n    \"\"\"\n    Apply or update a colormap to a raster image.\n\n    Args:\n        image (str, rasterio.io.DatasetReader, rioxarray.DataArray):\n            The input image. It can be:\n            - A file path to a raster image (string).\n            - A rasterio dataset.\n            - A rioxarray DataArray.\n        colormap (dict): A dictionary defining the colormap (value: (R, G, B, A)).\n        output_path (str, optional): Path to save the updated raster image.\n            If None, the original file is updated in-memory.\n\n    Returns:\n        str: Path to the updated raster image.\n\n    Raises:\n        ValueError: If the input image type is unsupported.\n    \"\"\"\n    import rasterio\n    import rioxarray\n    import xarray as xr\n\n    dataset = None\n    src_profile = None\n    src_data = None\n\n    if isinstance(image, str):  # File path\n        with rasterio.open(image) as ds:\n            dataset = ds\n            src_profile = ds.profile\n            src_data = ds.read(1)  # Assuming single-band\n    elif isinstance(image, rasterio.io.DatasetReader):  # rasterio dataset\n        dataset = image\n        src_profile = dataset.profile\n        src_data = dataset.read(1)  # Assuming single-band\n    elif isinstance(image, xr.DataArray):  # rioxarray DataArray\n        source = image.encoding.get(\"source\")\n        if source:\n            with rasterio.open(source) as ds:\n                dataset = ds\n                src_profile = ds.profile\n                src_data = ds.read(1)  # Assuming single-band\n        else:\n            raise ValueError(\"Cannot apply colormap: DataArray does not have a source.\")\n    else:\n        raise ValueError(\n            \"Unsupported input type. Provide a file path, rasterio dataset, or rioxarray DataArray.\"\n        )\n\n    # Ensure the dataset is single-band\n    if dataset.count != 1:\n        raise ValueError(\n            \"Colormaps can only be applied to single-band raster datasets.\"\n        )\n\n    # Update the profile and colormap\n    src_profile.update(dtype=src_data.dtype, count=1)\n\n    if not output_path:\n        output_path = \"output_with_colormap.tif\"\n\n    # Write the updated dataset with the colormap\n    with rasterio.open(output_path, \"w\", **src_profile) as dst:\n        dst.write(src_data, 1)\n        dst.write_colormap(1, colormap)\n\n    return output_path\n</code></pre>"},{"location":"common/#beamgis.common.write_lidar","title":"<code>write_lidar(source, destination, do_compress=None, laz_backend=None)</code>","text":"<p>Writes to a stream or file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | laspy.lasdatas.base.LasBase</code> <p>The source data to be written.</p> required <code>destination</code> <code>str</code> <p>The destination filepath.</p> required <code>do_compress</code> <code>bool</code> <p>Flags to indicate if you want to compress the data. Defaults to None.</p> <code>None</code> <code>laz_backend</code> <code>str</code> <p>The laz backend to use. Defaults to None.</p> <code>None</code> Source code in <code>beamgis/common.py</code> <pre><code>def write_lidar(source, destination, do_compress=None, laz_backend=None):\n    \"\"\"Writes to a stream or file.\n\n    Args:\n        source (str | laspy.lasdatas.base.LasBase): The source data to be written.\n        destination (str): The destination filepath.\n        do_compress (bool, optional): Flags to indicate if you want to compress the data. Defaults to None.\n        laz_backend (str, optional): The laz backend to use. Defaults to None.\n    \"\"\"\n\n    try:\n        import laspy\n    except ImportError:\n        print(\n            \"The laspy package is required for this function. Use `pip install laspy[lazrs,laszip]` to install it.\"\n        )\n        return\n\n    if isinstance(source, str):\n        source = read_lidar(source)\n\n    source.write(destination, do_compress=do_compress, laz_backend=laz_backend)\n</code></pre>"},{"location":"common/#beamgis.common.xarray_to_raster","title":"<code>xarray_to_raster(dataset, filename, **kwargs)</code>","text":"<p>Convert an xarray Dataset to a raster file.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>xr.Dataset</code> <p>The input xarray Dataset to be converted.</p> required <code>filename</code> <code>str</code> <p>The output filename for the raster file.</p> required <code>**kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments passed to the <code>rio.to_raster()</code> method. See https://corteva.github.io/rioxarray/stable/examples/convert_to_raster.html for more info.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>beamgis/common.py</code> <pre><code>def xarray_to_raster(dataset, filename: str, **kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"Convert an xarray Dataset to a raster file.\n\n    Args:\n        dataset (xr.Dataset): The input xarray Dataset to be converted.\n        filename (str): The output filename for the raster file.\n        **kwargs (Dict[str, Any]): Additional keyword arguments passed to the `rio.to_raster()` method.\n            See https://corteva.github.io/rioxarray/stable/examples/convert_to_raster.html for more info.\n\n    Returns:\n        None\n    \"\"\"\n    import rioxarray\n\n    dims = list(dataset.dims)\n\n    new_names = {}\n\n    if \"lat\" in dims:\n        new_names[\"lat\"] = \"y\"\n        dims.remove(\"lat\")\n    if \"lon\" in dims:\n        new_names[\"lon\"] = \"x\"\n        dims.remove(\"lon\")\n    if \"lng\" in dims:\n        new_names[\"lng\"] = \"x\"\n        dims.remove(\"lng\")\n    if \"latitude\" in dims:\n        new_names[\"latitude\"] = \"y\"\n        dims.remove(\"latitude\")\n    if \"longitude\" in dims:\n        new_names[\"longitude\"] = \"x\"\n        dims.remove(\"longitude\")\n\n    dataset = dataset.rename(new_names)\n    dataset.transpose(..., \"y\", \"x\").rio.to_raster(filename, **kwargs)\n</code></pre>"},{"location":"common/#beamgis.common.xy_to_window","title":"<code>xy_to_window(xy)</code>","text":"<p>Converts a list of coordinates to a rasterio window.</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>list</code> <p>A list of coordinates in the format of [[x1, y1], [x2, y2]]</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>The rasterio window in the format of (col_off, row_off, width, height)</p> Source code in <code>beamgis/common.py</code> <pre><code>def xy_to_window(xy):\n    \"\"\"Converts a list of coordinates to a rasterio window.\n\n    Args:\n        xy (list): A list of coordinates in the format of [[x1, y1], [x2, y2]]\n\n    Returns:\n        tuple: The rasterio window in the format of (col_off, row_off, width, height)\n    \"\"\"\n\n    x1, y1 = xy[0]\n    x2, y2 = xy[1]\n\n    left = min(x1, x2)\n    right = max(x1, x2)\n    top = min(y1, y2)\n    bottom = max(y1, y2)\n\n    width = right - left\n    height = bottom - top\n\n    return (left, top, width, height)\n</code></pre>"},{"location":"common/#beamgis.common.zonal_stats","title":"<code>zonal_stats(vectors, raster, layer=0, band_num=1, nodata=None, affine=None, stats=None, all_touched=False, categorical=False, category_map=None, add_stats=None, raster_out=False, prefix=None, geojson_out=False, gdf_out=False, dst_crs=None, open_vector_args={}, open_raster_args={}, **kwargs)</code>","text":"<p>This function wraps rasterstats.zonal_stats and performs reprojection if necessary.     See https://pythonhosted.org/rasterstats/rasterstats.html.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>str | list | GeoDataFrame</code> <p>path to an vector source or geo-like python objects.</p> required <code>raster</code> <code>str | ndarray</code> <p>ndarray or path to a GDAL raster source.</p> required <code>layer</code> <code>int</code> <p>If vectors is a path to an fiona source, specify the vector layer to use either by name or number. Defaults to 0</p> <code>0</code> <code>band_num</code> <code>int | str</code> <p>If raster is a GDAL source, the band number to use (counting from 1). defaults to 1.</p> <code>1</code> <code>nodata</code> <code>float</code> <p>If raster is a GDAL source, this value overrides any NODATA value specified in the file\u2019s metadata. If None, the file\u2019s metadata\u2019s NODATA value (if any) will be used. defaults to None.</p> <code>None</code> <code>affine</code> <code>Affine</code> <p>required only for ndarrays, otherwise it is read from src. Defaults to None.</p> <code>None</code> <code>stats</code> <code>str | list</code> <p>Which statistics to calculate for each zone. It can be ['min', 'max', 'mean', 'count']. For more, see https://pythonhosted.org/rasterstats/manual.html#zonal-statistics Defaults to None.</p> <code>None</code> <code>all_touched</code> <code>bool</code> <p>Whether to include every raster cell touched by a geometry, or only those having a center point within the polygon. defaults to False</p> <code>False</code> <code>categorical</code> <code>bool</code> <p>If True, the raster values will be treated as categorical.</p> <code>False</code> <code>category_map</code> <code>dict</code> <p>A dictionary mapping raster values to human-readable categorical names. Only applies when categorical is True</p> <code>None</code> <code>add_stats</code> <code>dict</code> <p>with names and functions of additional stats to compute. Defaults to None.</p> <code>None</code> <code>raster_out</code> <code>bool</code> <p>Include the masked numpy array for each feature?. Defaults to False.</p> <code>False</code> <code>prefix</code> <code>str</code> <p>add a prefix to the keys. Defaults to None.</p> <code>None</code> <code>geojson_out</code> <code>bool</code> <p>Return list of GeoJSON-like features (default: False) Original feature geometry and properties will be retained with zonal stats appended as additional properties. Use with prefix to ensure unique and meaningful property names.. Defaults to False.</p> <code>False</code> <code>gdf_out</code> <code>bool</code> <p>Return a GeoDataFrame. Defaults to False.</p> <code>False</code> <code>dst_crs</code> <code>str</code> <p>The destination CRS. Defaults to None.</p> <code>None</code> <code>open_vector_args</code> <code>dict</code> <p>Pass additional arguments to geopandas.open_file(). Defaults to {}.</p> <code>{}</code> <code>open_raster_args</code> <code>dict</code> <p>Pass additional arguments to rasterio.open(). Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict | list | GeoDataFrame</code> <p>The zonal statistics results</p> Source code in <code>beamgis/common.py</code> <pre><code>def zonal_stats(\n    vectors,\n    raster,\n    layer=0,\n    band_num=1,\n    nodata=None,\n    affine=None,\n    stats=None,\n    all_touched=False,\n    categorical=False,\n    category_map=None,\n    add_stats=None,\n    raster_out=False,\n    prefix=None,\n    geojson_out=False,\n    gdf_out=False,\n    dst_crs=None,\n    open_vector_args={},\n    open_raster_args={},\n    **kwargs,\n):\n    \"\"\"This function wraps rasterstats.zonal_stats and performs reprojection if necessary.\n        See https://pythonhosted.org/rasterstats/rasterstats.html.\n\n    Args:\n        vectors (str | list | GeoDataFrame): path to an vector source or geo-like python objects.\n        raster (str | ndarray): ndarray or path to a GDAL raster source.\n        layer (int, optional): If vectors is a path to an fiona source, specify the vector layer to\n            use either by name or number. Defaults to 0\n        band_num (int | str, optional): If raster is a GDAL source, the band number to use (counting from 1). defaults to 1.\n        nodata (float, optional): If raster is a GDAL source, this value overrides any NODATA value\n            specified in the file\u2019s metadata. If None, the file\u2019s metadata\u2019s NODATA value (if any)\n            will be used. defaults to None.\n        affine (Affine, optional): required only for ndarrays, otherwise it is read from src. Defaults to None.\n        stats (str | list, optional): Which statistics to calculate for each zone.\n            It can be ['min', 'max', 'mean', 'count']. For more, see https://pythonhosted.org/rasterstats/manual.html#zonal-statistics\n            Defaults to None.\n        all_touched (bool, optional): Whether to include every raster cell touched by a geometry, or only those having\n            a center point within the polygon. defaults to False\n        categorical (bool, optional): If True, the raster values will be treated as categorical.\n        category_map (dict, optional):A dictionary mapping raster values to human-readable categorical names.\n            Only applies when categorical is True\n        add_stats (dict, optional): with names and functions of additional stats to compute. Defaults to None.\n        raster_out (bool, optional): Include the masked numpy array for each feature?. Defaults to False.\n        prefix (str, optional): add a prefix to the keys. Defaults to None.\n        geojson_out (bool, optional): Return list of GeoJSON-like features (default: False)\n            Original feature geometry and properties will be retained with zonal stats\n            appended as additional properties. Use with prefix to ensure unique and\n            meaningful property names.. Defaults to False.\n        gdf_out (bool, optional): Return a GeoDataFrame. Defaults to False.\n        dst_crs (str, optional): The destination CRS. Defaults to None.\n        open_vector_args (dict, optional): Pass additional arguments to geopandas.open_file(). Defaults to {}.\n        open_raster_args (dict, optional): Pass additional arguments to rasterio.open(). Defaults to {}.\n\n    Returns:\n        dict | list | GeoDataFrame: The zonal statistics results\n    \"\"\"\n\n    import geopandas as gpd\n    import rasterio\n    import xarray as xr\n\n    try:\n        import rasterstats\n    except ImportError:\n        raise ImportError(\n            \"rasterstats is not installed. Install it with pip install rasterstats\"\n        )\n    try:\n        if isinstance(raster, str):\n            with rasterio.open(raster, **open_raster_args) as src:\n                affine = src.transform\n                nodata = src.nodata\n                array = src.read(band_num, masked=True)\n                raster_crs = src.crs\n        elif isinstance(raster, rasterio.io.DatasetReader):\n            affine = raster.transform\n            nodata = raster.nodata\n            array = raster.read(band_num, masked=True)\n            raster_crs = raster.crs\n        elif isinstance(raster, xr.DataArray):\n            array = raster\n            raster_crs = raster.rio.crs\n        else:\n            array = raster\n\n        if isinstance(vectors, str):\n            gdf = gpd.read_file(vectors, **open_vector_args)\n        elif isinstance(vectors, list):\n            gdf = gpd.GeoDataFrame.from_features(vectors)\n        else:\n            gdf = vectors\n\n        vector_crs = gdf.crs\n\n        if gdf.crs.is_geographic:\n            if not raster_crs.is_geographic:\n                gdf = gdf.to_crs(raster_crs)\n        elif gdf.crs != raster_crs:\n            if not raster_crs.is_geographic:\n                gdf = gdf.to_crs(raster_crs)\n            else:\n                raise ValueError(\"The vector and raster CRSs are not compatible\")\n\n        if gdf_out is True:\n            geojson_out = True\n\n        result = rasterstats.zonal_stats(\n            gdf,\n            array,\n            layer=layer,\n            band_num=band_num,\n            nodata=nodata,\n            affine=affine,\n            stats=stats,\n            all_touched=all_touched,\n            categorical=categorical,\n            category_map=category_map,\n            add_stats=add_stats,\n            raster_out=raster_out,\n            prefix=prefix,\n            geojson_out=geojson_out,\n            **kwargs,\n        )\n\n        if gdf_out is True:\n            if dst_crs is None:\n                dst_crs = vector_crs\n\n            out_gdf = gpd.GeoDataFrame.from_features(result)\n            out_gdf.crs = raster_crs\n            return out_gdf.to_crs(dst_crs)\n        else:\n            return result\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#beamgis.common.zoom_level_resolution","title":"<code>zoom_level_resolution(zoom, latitude=0)</code>","text":"<p>Returns the approximate pixel scale based on zoom level and latutude.     See https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>int</code> <p>The zoom level.</p> required <code>latitude</code> <code>float</code> <p>The latitude. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>float</code> <p>Map resolution in meters.</p> Source code in <code>beamgis/common.py</code> <pre><code>def zoom_level_resolution(zoom, latitude=0):\n    \"\"\"Returns the approximate pixel scale based on zoom level and latutude.\n        See https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution\n\n    Args:\n        zoom (int): The zoom level.\n        latitude (float, optional): The latitude. Defaults to 0.\n\n    Returns:\n        float: Map resolution in meters.\n    \"\"\"\n    import math\n\n    resolution = 156543.04 * math.cos(latitude) / math.pow(2, zoom)\n    return abs(resolution)\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/eafriyie28/beamgis/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>beamgis could always use more documentation, whether as part of the official beamgis docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/eafriyie28/beamgis/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up beamgis for local development.</p> <ol> <li> <p>Fork the beamgis repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/beamgis.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv beamgis\n$ cd beamgis/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 beamgis tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/eafriyie28/beamgis/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"foliumap/","title":"folium module","text":"<p>This module provides a custom Map class that extends folium.Map</p>"},{"location":"foliumap/#beamgis.foliumap.Map","title":"<code> Map            (Map)         </code>","text":"<p>A custom Map class that extends folium.Map.</p> Source code in <code>beamgis/foliumap.py</code> <pre><code>class Map(folium.Map):\n    \"\"\"A custom Map class that extends folium.Map.\"\"\"\n\n    def __init__(self, center=(0, 0), zoom=2, **kwargs):\n        \"\"\"Initializes the Map object.\n\n        Args:\n            center (tuple, optional): The initial center of the map as (latitude, longitude). Defaults to (0, 0).\n            zoom (int, optional): The initial zoom level of the map. Defaults to 2.\n            **kwargs: Additional keyword arguments for the folium.Map class.\n        \"\"\"\n        super().__init__(location=center, zoom_start=zoom, **kwargs)\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the folium.GeoJson layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n\n        geojson = folium.GeoJson(data=geojson, **kwargs)\n        geojson.add_to(self)\n\n        if zoom_to_layer and gdf is not None:\n            bounds = gdf.total_bounds\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_basemap(self, basemap=\"OpenStreetMap\"):\n        \"\"\"Add basemap to the map using Folium's built-in tiles or a custom TileLayer.\n\n        Args:\n            basemap (str or dict, optional): Basemap name (dotted format) or a custom basemap dict.\n                Examples:\n                    \"CartoDB.DarkMatter\"\n                    {\n                        \"tiles\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\",\n                        \"name\": \"OpenTopoMap\",\n                        \"attr\": \"\u00a9 OpenTopoMap contributors\"\n                    }\n        \"\"\"\n        # Built-in basemap mapping\n        basemap_mapping = {\n            \"OpenStreetMap\": \"OpenStreetMap\",\n            \"CartoDB.Positron\": \"CartoDB positron\",\n            \"CartoDB.DarkMatter\": \"CartoDB dark_matter\",\n        }\n\n        if isinstance(basemap, str):\n            if basemap not in basemap_mapping:\n                raise ValueError(\n                    f\"Basemap '{basemap}' not supported. Available options: {list(basemap_mapping.keys())}\"\n                )\n            tile_name = basemap_mapping[basemap]\n            tile_layer = folium.TileLayer(tiles=tile_name, name=basemap, control=True)\n        elif isinstance(basemap, dict):\n            required_keys = {\"tiles\", \"name\", \"attr\"}\n            if not required_keys.issubset(basemap):\n                raise ValueError(\n                    \"Custom basemap dict must include 'tiles', 'name', and 'attr'\"\n                )\n            tile_layer = folium.TileLayer(\n                tiles=basemap[\"tiles\"],\n                name=basemap[\"name\"],\n                attr=basemap[\"attr\"],\n                control=True,\n            )\n        else:\n            raise TypeError(\n                \"Basemap must be a string or a dictionary with 'tiles', 'name', and 'attr'.\"\n            )\n\n        tile_layer.add_to(self)\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        folium.LayerControl().add_to(self)\n\n    def add_split_map(\n        self,\n        left=\"openstreetmap\",\n        right=\"cartodbpositron\",\n        colormap_left=None,\n        colormap_right=None,\n        opacity_left=1.0,\n        opacity_right=1.0,\n        **kwargs,\n    ):\n        \"\"\"\n        Adds a split map view to the current map, allowing users to compare two different map layers side by side.\n\n        Parameters:\n            left (str): The tile layer or path to a raster file for the left side of the map.\n            right (str): The tile layer or path to a raster file for the right side of the map.\n            colormap_left (callable): Colormap function for the left raster layer (if applicable).\n            colormap_right (callable): Colormap function for the right raster layer (if applicable).\n            opacity_left (float): Opacity for the left layer.\n            opacity_right (float): Opacity for the right layer.\n            **kwargs: Additional keyword arguments to customize the tile layers.\n\n        Returns:\n            None\n        \"\"\"\n\n        # Handle left layer\n        if isinstance(left, str) and left.lower().endswith((\".tif\", \".tiff\")):\n            client_left = TileClient(left)\n            layer_left = get_folium_tile_layer(\n                client_left,\n                name=\"Left Layer\",\n                colormap=colormap_left,\n                opacity=opacity_left,\n                **kwargs,\n            )\n        else:\n            layer_left = folium.TileLayer(\n                left, name=\"Left Layer\", opacity=opacity_left, **kwargs\n            )\n\n        # Handle right layer\n        if isinstance(right, str) and right.lower().endswith((\".tif\", \".tiff\")):\n            client_right = TileClient(right)\n            layer_right = get_folium_tile_layer(\n                client_right,\n                name=\"Right Layer\",\n                colormap=colormap_right,\n                opacity=opacity_right,\n                **kwargs,\n            )\n        else:\n            layer_right = folium.TileLayer(\n                right, name=\"Right Layer\", opacity=opacity_right, **kwargs\n            )\n\n        # Add layers to map\n        layer_left.add_to(self)\n        layer_right.add_to(self)\n\n        # Add split map control\n        sbs = folium.plugins.SideBySideLayers(\n            layer_left=layer_left, layer_right=layer_right\n        )\n        sbs.add_to(self)\n\n    def add_heatmap(\n        self,\n        data: Union[str, List[List[float]], pd.DataFrame],\n        latitude: Optional[str] = \"latitude\",\n        longitude: Optional[str] = \"longitude\",\n        value: Optional[str] = \"value\",\n        name: Optional[str] = \"Heat map\",\n        radius: Optional[int] = 25,\n        **kwargs,\n    ):\n        \"\"\"Adds a heat map to the map. Reference: https://stackoverflow.com/a/54756617\n\n        Args:\n            data (str | list | pd.DataFrame): File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\n            latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n            longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n            value (str, optional): The column name of values. Defaults to \"value\".\n            name (str, optional): Layer name to use. Defaults to \"Heat map\".\n            radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n\n        Raises:\n            ValueError: If data is not a list.\n        \"\"\"\n        import pandas as pd\n\n        try:\n            if isinstance(data, str):\n                df = pd.read_csv(data)\n                data = df[[latitude, longitude, value]].values.tolist()\n            elif isinstance(data, pd.DataFrame):\n                data = data[[latitude, longitude, value]].values.tolist()\n            elif isinstance(data, list):\n                pass\n            else:\n                raise ValueError(\"data must be a list, a DataFrame, or a file path.\")\n\n            plugins.HeatMap(data, name=name, radius=radius, **kwargs).add_to(\n                folium.FeatureGroup(name=name).add_to(self)\n            )\n        except Exception as e:\n            raise Exception(e)\n</code></pre>"},{"location":"foliumap/#beamgis.foliumap.Map.__init__","title":"<code>__init__(self, center=(0, 0), zoom=2, **kwargs)</code>  <code>special</code>","text":"<p>Initializes the Map object.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>The initial center of the map as (latitude, longitude). Defaults to (0, 0).</p> <code>(0, 0)</code> <code>zoom</code> <code>int</code> <p>The initial zoom level of the map. Defaults to 2.</p> <code>2</code> <code>**kwargs</code> <p>Additional keyword arguments for the folium.Map class.</p> <code>{}</code> Source code in <code>beamgis/foliumap.py</code> <pre><code>def __init__(self, center=(0, 0), zoom=2, **kwargs):\n    \"\"\"Initializes the Map object.\n\n    Args:\n        center (tuple, optional): The initial center of the map as (latitude, longitude). Defaults to (0, 0).\n        zoom (int, optional): The initial zoom level of the map. Defaults to 2.\n        **kwargs: Additional keyword arguments for the folium.Map class.\n    \"\"\"\n    super().__init__(location=center, zoom_start=zoom, **kwargs)\n</code></pre>"},{"location":"foliumap/#beamgis.foliumap.Map.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap')</code>","text":"<p>Add basemap to the map using Folium's built-in tiles or a custom TileLayer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str or dict</code> <p>Basemap name (dotted format) or a custom basemap dict. Examples:     \"CartoDB.DarkMatter\"     {         \"tiles\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\",         \"name\": \"OpenTopoMap\",         \"attr\": \"\u00a9 OpenTopoMap contributors\"     }</p> <code>'OpenStreetMap'</code> Source code in <code>beamgis/foliumap.py</code> <pre><code>def add_basemap(self, basemap=\"OpenStreetMap\"):\n    \"\"\"Add basemap to the map using Folium's built-in tiles or a custom TileLayer.\n\n    Args:\n        basemap (str or dict, optional): Basemap name (dotted format) or a custom basemap dict.\n            Examples:\n                \"CartoDB.DarkMatter\"\n                {\n                    \"tiles\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\",\n                    \"name\": \"OpenTopoMap\",\n                    \"attr\": \"\u00a9 OpenTopoMap contributors\"\n                }\n    \"\"\"\n    # Built-in basemap mapping\n    basemap_mapping = {\n        \"OpenStreetMap\": \"OpenStreetMap\",\n        \"CartoDB.Positron\": \"CartoDB positron\",\n        \"CartoDB.DarkMatter\": \"CartoDB dark_matter\",\n    }\n\n    if isinstance(basemap, str):\n        if basemap not in basemap_mapping:\n            raise ValueError(\n                f\"Basemap '{basemap}' not supported. Available options: {list(basemap_mapping.keys())}\"\n            )\n        tile_name = basemap_mapping[basemap]\n        tile_layer = folium.TileLayer(tiles=tile_name, name=basemap, control=True)\n    elif isinstance(basemap, dict):\n        required_keys = {\"tiles\", \"name\", \"attr\"}\n        if not required_keys.issubset(basemap):\n            raise ValueError(\n                \"Custom basemap dict must include 'tiles', 'name', and 'attr'\"\n            )\n        tile_layer = folium.TileLayer(\n            tiles=basemap[\"tiles\"],\n            name=basemap[\"name\"],\n            attr=basemap[\"attr\"],\n            control=True,\n        )\n    else:\n        raise TypeError(\n            \"Basemap must be a string or a dictionary with 'tiles', 'name', and 'attr'.\"\n        )\n\n    tile_layer.add_to(self)\n</code></pre>"},{"location":"foliumap/#beamgis.foliumap.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>beamgis/foliumap.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"foliumap/#beamgis.foliumap.Map.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the folium.GeoJson layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>beamgis/foliumap.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the folium.GeoJson layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n\n    geojson = folium.GeoJson(data=geojson, **kwargs)\n    geojson.add_to(self)\n\n    if zoom_to_layer and gdf is not None:\n        bounds = gdf.total_bounds\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"foliumap/#beamgis.foliumap.Map.add_heatmap","title":"<code>add_heatmap(self, data, latitude='latitude', longitude='longitude', value='value', name='Heat map', radius=25, **kwargs)</code>","text":"<p>Adds a heat map to the map. Reference: https://stackoverflow.com/a/54756617</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | list | pd.DataFrame</code> <p>File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv</p> required <code>latitude</code> <code>str</code> <p>The column name of latitude. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The column name of longitude. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>value</code> <code>str</code> <p>The column name of values. Defaults to \"value\".</p> <code>'value'</code> <code>name</code> <code>str</code> <p>Layer name to use. Defaults to \"Heat map\".</p> <code>'Heat map'</code> <code>radius</code> <code>int</code> <p>Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.</p> <code>25</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If data is not a list.</p> Source code in <code>beamgis/foliumap.py</code> <pre><code>def add_heatmap(\n    self,\n    data: Union[str, List[List[float]], pd.DataFrame],\n    latitude: Optional[str] = \"latitude\",\n    longitude: Optional[str] = \"longitude\",\n    value: Optional[str] = \"value\",\n    name: Optional[str] = \"Heat map\",\n    radius: Optional[int] = 25,\n    **kwargs,\n):\n    \"\"\"Adds a heat map to the map. Reference: https://stackoverflow.com/a/54756617\n\n    Args:\n        data (str | list | pd.DataFrame): File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\n        latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n        longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n        value (str, optional): The column name of values. Defaults to \"value\".\n        name (str, optional): Layer name to use. Defaults to \"Heat map\".\n        radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n\n    Raises:\n        ValueError: If data is not a list.\n    \"\"\"\n    import pandas as pd\n\n    try:\n        if isinstance(data, str):\n            df = pd.read_csv(data)\n            data = df[[latitude, longitude, value]].values.tolist()\n        elif isinstance(data, pd.DataFrame):\n            data = data[[latitude, longitude, value]].values.tolist()\n        elif isinstance(data, list):\n            pass\n        else:\n            raise ValueError(\"data must be a list, a DataFrame, or a file path.\")\n\n        plugins.HeatMap(data, name=name, radius=radius, **kwargs).add_to(\n            folium.FeatureGroup(name=name).add_to(self)\n        )\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#beamgis.foliumap.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>beamgis/foliumap.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    folium.LayerControl().add_to(self)\n</code></pre>"},{"location":"foliumap/#beamgis.foliumap.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>beamgis/foliumap.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"foliumap/#beamgis.foliumap.Map.add_split_map","title":"<code>add_split_map(self, left='openstreetmap', right='cartodbpositron', colormap_left=None, colormap_right=None, opacity_left=1.0, opacity_right=1.0, **kwargs)</code>","text":"<p>Adds a split map view to the current map, allowing users to compare two different map layers side by side.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str</code> <p>The tile layer or path to a raster file for the left side of the map.</p> <code>'openstreetmap'</code> <code>right</code> <code>str</code> <p>The tile layer or path to a raster file for the right side of the map.</p> <code>'cartodbpositron'</code> <code>colormap_left</code> <code>callable</code> <p>Colormap function for the left raster layer (if applicable).</p> <code>None</code> <code>colormap_right</code> <code>callable</code> <p>Colormap function for the right raster layer (if applicable).</p> <code>None</code> <code>opacity_left</code> <code>float</code> <p>Opacity for the left layer.</p> <code>1.0</code> <code>opacity_right</code> <code>float</code> <p>Opacity for the right layer.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional keyword arguments to customize the tile layers.</p> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>beamgis/foliumap.py</code> <pre><code>def add_split_map(\n    self,\n    left=\"openstreetmap\",\n    right=\"cartodbpositron\",\n    colormap_left=None,\n    colormap_right=None,\n    opacity_left=1.0,\n    opacity_right=1.0,\n    **kwargs,\n):\n    \"\"\"\n    Adds a split map view to the current map, allowing users to compare two different map layers side by side.\n\n    Parameters:\n        left (str): The tile layer or path to a raster file for the left side of the map.\n        right (str): The tile layer or path to a raster file for the right side of the map.\n        colormap_left (callable): Colormap function for the left raster layer (if applicable).\n        colormap_right (callable): Colormap function for the right raster layer (if applicable).\n        opacity_left (float): Opacity for the left layer.\n        opacity_right (float): Opacity for the right layer.\n        **kwargs: Additional keyword arguments to customize the tile layers.\n\n    Returns:\n        None\n    \"\"\"\n\n    # Handle left layer\n    if isinstance(left, str) and left.lower().endswith((\".tif\", \".tiff\")):\n        client_left = TileClient(left)\n        layer_left = get_folium_tile_layer(\n            client_left,\n            name=\"Left Layer\",\n            colormap=colormap_left,\n            opacity=opacity_left,\n            **kwargs,\n        )\n    else:\n        layer_left = folium.TileLayer(\n            left, name=\"Left Layer\", opacity=opacity_left, **kwargs\n        )\n\n    # Handle right layer\n    if isinstance(right, str) and right.lower().endswith((\".tif\", \".tiff\")):\n        client_right = TileClient(right)\n        layer_right = get_folium_tile_layer(\n            client_right,\n            name=\"Right Layer\",\n            colormap=colormap_right,\n            opacity=opacity_right,\n            **kwargs,\n        )\n    else:\n        layer_right = folium.TileLayer(\n            right, name=\"Right Layer\", opacity=opacity_right, **kwargs\n        )\n\n    # Add layers to map\n    layer_left.add_to(self)\n    layer_right.add_to(self)\n\n    # Add split map control\n    sbs = folium.plugins.SideBySideLayers(\n        layer_left=layer_left, layer_right=layer_right\n    )\n    sbs.add_to(self)\n</code></pre>"},{"location":"foliumap/#beamgis.foliumap.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>beamgis/foliumap.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"heatmapwidget/","title":"heatmap widget module","text":""},{"location":"heatmapwidget/#beamgis.heatmapwidget.HeatmapWidget","title":"<code> HeatmapWidget            (VBox)         </code>","text":"<p>A widget for creating and adding a heatmap layer to an ipyleaflet map.</p> <p>Attributes:</p> Name Type Description <code>map_obj</code> <code>ipyleaflet.Map</code> <p>The ipyleaflet map object to which the heatmap will be added.</p> <code>df</code> <code>pandas.DataFrame</code> <p>The dataframe loaded from the provided CSV URL.</p> <p>Methods</p> <p>_load_csv(b): Loads a CSV file from the provided URL and populates dropdowns with column names. _add_heatmap(b): Adds a heatmap layer to the map using the selected columns and parameters.</p> Source code in <code>beamgis/heatmapwidget.py</code> <pre><code>class HeatmapWidget(widgets.VBox):\n    \"\"\"\n    A widget for creating and adding a heatmap layer to an ipyleaflet map.\n\n    Attributes:\n        map_obj (ipyleaflet.Map): The ipyleaflet map object to which the heatmap will be added.\n        df (pandas.DataFrame): The dataframe loaded from the provided CSV URL.\n\n    Methods:\n        _load_csv(b): Loads a CSV file from the provided URL and populates dropdowns with column names.\n        _add_heatmap(b): Adds a heatmap layer to the map using the selected columns and parameters.\n    \"\"\"\n\n    def __init__(self, map_obj):\n        \"\"\"\n        Initializes the HeatmapWidget with the given map object and sets up the UI components.\n\n        Args:\n            map_obj (ipyleaflet.Map): The ipyleaflet map object to which the heatmap will be added.\n        \"\"\"\n        super().__init__()\n        self.map_obj = map_obj\n        self.df = None\n\n        # Widgets\n        self.csv_url = widgets.Text(\n            value=\"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\",\n            placeholder=\"Enter CSV URL\",\n            description=\"CSV URL:\",\n            layout=widgets.Layout(width=\"100%\"),\n        )\n\n        self.load_button = widgets.Button(description=\"Load CSV\", button_style=\"info\")\n        self.lat_dropdown = widgets.Dropdown(description=\"Latitude:\")\n        self.lon_dropdown = widgets.Dropdown(description=\"Longitude:\")\n        self.val_dropdown = widgets.Dropdown(description=\"Value:\")\n        self.radius_slider = widgets.IntSlider(\n            value=25, min=1, max=50, step=1, description=\"Radius:\"\n        )\n        self.name_text = widgets.Text(value=\"Heat map\", description=\"Layer Name:\")\n        self.add_button = widgets.Button(\n            description=\"Add Heatmap\", button_style=\"success\"\n        )\n\n        self.load_button.on_click(self._load_csv)\n        self.add_button.on_click(self._add_heatmap)\n\n        self.children = [\n            self.csv_url,\n            self.load_button,\n            self.lat_dropdown,\n            self.lon_dropdown,\n            self.val_dropdown,\n            self.radius_slider,\n            self.name_text,\n            self.add_button,\n        ]\n\n    def _load_csv(self, b):\n        \"\"\"\n        Loads a CSV file from the provided URL and populates the dropdowns with column names.\n\n        Args:\n            b: The button click event.\n        \"\"\"\n        try:\n            self.df = pd.read_csv(self.csv_url.value)\n            cols = self.df.columns.tolist()\n            self.lat_dropdown.options = cols\n            self.lon_dropdown.options = cols\n            self.val_dropdown.options = cols\n        except Exception as e:\n            print(f\"Error loading CSV: {e}\")\n\n    def _add_heatmap(self, b):\n        \"\"\"\n        Adds a heatmap layer to the map using the selected columns and parameters.\n\n        Args:\n            b: The button click event.\n        \"\"\"\n        try:\n            lat = self.lat_dropdown.value\n            lon = self.lon_dropdown.value\n            val = self.val_dropdown.value\n            radius = self.radius_slider.value\n            name = self.name_text.value\n\n            data = self.df[[lat, lon, val]].values.tolist()\n            heatmap = Heatmap(locations=data, radius=radius, name=name)\n            self.map_obj.add(heatmap)\n        except Exception as e:\n            print(f\"Error adding heatmap: {e}\")\n</code></pre>"},{"location":"heatmapwidget/#beamgis.heatmapwidget.HeatmapWidget.__init__","title":"<code>__init__(self, map_obj)</code>  <code>special</code>","text":"<p>Initializes the HeatmapWidget with the given map object and sets up the UI components.</p> <p>Parameters:</p> Name Type Description Default <code>map_obj</code> <code>ipyleaflet.Map</code> <p>The ipyleaflet map object to which the heatmap will be added.</p> required Source code in <code>beamgis/heatmapwidget.py</code> <pre><code>def __init__(self, map_obj):\n    \"\"\"\n    Initializes the HeatmapWidget with the given map object and sets up the UI components.\n\n    Args:\n        map_obj (ipyleaflet.Map): The ipyleaflet map object to which the heatmap will be added.\n    \"\"\"\n    super().__init__()\n    self.map_obj = map_obj\n    self.df = None\n\n    # Widgets\n    self.csv_url = widgets.Text(\n        value=\"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\",\n        placeholder=\"Enter CSV URL\",\n        description=\"CSV URL:\",\n        layout=widgets.Layout(width=\"100%\"),\n    )\n\n    self.load_button = widgets.Button(description=\"Load CSV\", button_style=\"info\")\n    self.lat_dropdown = widgets.Dropdown(description=\"Latitude:\")\n    self.lon_dropdown = widgets.Dropdown(description=\"Longitude:\")\n    self.val_dropdown = widgets.Dropdown(description=\"Value:\")\n    self.radius_slider = widgets.IntSlider(\n        value=25, min=1, max=50, step=1, description=\"Radius:\"\n    )\n    self.name_text = widgets.Text(value=\"Heat map\", description=\"Layer Name:\")\n    self.add_button = widgets.Button(\n        description=\"Add Heatmap\", button_style=\"success\"\n    )\n\n    self.load_button.on_click(self._load_csv)\n    self.add_button.on_click(self._add_heatmap)\n\n    self.children = [\n        self.csv_url,\n        self.load_button,\n        self.lat_dropdown,\n        self.lon_dropdown,\n        self.val_dropdown,\n        self.radius_slider,\n        self.name_text,\n        self.add_button,\n    ]\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install beamgis, run this command in your terminal:</p> <pre><code>pip install beamgis\n</code></pre> <p>This is the preferred method to install beamgis, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install beamgis from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/eafriyie28/beamgis\n</code></pre>"},{"location":"map_widgets/","title":"map widgets module","text":""},{"location":"map_widgets/#beamgis.map_widgets.Colorbar","title":"<code> Colorbar            (Output)         </code>","text":"<p>A matplotlib colorbar widget that can be added to the map.</p> Source code in <code>beamgis/map_widgets.py</code> <pre><code>class Colorbar(ipywidgets.Output):\n    \"\"\"A matplotlib colorbar widget that can be added to the map.\"\"\"\n\n    def __init__(\n        self,\n        vmin=0,\n        vmax=1,\n        cmap=\"gray\",\n        discrete=False,\n        label=None,\n        orientation=\"horizontal\",\n        transparent_bg=False,\n        font_size=9,\n        axis_off=False,\n        max_width=None,\n        **kwargs,\n    ):\n        \"\"\"Add a matplotlib colorbar to the map.\n\n        Args:\n            vis_params (dict): Visualization parameters as a dictionary. See\n                https://developers.google.com/earth-engine/guides/image_visualization # noqa\n                for options.\n            cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See\n                https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py # noqa\n                for options.\n            discrete (bool, optional): Whether to create a discrete colorbar.\n                Defaults to False.\n            label (str, optional): Label for the colorbar. Defaults to None.\n            orientation (str, optional): Orientation of the colorbar, such as\n                \"vertical\" and \"horizontal\". Defaults to \"horizontal\".\n            transparent_bg (bool, optional): Whether to use transparent\n                background. Defaults to False.\n            font_size (int, optional): Font size for the colorbar. Defaults\n                to 9.\n            axis_off (bool, optional): Whether to turn off the axis. Defaults\n                to False.\n            max_width (str, optional): Maximum width of the colorbar in pixels.\n                Defaults to None.\n\n        Raises:\n            TypeError: If the vis_params is not a dictionary.\n            ValueError: If the orientation is not either horizontal or vertical.\n            ValueError: If the provided min value is not convertible to float.\n            ValueError: If the provided max value is not convertible to float.\n            ValueError: If the provided opacity value is not convertible to float.\n            ValueError: If cmap or palette is not provided.\n        \"\"\"\n\n        import matplotlib  # pylint: disable=import-outside-toplevel\n        import numpy  # pylint: disable=import-outside-toplevel\n\n        if max_width is None:\n            if orientation == \"horizontal\":\n                max_width = \"270px\"\n            else:\n                max_width = \"100px\"\n\n        vis_params = {\n            \"min\": vmin,\n            \"max\": vmax,\n        }\n\n        if not isinstance(vis_params, dict):\n            raise TypeError(\"The vis_params must be a dictionary.\")\n\n        if isinstance(kwargs.get(\"colors\"), (list, tuple)):\n            vis_params[\"palette\"] = list(kwargs[\"colors\"])\n\n        width, height = self._get_dimensions(orientation, kwargs)\n\n        vmin = vis_params.get(\"min\", kwargs.pop(\"vmin\", 0))\n        try:\n            vmin = float(vmin)\n        except ValueError as err:\n            raise ValueError(\"The provided min value must be scalar type.\")\n\n        vmax = vis_params.get(\"max\", kwargs.pop(\"vmax\", 1))\n        try:\n            vmax = float(vmax)\n        except ValueError as err:\n            raise ValueError(\"The provided max value must be scalar type.\")\n\n        alpha = vis_params.get(\"opacity\", kwargs.pop(\"alpha\", 1))\n        try:\n            alpha = float(alpha)\n        except ValueError as err:\n            raise ValueError(\"opacity or alpha value must be scalar type.\")\n\n        if \"palette\" in vis_params.keys():\n            hexcodes = common.to_hex_colors(common.check_cmap(vis_params[\"palette\"]))\n            if discrete:\n                cmap = matplotlib.colors.ListedColormap(hexcodes)\n                linspace = numpy.linspace(vmin, vmax, cmap.N + 1)\n                norm = matplotlib.colors.BoundaryNorm(linspace, cmap.N)\n            else:\n                cmap = matplotlib.colors.LinearSegmentedColormap.from_list(\n                    \"custom\", hexcodes, N=256\n                )\n                norm = matplotlib.colors.Normalize(vmin=vmin, vmax=vmax)\n        elif cmap:\n            cmap = matplotlib.colormaps[cmap]\n            norm = matplotlib.colors.Normalize(vmin=vmin, vmax=vmax)\n        else:\n            raise ValueError(\n                'cmap keyword or \"palette\" key in vis_params must be provided.'\n            )\n\n        fig, ax = matplotlib.pyplot.subplots(figsize=(width, height))\n        cb = matplotlib.colorbar.ColorbarBase(\n            ax,\n            norm=norm,\n            alpha=alpha,\n            cmap=cmap,\n            orientation=orientation,\n            **kwargs,\n        )\n\n        label = label or vis_params.get(\"bands\") or kwargs.pop(\"caption\", None)\n        if label:\n            cb.set_label(label, fontsize=font_size)\n\n        if axis_off:\n            ax.set_axis_off()\n        ax.tick_params(labelsize=font_size)\n\n        # Set the background color to transparent.\n        if transparent_bg:\n            fig.patch.set_alpha(0.0)\n\n        super().__init__(layout=ipywidgets.Layout(width=max_width))\n        with self:\n            self.outputs = ()\n            matplotlib.pyplot.show()\n\n    def _get_dimensions(self, orientation, kwargs):\n        default_dims = {\"horizontal\": (3.0, 0.3), \"vertical\": (0.3, 3.0)}\n        if orientation not in default_dims:\n            valid_orientations = \", \".join(default_dims.keys())\n            raise ValueError(\n                f\"orientation must be one of [{', '.join(valid_orientations)}]\"\n            )\n        default_width, default_height = default_dims[orientation]\n        width = kwargs.get(\"width\", default_width)\n        height = kwargs.get(\"height\", default_height)\n        return width, height\n</code></pre>"},{"location":"map_widgets/#beamgis.map_widgets.Colorbar.__init__","title":"<code>__init__(self, vmin=0, vmax=1, cmap='gray', discrete=False, label=None, orientation='horizontal', transparent_bg=False, font_size=9, axis_off=False, max_width=None, **kwargs)</code>  <code>special</code>","text":"<p>Add a matplotlib colorbar to the map.</p> <p>Parameters:</p> Name Type Description Default <code>vis_params</code> <code>dict</code> <p>Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization # noqa for options.</p> required <code>cmap</code> <code>str</code> <p>Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py # noqa for options.</p> <code>'gray'</code> <code>discrete</code> <code>bool</code> <p>Whether to create a discrete colorbar. Defaults to False.</p> <code>False</code> <code>label</code> <code>str</code> <p>Label for the colorbar. Defaults to None.</p> <code>None</code> <code>orientation</code> <code>str</code> <p>Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".</p> <code>'horizontal'</code> <code>transparent_bg</code> <code>bool</code> <p>Whether to use transparent background. Defaults to False.</p> <code>False</code> <code>font_size</code> <code>int</code> <p>Font size for the colorbar. Defaults to 9.</p> <code>9</code> <code>axis_off</code> <code>bool</code> <p>Whether to turn off the axis. Defaults to False.</p> <code>False</code> <code>max_width</code> <code>str</code> <p>Maximum width of the colorbar in pixels. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If the vis_params is not a dictionary.</p> <code>ValueError</code> <p>If the orientation is not either horizontal or vertical.</p> <code>ValueError</code> <p>If the provided min value is not convertible to float.</p> <code>ValueError</code> <p>If the provided max value is not convertible to float.</p> <code>ValueError</code> <p>If the provided opacity value is not convertible to float.</p> <code>ValueError</code> <p>If cmap or palette is not provided.</p> Source code in <code>beamgis/map_widgets.py</code> <pre><code>def __init__(\n    self,\n    vmin=0,\n    vmax=1,\n    cmap=\"gray\",\n    discrete=False,\n    label=None,\n    orientation=\"horizontal\",\n    transparent_bg=False,\n    font_size=9,\n    axis_off=False,\n    max_width=None,\n    **kwargs,\n):\n    \"\"\"Add a matplotlib colorbar to the map.\n\n    Args:\n        vis_params (dict): Visualization parameters as a dictionary. See\n            https://developers.google.com/earth-engine/guides/image_visualization # noqa\n            for options.\n        cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See\n            https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py # noqa\n            for options.\n        discrete (bool, optional): Whether to create a discrete colorbar.\n            Defaults to False.\n        label (str, optional): Label for the colorbar. Defaults to None.\n        orientation (str, optional): Orientation of the colorbar, such as\n            \"vertical\" and \"horizontal\". Defaults to \"horizontal\".\n        transparent_bg (bool, optional): Whether to use transparent\n            background. Defaults to False.\n        font_size (int, optional): Font size for the colorbar. Defaults\n            to 9.\n        axis_off (bool, optional): Whether to turn off the axis. Defaults\n            to False.\n        max_width (str, optional): Maximum width of the colorbar in pixels.\n            Defaults to None.\n\n    Raises:\n        TypeError: If the vis_params is not a dictionary.\n        ValueError: If the orientation is not either horizontal or vertical.\n        ValueError: If the provided min value is not convertible to float.\n        ValueError: If the provided max value is not convertible to float.\n        ValueError: If the provided opacity value is not convertible to float.\n        ValueError: If cmap or palette is not provided.\n    \"\"\"\n\n    import matplotlib  # pylint: disable=import-outside-toplevel\n    import numpy  # pylint: disable=import-outside-toplevel\n\n    if max_width is None:\n        if orientation == \"horizontal\":\n            max_width = \"270px\"\n        else:\n            max_width = \"100px\"\n\n    vis_params = {\n        \"min\": vmin,\n        \"max\": vmax,\n    }\n\n    if not isinstance(vis_params, dict):\n        raise TypeError(\"The vis_params must be a dictionary.\")\n\n    if isinstance(kwargs.get(\"colors\"), (list, tuple)):\n        vis_params[\"palette\"] = list(kwargs[\"colors\"])\n\n    width, height = self._get_dimensions(orientation, kwargs)\n\n    vmin = vis_params.get(\"min\", kwargs.pop(\"vmin\", 0))\n    try:\n        vmin = float(vmin)\n    except ValueError as err:\n        raise ValueError(\"The provided min value must be scalar type.\")\n\n    vmax = vis_params.get(\"max\", kwargs.pop(\"vmax\", 1))\n    try:\n        vmax = float(vmax)\n    except ValueError as err:\n        raise ValueError(\"The provided max value must be scalar type.\")\n\n    alpha = vis_params.get(\"opacity\", kwargs.pop(\"alpha\", 1))\n    try:\n        alpha = float(alpha)\n    except ValueError as err:\n        raise ValueError(\"opacity or alpha value must be scalar type.\")\n\n    if \"palette\" in vis_params.keys():\n        hexcodes = common.to_hex_colors(common.check_cmap(vis_params[\"palette\"]))\n        if discrete:\n            cmap = matplotlib.colors.ListedColormap(hexcodes)\n            linspace = numpy.linspace(vmin, vmax, cmap.N + 1)\n            norm = matplotlib.colors.BoundaryNorm(linspace, cmap.N)\n        else:\n            cmap = matplotlib.colors.LinearSegmentedColormap.from_list(\n                \"custom\", hexcodes, N=256\n            )\n            norm = matplotlib.colors.Normalize(vmin=vmin, vmax=vmax)\n    elif cmap:\n        cmap = matplotlib.colormaps[cmap]\n        norm = matplotlib.colors.Normalize(vmin=vmin, vmax=vmax)\n    else:\n        raise ValueError(\n            'cmap keyword or \"palette\" key in vis_params must be provided.'\n        )\n\n    fig, ax = matplotlib.pyplot.subplots(figsize=(width, height))\n    cb = matplotlib.colorbar.ColorbarBase(\n        ax,\n        norm=norm,\n        alpha=alpha,\n        cmap=cmap,\n        orientation=orientation,\n        **kwargs,\n    )\n\n    label = label or vis_params.get(\"bands\") or kwargs.pop(\"caption\", None)\n    if label:\n        cb.set_label(label, fontsize=font_size)\n\n    if axis_off:\n        ax.set_axis_off()\n    ax.tick_params(labelsize=font_size)\n\n    # Set the background color to transparent.\n    if transparent_bg:\n        fig.patch.set_alpha(0.0)\n\n    super().__init__(layout=ipywidgets.Layout(width=max_width))\n    with self:\n        self.outputs = ()\n        matplotlib.pyplot.show()\n</code></pre>"},{"location":"map_widgets/#beamgis.map_widgets.LayerEditor","title":"<code> LayerEditor            (VBox)         </code>","text":"<p>Widget for displaying and editing layer visualization properties.</p> Source code in <code>beamgis/map_widgets.py</code> <pre><code>class LayerEditor(ipywidgets.VBox):\n    \"\"\"Widget for displaying and editing layer visualization properties.\"\"\"\n\n    def __init__(self, host_map, layer_dict):\n        \"\"\"Initializes a layer editor widget.\n\n        Args:\n            host_map (geemap.Map): The geemap.Map object.\n            layer_dict (dict): The layer object to edit.\n        \"\"\"\n\n        # self.on_close = None\n\n        self._host_map = host_map\n        self._layer_dict = layer_dict\n        if not host_map:\n            raise ValueError(\n                f\"Must pass a valid map when creating a {self.__class__.__name__} widget.\"\n            )\n\n        self._toggle_button = ipywidgets.ToggleButton(\n            value=True,\n            tooltip=\"Layer editor\",\n            icon=\"gear\",\n            layout=ipywidgets.Layout(\n                width=\"28px\", height=\"28px\", padding=\"0px 0 0 3px\"\n            ),\n        )\n        self._toggle_button.observe(self._on_toggle_click, \"value\")\n\n        self._close_button = ipywidgets.Button(\n            tooltip=\"Close the vis params dialog\",\n            icon=\"times\",\n            button_style=\"primary\",\n            layout=ipywidgets.Layout(width=\"28px\", height=\"28px\", padding=\"0\"),\n        )\n        self._close_button.on_click(self._on_close_click)\n\n        layout = ipywidgets.Layout(width=\"95px\")\n        self._import_button = ipywidgets.Button(\n            description=\"Import\",\n            # button_style=\"primary\",\n            tooltip=\"Import vis params to notebook\",\n            layout=layout,\n        )\n        self._apply_button = ipywidgets.Button(\n            description=\"Apply\", tooltip=\"Apply vis params to the layer\", layout=layout\n        )\n\n        self._layer_spinner = ipywidgets.Button(\n            icon=\"check\",\n            layout=ipywidgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px\"),\n            tooltip=\"Loaded\",\n        )\n\n        def loading_change(change):\n            if change[\"new\"]:\n                self._layer_spinner.tooltip = \"Loading ...\"\n                self._layer_spinner.icon = \"spinner spin lg\"\n            else:\n                self._layer_spinner.tooltip = \"Loaded\"\n                self._layer_spinner.icon = \"check\"\n\n        self._import_button.on_click(self._on_import_click)\n        self._apply_button.on_click(self._on_apply_click)\n\n        self._label = ipywidgets.Label(\n            value=layer_dict[\"layer_name\"],\n            layout=ipywidgets.Layout(max_width=\"200px\", padding=\"1px 4px 0 4px\"),\n        )\n        self._embedded_widget = ipywidgets.Label(value=\"Vis params are uneditable\")\n        if layer_dict is not None:\n            if layer_dict[\"type\"] in [\"LOCAL\", \"COG\", \"STAC\", \"XARRAY\"]:\n                self._embedded_widget = RasterLayerEditor(\n                    host_map=host_map, layer_dict=layer_dict\n                )\n\n                layer_dict[\"tile_layer\"].observe(loading_change, \"loading\")\n\n        super().__init__(children=[])\n        self._on_toggle_click({\"new\": True})\n\n    def _on_toggle_click(self, change):\n        if change[\"new\"]:\n            self.children = [\n                ipywidgets.HBox([self._close_button, self._toggle_button, self._label]),\n                self._embedded_widget,\n                ipywidgets.HBox(\n                    [self._import_button, self._apply_button, self._layer_spinner]\n                ),\n            ]\n        else:\n            self.children = [\n                ipywidgets.HBox([self._close_button, self._toggle_button, self._label]),\n            ]\n\n    def _on_import_click(self, _):\n        self._embedded_widget.on_import_click()\n\n    def _on_apply_click(self, _):\n\n        def loading_change(change):\n            if change[\"new\"]:\n                self._layer_spinner.tooltip = \"Loading ...\"\n                self._layer_spinner.icon = \"spinner spin lg\"\n            else:\n                self._layer_spinner.tooltip = \"Loaded\"\n                self._layer_spinner.icon = \"check\"\n\n        self._layer_spinner.icon = \"spinner spin lg\"\n        self._layer_spinner.unobserve(loading_change, \"loading\")\n        self._embedded_widget.on_apply_click()\n        self._host_map.cog_layer_dict[self._layer_dict[\"layer_name\"]][\n            \"tile_layer\"\n        ].observe(loading_change, \"loading\")\n\n    def _on_close_click(self, _):\n        # if self.on_close:\n        self._layer_editor = None\n        self.on_close()\n</code></pre>"},{"location":"map_widgets/#beamgis.map_widgets.LayerEditor.__init__","title":"<code>__init__(self, host_map, layer_dict)</code>  <code>special</code>","text":"<p>Initializes a layer editor widget.</p> <p>Parameters:</p> Name Type Description Default <code>host_map</code> <code>geemap.Map</code> <p>The geemap.Map object.</p> required <code>layer_dict</code> <code>dict</code> <p>The layer object to edit.</p> required Source code in <code>beamgis/map_widgets.py</code> <pre><code>def __init__(self, host_map, layer_dict):\n    \"\"\"Initializes a layer editor widget.\n\n    Args:\n        host_map (geemap.Map): The geemap.Map object.\n        layer_dict (dict): The layer object to edit.\n    \"\"\"\n\n    # self.on_close = None\n\n    self._host_map = host_map\n    self._layer_dict = layer_dict\n    if not host_map:\n        raise ValueError(\n            f\"Must pass a valid map when creating a {self.__class__.__name__} widget.\"\n        )\n\n    self._toggle_button = ipywidgets.ToggleButton(\n        value=True,\n        tooltip=\"Layer editor\",\n        icon=\"gear\",\n        layout=ipywidgets.Layout(\n            width=\"28px\", height=\"28px\", padding=\"0px 0 0 3px\"\n        ),\n    )\n    self._toggle_button.observe(self._on_toggle_click, \"value\")\n\n    self._close_button = ipywidgets.Button(\n        tooltip=\"Close the vis params dialog\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=ipywidgets.Layout(width=\"28px\", height=\"28px\", padding=\"0\"),\n    )\n    self._close_button.on_click(self._on_close_click)\n\n    layout = ipywidgets.Layout(width=\"95px\")\n    self._import_button = ipywidgets.Button(\n        description=\"Import\",\n        # button_style=\"primary\",\n        tooltip=\"Import vis params to notebook\",\n        layout=layout,\n    )\n    self._apply_button = ipywidgets.Button(\n        description=\"Apply\", tooltip=\"Apply vis params to the layer\", layout=layout\n    )\n\n    self._layer_spinner = ipywidgets.Button(\n        icon=\"check\",\n        layout=ipywidgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px\"),\n        tooltip=\"Loaded\",\n    )\n\n    def loading_change(change):\n        if change[\"new\"]:\n            self._layer_spinner.tooltip = \"Loading ...\"\n            self._layer_spinner.icon = \"spinner spin lg\"\n        else:\n            self._layer_spinner.tooltip = \"Loaded\"\n            self._layer_spinner.icon = \"check\"\n\n    self._import_button.on_click(self._on_import_click)\n    self._apply_button.on_click(self._on_apply_click)\n\n    self._label = ipywidgets.Label(\n        value=layer_dict[\"layer_name\"],\n        layout=ipywidgets.Layout(max_width=\"200px\", padding=\"1px 4px 0 4px\"),\n    )\n    self._embedded_widget = ipywidgets.Label(value=\"Vis params are uneditable\")\n    if layer_dict is not None:\n        if layer_dict[\"type\"] in [\"LOCAL\", \"COG\", \"STAC\", \"XARRAY\"]:\n            self._embedded_widget = RasterLayerEditor(\n                host_map=host_map, layer_dict=layer_dict\n            )\n\n            layer_dict[\"tile_layer\"].observe(loading_change, \"loading\")\n\n    super().__init__(children=[])\n    self._on_toggle_click({\"new\": True})\n</code></pre>"},{"location":"map_widgets/#beamgis.map_widgets.Legend","title":"<code> Legend            (VBox)         </code>","text":"<p>A legend widget that can be added to the map.</p> Source code in <code>beamgis/map_widgets.py</code> <pre><code>class Legend(ipywidgets.VBox):\n    \"\"\"A legend widget that can be added to the map.\"\"\"\n\n    ALLOWED_POSITIONS = [\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"]\n    DEFAULT_COLORS = [\"#8DD3C7\", \"#FFFFB3\", \"#BEBADA\", \"#FB8072\", \"#80B1D3\"]\n    DEFAULT_KEYS = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"]\n    DEFAULT_MAX_HEIGHT = \"400px\"\n    DEFAULT_MAX_WIDTH = \"300px\"\n\n    def __init__(\n        self,\n        title=\"Legend\",\n        legend_dict=None,\n        keys=None,\n        colors=None,\n        position=\"bottomright\",\n        builtin_legend=None,\n        add_header=True,\n        shape_type=\"rectangle\",\n        widget_args={},\n        **kwargs,\n    ):\n        \"\"\"Adds a customized legend to the map.\n\n         Args:\n            title (str, optional): Title of the legend. Defaults to 'Legend'.\n            legend_dict (dict, optional): A dictionary containing legend items\n                as keys and color as values. If provided, keys and colors will\n                be ignored. Defaults to None.\n            keys (list, optional): A list of legend keys. Defaults to None.\n            colors (list, optional): A list of legend colors. Defaults to None.\n            position (str, optional): Position of the legend. Defaults to\n                'bottomright'.\n            builtin_legend (str, optional): Name of the builtin legend to add\n                to the map. Defaults to None.\n            add_header (bool, optional): Whether the legend can be closed or\n                not. Defaults to True.\n            shape_type (str, optional): The shape type of the legend item.\n            widget_args (dict, optional): Additional arguments passed to the\n                widget_template() function. Defaults to {}.\n\n        Raises:\n            TypeError: If the keys are not a list.\n            TypeError: If the colors are not list.\n            TypeError: If the colors are not a list of tuples.\n            TypeError: If the legend_dict is not a dictionary.\n            ValueError: If the legend template does not exist.\n            ValueError: If a rgb value cannot to be converted to hex.\n            ValueError: If the keys and colors are not the same length.\n            ValueError: If the builtin_legend is not allowed.\n            ValueError: If the position is not allowed.\n\n        \"\"\"\n        import os  # pylint: disable=import-outside-toplevel\n        from IPython.display import display  # pylint: disable=import-outside-toplevel\n        import importlib.resources  # pylint: disable=import-outside-toplevel\n        from .legends import builtin_legends  # pylint: disable=import-outside-toplevel\n\n        pkg_dir = os.path.dirname(importlib.resources.files(\"leafmap\") / \"leafmap.py\")\n        legend_template = os.path.join(pkg_dir, \"data/template/legend.html\")\n\n        if not os.path.exists(legend_template):\n            raise ValueError(\"The legend template does not exist.\")\n\n        if \"labels\" in kwargs:\n            keys = kwargs[\"labels\"]\n            kwargs.pop(\"labels\")\n\n        if keys is not None:\n            if not isinstance(keys, list):\n                raise TypeError(\"The legend keys must be a list.\")\n        else:\n            keys = Legend.DEFAULT_KEYS\n\n        if colors is not None:\n            if not isinstance(colors, list):\n                raise TypeError(\"The legend colors must be a list.\")\n            elif all(isinstance(item, tuple) for item in colors):\n                colors = Legend.__convert_rgb_colors_to_hex(colors)\n            elif all((item.startswith(\"#\") and len(item) == 7) for item in colors):\n                pass\n            elif all((len(item) == 6) for item in colors):\n                pass\n            else:\n                raise TypeError(\"The legend colors must be a list of tuples.\")\n        else:\n            colors = Legend.DEFAULT_COLORS\n\n        if len(keys) != len(colors):\n            raise ValueError(\"The legend keys and colors must be the same length.\")\n\n        allowed_builtin_legends = builtin_legends.keys()\n        if builtin_legend is not None:\n            builtin_legend_allowed = Legend.__check_if_allowed(\n                builtin_legend, \"builtin legend\", allowed_builtin_legends\n            )\n            if builtin_legend_allowed:\n                legend_dict = builtin_legends[builtin_legend]\n                keys = list(legend_dict.keys())\n                colors = list(legend_dict.values())\n\n        if legend_dict is not None:\n            if not isinstance(legend_dict, dict):\n                raise TypeError(\"The legend dict must be a dictionary.\")\n            else:\n                keys = list(legend_dict.keys())\n                colors = list(legend_dict.values())\n                if all(isinstance(item, tuple) for item in colors):\n                    colors = Legend.__convert_rgb_colors_to_hex(colors)\n\n        Legend.__check_if_allowed(position, \"position\", Legend.ALLOWED_POSITIONS)\n\n        header = []\n        footer = []\n        content = Legend.__create_legend_items(keys, colors)\n\n        with open(legend_template) as f:\n            lines = f.readlines()\n            lines[3] = lines[3].replace(\"Legend\", title)\n            header = lines[:6]\n            footer = lines[11:]\n\n        legend_html = header + content + footer\n        legend_text = \"\".join(legend_html)\n\n        if shape_type == \"circle\":\n            legend_text = legend_text.replace(\"width: 30px\", \"width: 16px\")\n            legend_text = legend_text.replace(\n                \"border: 1px solid #999;\",\n                \"border-radius: 50%;\\n      border: 1px solid #999;\",\n            )\n        elif shape_type == \"line\":\n            legend_text = legend_text.replace(\"height: 16px\", \"height: 3px\")\n        legend_output = ipywidgets.Output(layout=Legend.__create_layout(**kwargs))\n        legend_widget = ipywidgets.HTML(value=legend_text)\n\n        if add_header:\n            if \"show_close_button\" not in widget_args:\n                widget_args[\"show_close_button\"] = False\n            if \"widget_icon\" not in widget_args:\n                widget_args[\"widget_icon\"] = \"bars\"\n\n            legend_output_widget = common.widget_template(\n                legend_output,\n                position=position,\n                display_widget=legend_widget,\n                **widget_args,\n            )\n        else:\n            legend_output_widget = legend_widget\n\n        super().__init__(children=[legend_output_widget])\n\n        legend_output.clear_output()\n        with legend_output:\n            display(legend_widget)\n\n    def __check_if_allowed(value, value_name, allowed_list):  # pylint: disable=E0213\n        if value not in allowed_list:\n            raise ValueError(\n                \"The \"\n                + value_name\n                + \" must be one of the following: {}.\".format(\", \".join(allowed_list))\n            )\n        return True\n\n    def __convert_rgb_colors_to_hex(colors):  # pylint: disable=E0213\n        try:\n            return [common.rgb_to_hex(x) for x in colors]\n        except:\n            raise ValueError(\"Unable to convert rgb value to hex.\")\n\n    def __create_legend_items(keys, colors):  # pylint: disable=E0213\n        legend_items = []\n        for index, key in enumerate(keys):\n            color = colors[index]\n            if not color.startswith(\"#\"):\n                color = \"#\" + color\n            item = \"&lt;li&gt;&lt;span style='background:{};'&gt;&lt;/span&gt;{}&lt;/li&gt;\\n\".format(\n                color, key\n            )\n            legend_items.append(item)\n        return legend_items\n\n    def __create_layout(**kwargs):  # pylint: disable=E0213\n        height = Legend.__create_layout_property(\"height\", None, **kwargs)\n\n        min_height = Legend.__create_layout_property(\"min_height\", None, **kwargs)\n\n        if height is None:\n            max_height = Legend.DEFAULT_MAX_HEIGHT\n        else:\n            max_height = Legend.__create_layout_property(\"max_height\", None, **kwargs)\n\n        width = Legend.__create_layout_property(\"width\", None, **kwargs)\n\n        if \"min_width\" not in kwargs:\n            min_width = None\n\n        if width is None:\n            max_width = Legend.DEFAULT_MAX_WIDTH\n        else:\n            max_width = Legend.__create_layout_property(\n                \"max_width\", Legend.DEFAULT_MAX_WIDTH, **kwargs\n            )\n\n        return {\n            \"height\": height,\n            \"max_height\": max_height,\n            \"max_width\": max_width,\n            \"min_height\": min_height,\n            \"min_width\": min_width,\n            \"overflow\": \"scroll\",\n            \"width\": width,\n        }\n\n    def __create_layout_property(name, default_value, **kwargs):\n        return default_value if name not in kwargs else kwargs[name]\n</code></pre>"},{"location":"map_widgets/#beamgis.map_widgets.Legend.__init__","title":"<code>__init__(self, title='Legend', legend_dict=None, keys=None, colors=None, position='bottomright', builtin_legend=None, add_header=True, shape_type='rectangle', widget_args={}, **kwargs)</code>  <code>special</code>","text":"<p>Adds a customized legend to the map.</p> <p>Args:     title (str, optional): Title of the legend. Defaults to 'Legend'.     legend_dict (dict, optional): A dictionary containing legend items         as keys and color as values. If provided, keys and colors will         be ignored. Defaults to None.     keys (list, optional): A list of legend keys. Defaults to None.     colors (list, optional): A list of legend colors. Defaults to None.     position (str, optional): Position of the legend. Defaults to         'bottomright'.     builtin_legend (str, optional): Name of the builtin legend to add         to the map. Defaults to None.     add_header (bool, optional): Whether the legend can be closed or         not. Defaults to True.     shape_type (str, optional): The shape type of the legend item.     widget_args (dict, optional): Additional arguments passed to the         widget_template() function. Defaults to {}.</p> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If the keys are not a list.</p> <code>TypeError</code> <p>If the colors are not list.</p> <code>TypeError</code> <p>If the colors are not a list of tuples.</p> <code>TypeError</code> <p>If the legend_dict is not a dictionary.</p> <code>ValueError</code> <p>If the legend template does not exist.</p> <code>ValueError</code> <p>If a rgb value cannot to be converted to hex.</p> <code>ValueError</code> <p>If the keys and colors are not the same length.</p> <code>ValueError</code> <p>If the builtin_legend is not allowed.</p> <code>ValueError</code> <p>If the position is not allowed.</p> Source code in <code>beamgis/map_widgets.py</code> <pre><code>def __init__(\n    self,\n    title=\"Legend\",\n    legend_dict=None,\n    keys=None,\n    colors=None,\n    position=\"bottomright\",\n    builtin_legend=None,\n    add_header=True,\n    shape_type=\"rectangle\",\n    widget_args={},\n    **kwargs,\n):\n    \"\"\"Adds a customized legend to the map.\n\n     Args:\n        title (str, optional): Title of the legend. Defaults to 'Legend'.\n        legend_dict (dict, optional): A dictionary containing legend items\n            as keys and color as values. If provided, keys and colors will\n            be ignored. Defaults to None.\n        keys (list, optional): A list of legend keys. Defaults to None.\n        colors (list, optional): A list of legend colors. Defaults to None.\n        position (str, optional): Position of the legend. Defaults to\n            'bottomright'.\n        builtin_legend (str, optional): Name of the builtin legend to add\n            to the map. Defaults to None.\n        add_header (bool, optional): Whether the legend can be closed or\n            not. Defaults to True.\n        shape_type (str, optional): The shape type of the legend item.\n        widget_args (dict, optional): Additional arguments passed to the\n            widget_template() function. Defaults to {}.\n\n    Raises:\n        TypeError: If the keys are not a list.\n        TypeError: If the colors are not list.\n        TypeError: If the colors are not a list of tuples.\n        TypeError: If the legend_dict is not a dictionary.\n        ValueError: If the legend template does not exist.\n        ValueError: If a rgb value cannot to be converted to hex.\n        ValueError: If the keys and colors are not the same length.\n        ValueError: If the builtin_legend is not allowed.\n        ValueError: If the position is not allowed.\n\n    \"\"\"\n    import os  # pylint: disable=import-outside-toplevel\n    from IPython.display import display  # pylint: disable=import-outside-toplevel\n    import importlib.resources  # pylint: disable=import-outside-toplevel\n    from .legends import builtin_legends  # pylint: disable=import-outside-toplevel\n\n    pkg_dir = os.path.dirname(importlib.resources.files(\"leafmap\") / \"leafmap.py\")\n    legend_template = os.path.join(pkg_dir, \"data/template/legend.html\")\n\n    if not os.path.exists(legend_template):\n        raise ValueError(\"The legend template does not exist.\")\n\n    if \"labels\" in kwargs:\n        keys = kwargs[\"labels\"]\n        kwargs.pop(\"labels\")\n\n    if keys is not None:\n        if not isinstance(keys, list):\n            raise TypeError(\"The legend keys must be a list.\")\n    else:\n        keys = Legend.DEFAULT_KEYS\n\n    if colors is not None:\n        if not isinstance(colors, list):\n            raise TypeError(\"The legend colors must be a list.\")\n        elif all(isinstance(item, tuple) for item in colors):\n            colors = Legend.__convert_rgb_colors_to_hex(colors)\n        elif all((item.startswith(\"#\") and len(item) == 7) for item in colors):\n            pass\n        elif all((len(item) == 6) for item in colors):\n            pass\n        else:\n            raise TypeError(\"The legend colors must be a list of tuples.\")\n    else:\n        colors = Legend.DEFAULT_COLORS\n\n    if len(keys) != len(colors):\n        raise ValueError(\"The legend keys and colors must be the same length.\")\n\n    allowed_builtin_legends = builtin_legends.keys()\n    if builtin_legend is not None:\n        builtin_legend_allowed = Legend.__check_if_allowed(\n            builtin_legend, \"builtin legend\", allowed_builtin_legends\n        )\n        if builtin_legend_allowed:\n            legend_dict = builtin_legends[builtin_legend]\n            keys = list(legend_dict.keys())\n            colors = list(legend_dict.values())\n\n    if legend_dict is not None:\n        if not isinstance(legend_dict, dict):\n            raise TypeError(\"The legend dict must be a dictionary.\")\n        else:\n            keys = list(legend_dict.keys())\n            colors = list(legend_dict.values())\n            if all(isinstance(item, tuple) for item in colors):\n                colors = Legend.__convert_rgb_colors_to_hex(colors)\n\n    Legend.__check_if_allowed(position, \"position\", Legend.ALLOWED_POSITIONS)\n\n    header = []\n    footer = []\n    content = Legend.__create_legend_items(keys, colors)\n\n    with open(legend_template) as f:\n        lines = f.readlines()\n        lines[3] = lines[3].replace(\"Legend\", title)\n        header = lines[:6]\n        footer = lines[11:]\n\n    legend_html = header + content + footer\n    legend_text = \"\".join(legend_html)\n\n    if shape_type == \"circle\":\n        legend_text = legend_text.replace(\"width: 30px\", \"width: 16px\")\n        legend_text = legend_text.replace(\n            \"border: 1px solid #999;\",\n            \"border-radius: 50%;\\n      border: 1px solid #999;\",\n        )\n    elif shape_type == \"line\":\n        legend_text = legend_text.replace(\"height: 16px\", \"height: 3px\")\n    legend_output = ipywidgets.Output(layout=Legend.__create_layout(**kwargs))\n    legend_widget = ipywidgets.HTML(value=legend_text)\n\n    if add_header:\n        if \"show_close_button\" not in widget_args:\n            widget_args[\"show_close_button\"] = False\n        if \"widget_icon\" not in widget_args:\n            widget_args[\"widget_icon\"] = \"bars\"\n\n        legend_output_widget = common.widget_template(\n            legend_output,\n            position=position,\n            display_widget=legend_widget,\n            **widget_args,\n        )\n    else:\n        legend_output_widget = legend_widget\n\n    super().__init__(children=[legend_output_widget])\n\n    legend_output.clear_output()\n    with legend_output:\n        display(legend_widget)\n</code></pre>"},{"location":"map_widgets/#beamgis.map_widgets.RasterLayerEditor","title":"<code> RasterLayerEditor            (VBox)         </code>","text":"<p>Widget for displaying and editing layer visualization properties for raster layers.</p> Source code in <code>beamgis/map_widgets.py</code> <pre><code>class RasterLayerEditor(ipywidgets.VBox):\n    \"\"\"Widget for displaying and editing layer visualization properties for raster layers.\"\"\"\n\n    def __init__(self, host_map, layer_dict):\n        \"\"\"Initializes a raster layer editor widget.\n\n        Args:\n            host_map (geemap.Map): The geemap.Map object.\n            layer_dict (dict): The layer object to edit.\n        \"\"\"\n        self._host_map = host_map\n        self._layer_dict = layer_dict\n\n        self._layer_name = self._layer_dict[\"layer_name\"]\n        self._layer_opacity = self._layer_dict[\"opacity\"]\n        self._min_value = self._layer_dict[\"vmin\"]\n        self._max_value = self._layer_dict[\"vmax\"]\n        self._band_indexes = self._layer_dict[\"indexes\"]\n        self._nodata = self._layer_dict[\"nodata\"]\n\n        if self._layer_dict[\"type\"] == \"LOCAL\":\n            self._tile_client = self._layer_dict[\"tile_client\"]\n            self._filename = self._layer_dict[\"filename\"]\n        if \"xds\" in self._layer_dict:\n            self._xds = self._layer_dict[\"xds\"]\n        else:\n            self._xds = None\n\n        if self._min_value is None or self._max_value is None:\n            try:\n                self._min_value, self._max_value = common.image_min_max(\n                    self._filename, self._band_indexes\n                )\n            except Exception as e:\n                self._min_value = 0\n                self._max_value = 1\n\n        self._sel_bands = self._layer_dict[\"vis_bands\"]\n        self._layer_palette = []\n        self._layer_gamma = 1\n        self._left_value = min(self._min_value, 0)\n        self._right_value = self._max_value * 1.5\n\n        band_names = self._layer_dict[\"band_names\"]\n        self._band_count = len(band_names)\n\n        self._greyscale_radio_button = ipywidgets.RadioButtons(\n            options=[\"1 band (Grayscale)\"],\n            layout={\"width\": \"max-content\", \"margin\": \"0 15px 0 0\"},\n        )\n        self._rgb_radio_button = ipywidgets.RadioButtons(\n            options=[\"3 bands (RGB)\"], layout={\"width\": \"max-content\"}\n        )\n        self._greyscale_radio_button.index = None\n        self._rgb_radio_button.index = None\n\n        band_dropdown_layout = ipywidgets.Layout(width=\"98px\")\n        self._band_1_dropdown = ipywidgets.Dropdown(\n            options=band_names, value=band_names[0], layout=band_dropdown_layout\n        )\n        self._band_2_dropdown = ipywidgets.Dropdown(\n            options=band_names, value=band_names[0], layout=band_dropdown_layout\n        )\n        self._band_3_dropdown = ipywidgets.Dropdown(\n            options=band_names, value=band_names[0], layout=band_dropdown_layout\n        )\n        self._bands_hbox = ipywidgets.HBox(layout=ipywidgets.Layout(margin=\"0 0 6px 0\"))\n\n        self._color_picker = ipywidgets.ColorPicker(\n            concise=False,\n            value=\"#000000\",\n            layout=ipywidgets.Layout(width=\"116px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        self._add_color_button = ipywidgets.Button(\n            icon=\"plus\",\n            tooltip=\"Add a hex color string to the palette\",\n            layout=ipywidgets.Layout(width=\"32px\"),\n        )\n        self._del_color_button = ipywidgets.Button(\n            icon=\"minus\",\n            tooltip=\"Remove a hex color string from the palette\",\n            layout=ipywidgets.Layout(width=\"32px\"),\n        )\n        self._reset_color_button = ipywidgets.Button(\n            icon=\"eraser\",\n            tooltip=\"Remove all color strings from the palette\",\n            layout=ipywidgets.Layout(width=\"34px\"),\n        )\n        self._add_color_button.on_click(self._add_color_clicked)\n        self._del_color_button.on_click(self._del_color_clicked)\n        self._reset_color_button.on_click(self._reset_color_clicked)\n\n        self._classes_dropdown = ipywidgets.Dropdown(\n            options=[\"Any\"] + [str(i) for i in range(3, 13)],\n            description=\"Classes:\",\n            layout=ipywidgets.Layout(width=\"115px\"),\n            style={\"description_width\": \"initial\"},\n        )\n        self._classes_dropdown.observe(self._classes_changed, \"value\")\n\n        self._colormap_dropdown = ipywidgets.Dropdown(\n            options=self._get_colormaps(),\n            value=None,\n            description=\"Colormap:\",\n            layout=ipywidgets.Layout(width=\"300px\"),\n            style={\"description_width\": \"initial\"},\n        )\n        self._colormap_dropdown.observe(self._colormap_changed, \"value\")\n\n        self._palette_label = ipywidgets.Text(\n            value=\", \".join(self._layer_palette),\n            placeholder=\"List of hex color code (RRGGBB)\",\n            description=\"Palette:\",\n            tooltip=\"Enter a list of hex color code (RRGGBB)\",\n            layout=ipywidgets.Layout(width=\"300px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        self._value_range_slider = ipywidgets.FloatRangeSlider(\n            value=[self._min_value, self._max_value],\n            min=self._left_value,\n            max=self._right_value,\n            step=(self._right_value - self._left_value) / 100,\n            description=\"Range:\",\n            disabled=False,\n            continuous_update=False,\n            readout=True,\n            readout_format=\".2f\",\n            layout=ipywidgets.Layout(width=\"300px\"),\n            style={\"description_width\": \"45px\"},\n        )\n\n        self._opacity_slider = ipywidgets.FloatSlider(\n            value=self._layer_opacity,\n            min=0,\n            max=1,\n            step=0.01,\n            description=\"Opacity:\",\n            continuous_update=False,\n            readout=True,\n            readout_format=\".2f\",\n            layout=ipywidgets.Layout(width=\"310px\"),\n            style={\"description_width\": \"50px\"},\n        )\n\n        self._colorbar_output = ipywidgets.Output(\n            layout=ipywidgets.Layout(height=\"60px\", max_width=\"300px\")\n        )\n\n        children = []\n        if self._band_count &lt; 3:\n            self._greyscale_radio_button.index = 0\n            self._band_1_dropdown.layout.width = \"300px\"\n            self._bands_hbox.children = [self._band_1_dropdown]\n            children = self._get_tool_layout(grayscale=True)\n\n            if len(self._palette_label.value) &gt; 0 and \",\" in self._palette_label.value:\n                colors = common.to_hex_colors(\n                    [color.strip() for color in self._palette_label.value.split(\",\")]\n                )\n                self._render_colorbar(colors)\n        else:\n            self._rgb_radio_button.index = 0\n            sel_bands = self._sel_bands\n            if (sel_bands is None) or (len(sel_bands) &lt; 2):\n                sel_bands = band_names[0:3]\n            self._band_1_dropdown.value = sel_bands[0]\n            self._band_2_dropdown.value = sel_bands[1]\n            self._band_3_dropdown.value = sel_bands[2]\n            self._bands_hbox.children = [\n                self._band_1_dropdown,\n                self._band_2_dropdown,\n                self._band_3_dropdown,\n            ]\n            children = self._get_tool_layout(grayscale=False)\n\n        self._greyscale_radio_button.observe(self._radio1_observer, names=[\"value\"])\n        self._rgb_radio_button.observe(self._radio2_observer, names=[\"value\"])\n\n        super().__init__(\n            layout=ipywidgets.Layout(\n                padding=\"5px 0px 5px 8px\",  # top, right, bottom, left\n                # width=\"330px\",\n                max_height=\"305px\",\n                overflow=\"auto\",\n                display=\"block\",\n            ),\n            children=children,\n        )\n\n    def _get_tool_layout(self, grayscale):\n        return [\n            ipywidgets.HBox([self._greyscale_radio_button, self._rgb_radio_button]),\n            self._bands_hbox,\n            self._value_range_slider,\n            self._opacity_slider,\n        ] + (\n            [\n                self._colormap_dropdown,\n                # self._palette_label,\n                self._colorbar_output,\n                # ipywidgets.HBox(\n                #     [\n                #         self._color_picker,\n                #         self._add_color_button,\n                #         self._del_color_button,\n                #         self._reset_color_button,\n                #     ]\n                # ),\n            ]\n            if grayscale\n            else []\n        )\n\n    def _get_colormaps(self):\n        from matplotlib import pyplot  # pylint: disable=import-outside-toplevel\n\n        colormap_options = pyplot.colormaps()\n        colormap_options = [\n            item\n            for item in colormap_options\n            if not (item[0].isupper() or \"cet\" in item.lower())\n        ]\n        colormap_options.sort()\n        return colormap_options\n\n    def _render_colorbar(self, colors):\n        import matplotlib  # pylint: disable=import-outside-toplevel\n        from matplotlib import pyplot  # pylint: disable=import-outside-toplevel\n\n        colors = common.to_hex_colors(colors)\n\n        _, ax = pyplot.subplots(figsize=(4, 0.3))\n        cmap = matplotlib.colors.LinearSegmentedColormap.from_list(\n            \"custom\", colors, N=256\n        )\n        norm = matplotlib.colors.Normalize(\n            vmin=self._value_range_slider.value[0],\n            vmax=self._value_range_slider.value[1],\n        )\n        matplotlib.colorbar.ColorbarBase(\n            ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n        )\n\n        self._palette_label.value = \", \".join(colors)\n\n        self._colorbar_output.clear_output()\n        with self._colorbar_output:\n            pyplot.show()\n\n    def _classes_changed(self, change):\n        import matplotlib  # pylint: disable=import-outside-toplevel\n        from matplotlib import pyplot  # pylint: disable=import-outside-toplevel\n\n        if not change[\"new\"]:\n            return\n\n        selected = change[\"owner\"].value\n        if self._colormap_dropdown.value is not None:\n            n_class = None\n            if selected != \"Any\":\n                n_class = int(self._classes_dropdown.value)\n\n            colors = pyplot.get_cmap(self._colormap_dropdown.value, n_class)\n            cmap_colors = [\n                matplotlib.colors.rgb2hex(colors(i))[1:] for i in range(colors.N)\n            ]\n            self._render_colorbar(cmap_colors)\n\n            if len(self._palette_label.value) &gt; 0 and \",\" in self._palette_label.value:\n                labels = [\n                    f\"Class {i+1}\"\n                    for i in range(len(self._palette_label.value.split(\",\")))\n                ]\n\n    def _add_color_clicked(self, _):\n        if self._color_picker.value is not None:\n            if len(self._palette_label.value) == 0:\n                self._palette_label.value = self._color_picker.value\n            else:\n                self._palette_label.value += \", \" + self._color_picker.value\n\n    def _del_color_clicked(self, _):\n        if \",\" in self._palette_label.value:\n            items = [item.strip() for item in self._palette_label.value.split(\",\")]\n            self._palette_label.value = \", \".join(items[:-1])\n        else:\n            self._palette_label.value = \"\"\n\n    def _reset_color_clicked(self, _):\n        self._palette_label.value = \"\"\n\n    def _colormap_changed(self, change):\n        import matplotlib  # pylint: disable=import-outside-toplevel\n        from matplotlib import pyplot  # pylint: disable=import-outside-toplevel\n\n        if change[\"new\"]:\n            n_class = None\n            if self._classes_dropdown.value != \"Any\":\n                n_class = int(self._classes_dropdown.value)\n\n            colors = pyplot.get_cmap(self._colormap_dropdown.value, n_class)\n            cmap_colors = [\n                matplotlib.colors.rgb2hex(colors(i))[1:] for i in range(colors.N)\n            ]\n            self._render_colorbar(cmap_colors)\n\n            if len(self._palette_label.value) &gt; 0 and \",\" in self._palette_label.value:\n                labels = [\n                    f\"Class {i+1}\"\n                    for i in range(len(self._palette_label.value.split(\",\")))\n                ]\n\n    def on_import_click(self):\n        vis = {}\n        if self._greyscale_radio_button.index == 0:\n            vis[\"indexes\"] = [self._band_1_dropdown.index + 1]\n        else:\n            vis[\"indexes\"] = [\n                self._band_1_dropdown.index + 1,\n                self._band_2_dropdown.index + 1,\n                self._band_3_dropdown.index + 1,\n            ]\n            self._colormap_dropdown.value = None\n\n        vis[\"vmin\"] = self._value_range_slider.value[0]\n        vis[\"vmax\"] = self._value_range_slider.value[1]\n        vis[\"opacity\"] = self._opacity_slider.value\n        vis[\"colormap\"] = self._colormap_dropdown.value\n\n        if self._layer_dict[\"type\"] in [\"COG\", \"STAC\"]:\n            if self._layer_dict[\"type\"] == \"COG\":\n                vis[\"bidx\"] = vis[\"indexes\"]\n                if len(vis[\"bidx\"]) == 1:\n                    vis[\"colormap_name\"] = vis[\"colormap\"]\n            elif self._layer_dict[\"type\"] == \"STAC\":\n                vis[\"assets\"] = self._layer_dict[\"assets\"]\n                if len(vis[\"assets\"]) == 1:\n                    vis[\"colormap_name\"] = vis[\"colormap\"]\n            vis[\"rescale\"] = f'{vis[\"vmin\"]},{vis[\"vmax\"]}'\n            vis.pop(\"vmin\", None)\n            vis.pop(\"vmax\", None)\n            vis.pop(\"indexes\", None)\n            vis.pop(\"colormap\", None)\n\n        if \"colormap\" in vis and vis[\"colormap\"] is None:\n            vis.pop(\"colormap\", None)\n        common.create_code_cell(f\"vis_params = {str(vis)}\")\n        print(f\"vis_params = {str(vis)}\")\n\n    def on_apply_click(self):\n        from rio_tiler.colormap import cmap\n\n        vis = {}\n        if self._greyscale_radio_button.index == 0:\n            vis[\"indexes\"] = [self._band_1_dropdown.index + 1]\n        else:\n            vis[\"indexes\"] = [\n                self._band_1_dropdown.index + 1,\n                self._band_2_dropdown.index + 1,\n                self._band_3_dropdown.index + 1,\n            ]\n            self._colormap_dropdown.value = None\n\n        vis[\"vmin\"] = self._value_range_slider.value[0]\n        vis[\"vmax\"] = self._value_range_slider.value[1]\n        vis[\"opacity\"] = self._opacity_slider.value\n        vis[\"colormap\"] = self._colormap_dropdown.value\n\n        if vis[\"colormap\"] is not None:\n            try:\n                cmap.get(vis[\"colormap\"])\n            except:\n                vis[\"colormap\"] = \"gray\"\n                self._colormap_dropdown.value = \"gray\"\n\n        old_layer = self._host_map.find_layer(self._layer_name)\n        layer_index = self._host_map.find_layer_index(self._layer_name)\n\n        self._host_map.remove(old_layer)\n\n        # Add support for hyperspectral data via HyperCoast\n        if self._xds is not None:\n\n            r_index = self._band_1_dropdown.index\n            g_index = self._band_2_dropdown.index\n            b_index = self._band_3_dropdown.index\n\n            if (r_index &gt;= g_index and g_index &gt;= b_index) or (\n                r_index &lt;= g_index and g_index &lt;= b_index\n            ):\n                pass\n            else:\n                sorted_indexes = sorted([r_index, g_index, b_index], reverse=True)\n                self._band_1_dropdown.index = sorted_indexes[0]\n                self._band_2_dropdown.index = sorted_indexes[1]\n                self._band_3_dropdown.index = sorted_indexes[2]\n                vis[\"indexes\"] = [\n                    self._band_1_dropdown.index + 1,\n                    self._band_2_dropdown.index + 1,\n                    self._band_3_dropdown.index + 1,\n                ]\n            self._host_map.add_hyper(\n                self._xds,\n                dtype=self._layer_dict[\"hyper\"],\n                wvl_indexes=[index - 1 for index in vis[\"indexes\"]],\n                colormap=vis[\"colormap\"],\n                vmin=vis[\"vmin\"],\n                vmax=vis[\"vmax\"],\n                opacity=vis[\"opacity\"],\n                nodata=self._nodata,\n                layer_name=self._layer_name,\n                zoom_to_layer=False,\n                layer_index=layer_index,\n            )\n\n        elif self._layer_dict[\"type\"] == \"LOCAL\":\n            self._host_map.add_raster(\n                self._filename,\n                indexes=vis[\"indexes\"],\n                colormap=vis[\"colormap\"],\n                vmin=vis[\"vmin\"],\n                vmax=vis[\"vmax\"],\n                opacity=vis[\"opacity\"],\n                nodata=self._nodata,\n                layer_name=self._layer_name,\n                zoom_to_layer=False,\n                layer_index=layer_index,\n            )\n\n        elif self._layer_dict[\"type\"] == \"COG\":\n            self._host_map.add_cog_layer(\n                self._layer_dict[\"url\"],\n                bidx=vis[\"indexes\"],\n                colormap_name=vis[\"colormap\"],\n                rescale=f'{vis[\"vmin\"]},{vis[\"vmax\"]}',\n                opacity=vis[\"opacity\"],\n                name=self._layer_name,\n                zoom_to_layer=False,\n                layer_index=layer_index,\n            )\n        elif self._layer_dict[\"type\"] == \"STAC\":\n            self._host_map.add_stac_layer(\n                self._layer_dict[\"url\"],\n                titiler_endpoint=self._layer_dict[\"titiler_endpoint\"],\n                collection=self._layer_dict[\"collection\"],\n                item=self._layer_dict[\"item\"],\n                assets=[self._layer_dict[\"band_names\"][i - 1] for i in vis[\"indexes\"]],\n                colormap_name=vis[\"colormap\"],\n                rescale=f'{vis[\"vmin\"]},{vis[\"vmax\"]}',\n                opacity=vis[\"opacity\"],\n                name=self._layer_name,\n                fit_bounds=False,\n                layer_index=layer_index,\n            )\n\n        def _remove_control(key):\n            if widget := self._layer_dict.get(key, None):\n                if widget in self._host_map.controls:\n                    self._host_map.remove(widget)\n                del self._layer_dict[key]\n\n    def _radio1_observer(self, _):\n        self._rgb_radio_button.unobserve(self._radio2_observer, names=[\"value\"])\n        self._rgb_radio_button.index = None\n        self._rgb_radio_button.observe(self._radio2_observer, names=[\"value\"])\n        self._band_1_dropdown.layout.width = \"300px\"\n        self._colormap_dropdown.value = \"gray\"\n        self._bands_hbox.children = [self._band_1_dropdown]\n        self._palette_label.value = \", \".join(self._layer_palette)\n        self._palette_label.disabled = False\n        self._color_picker.disabled = False\n        self._add_color_button.disabled = False\n        self._del_color_button.disabled = False\n        self._reset_color_button.disabled = False\n        self.children = self._get_tool_layout(grayscale=True)\n\n        if len(self._palette_label.value) &gt; 0 and \",\" in self._palette_label.value:\n            colors = [color.strip() for color in self._palette_label.value.split(\",\")]\n            self._render_colorbar(colors)\n\n    def _radio2_observer(self, _):\n        dropdown_width = \"98px\"\n        self._greyscale_radio_button.unobserve(self._radio1_observer, names=[\"value\"])\n        self._greyscale_radio_button.index = None\n        self._greyscale_radio_button.observe(self._radio1_observer, names=[\"value\"])\n        self._band_1_dropdown.layout.width = dropdown_width\n        self._colormap_dropdown.value = None\n        self._bands_hbox.children = [\n            self._band_1_dropdown,\n            self._band_2_dropdown,\n            self._band_3_dropdown,\n        ]\n        self._palette_label.value = \"\"\n        self._palette_label.disabled = True\n        self._color_picker.disabled = True\n        self._add_color_button.disabled = True\n        self._del_color_button.disabled = True\n        self._reset_color_button.disabled = True\n        self.children = self._get_tool_layout(grayscale=False)\n        self._colorbar_output.clear_output()\n</code></pre>"},{"location":"map_widgets/#beamgis.map_widgets.RasterLayerEditor.__init__","title":"<code>__init__(self, host_map, layer_dict)</code>  <code>special</code>","text":"<p>Initializes a raster layer editor widget.</p> <p>Parameters:</p> Name Type Description Default <code>host_map</code> <code>geemap.Map</code> <p>The geemap.Map object.</p> required <code>layer_dict</code> <code>dict</code> <p>The layer object to edit.</p> required Source code in <code>beamgis/map_widgets.py</code> <pre><code>def __init__(self, host_map, layer_dict):\n    \"\"\"Initializes a raster layer editor widget.\n\n    Args:\n        host_map (geemap.Map): The geemap.Map object.\n        layer_dict (dict): The layer object to edit.\n    \"\"\"\n    self._host_map = host_map\n    self._layer_dict = layer_dict\n\n    self._layer_name = self._layer_dict[\"layer_name\"]\n    self._layer_opacity = self._layer_dict[\"opacity\"]\n    self._min_value = self._layer_dict[\"vmin\"]\n    self._max_value = self._layer_dict[\"vmax\"]\n    self._band_indexes = self._layer_dict[\"indexes\"]\n    self._nodata = self._layer_dict[\"nodata\"]\n\n    if self._layer_dict[\"type\"] == \"LOCAL\":\n        self._tile_client = self._layer_dict[\"tile_client\"]\n        self._filename = self._layer_dict[\"filename\"]\n    if \"xds\" in self._layer_dict:\n        self._xds = self._layer_dict[\"xds\"]\n    else:\n        self._xds = None\n\n    if self._min_value is None or self._max_value is None:\n        try:\n            self._min_value, self._max_value = common.image_min_max(\n                self._filename, self._band_indexes\n            )\n        except Exception as e:\n            self._min_value = 0\n            self._max_value = 1\n\n    self._sel_bands = self._layer_dict[\"vis_bands\"]\n    self._layer_palette = []\n    self._layer_gamma = 1\n    self._left_value = min(self._min_value, 0)\n    self._right_value = self._max_value * 1.5\n\n    band_names = self._layer_dict[\"band_names\"]\n    self._band_count = len(band_names)\n\n    self._greyscale_radio_button = ipywidgets.RadioButtons(\n        options=[\"1 band (Grayscale)\"],\n        layout={\"width\": \"max-content\", \"margin\": \"0 15px 0 0\"},\n    )\n    self._rgb_radio_button = ipywidgets.RadioButtons(\n        options=[\"3 bands (RGB)\"], layout={\"width\": \"max-content\"}\n    )\n    self._greyscale_radio_button.index = None\n    self._rgb_radio_button.index = None\n\n    band_dropdown_layout = ipywidgets.Layout(width=\"98px\")\n    self._band_1_dropdown = ipywidgets.Dropdown(\n        options=band_names, value=band_names[0], layout=band_dropdown_layout\n    )\n    self._band_2_dropdown = ipywidgets.Dropdown(\n        options=band_names, value=band_names[0], layout=band_dropdown_layout\n    )\n    self._band_3_dropdown = ipywidgets.Dropdown(\n        options=band_names, value=band_names[0], layout=band_dropdown_layout\n    )\n    self._bands_hbox = ipywidgets.HBox(layout=ipywidgets.Layout(margin=\"0 0 6px 0\"))\n\n    self._color_picker = ipywidgets.ColorPicker(\n        concise=False,\n        value=\"#000000\",\n        layout=ipywidgets.Layout(width=\"116px\"),\n        style={\"description_width\": \"initial\"},\n    )\n\n    self._add_color_button = ipywidgets.Button(\n        icon=\"plus\",\n        tooltip=\"Add a hex color string to the palette\",\n        layout=ipywidgets.Layout(width=\"32px\"),\n    )\n    self._del_color_button = ipywidgets.Button(\n        icon=\"minus\",\n        tooltip=\"Remove a hex color string from the palette\",\n        layout=ipywidgets.Layout(width=\"32px\"),\n    )\n    self._reset_color_button = ipywidgets.Button(\n        icon=\"eraser\",\n        tooltip=\"Remove all color strings from the palette\",\n        layout=ipywidgets.Layout(width=\"34px\"),\n    )\n    self._add_color_button.on_click(self._add_color_clicked)\n    self._del_color_button.on_click(self._del_color_clicked)\n    self._reset_color_button.on_click(self._reset_color_clicked)\n\n    self._classes_dropdown = ipywidgets.Dropdown(\n        options=[\"Any\"] + [str(i) for i in range(3, 13)],\n        description=\"Classes:\",\n        layout=ipywidgets.Layout(width=\"115px\"),\n        style={\"description_width\": \"initial\"},\n    )\n    self._classes_dropdown.observe(self._classes_changed, \"value\")\n\n    self._colormap_dropdown = ipywidgets.Dropdown(\n        options=self._get_colormaps(),\n        value=None,\n        description=\"Colormap:\",\n        layout=ipywidgets.Layout(width=\"300px\"),\n        style={\"description_width\": \"initial\"},\n    )\n    self._colormap_dropdown.observe(self._colormap_changed, \"value\")\n\n    self._palette_label = ipywidgets.Text(\n        value=\", \".join(self._layer_palette),\n        placeholder=\"List of hex color code (RRGGBB)\",\n        description=\"Palette:\",\n        tooltip=\"Enter a list of hex color code (RRGGBB)\",\n        layout=ipywidgets.Layout(width=\"300px\"),\n        style={\"description_width\": \"initial\"},\n    )\n\n    self._value_range_slider = ipywidgets.FloatRangeSlider(\n        value=[self._min_value, self._max_value],\n        min=self._left_value,\n        max=self._right_value,\n        step=(self._right_value - self._left_value) / 100,\n        description=\"Range:\",\n        disabled=False,\n        continuous_update=False,\n        readout=True,\n        readout_format=\".2f\",\n        layout=ipywidgets.Layout(width=\"300px\"),\n        style={\"description_width\": \"45px\"},\n    )\n\n    self._opacity_slider = ipywidgets.FloatSlider(\n        value=self._layer_opacity,\n        min=0,\n        max=1,\n        step=0.01,\n        description=\"Opacity:\",\n        continuous_update=False,\n        readout=True,\n        readout_format=\".2f\",\n        layout=ipywidgets.Layout(width=\"310px\"),\n        style={\"description_width\": \"50px\"},\n    )\n\n    self._colorbar_output = ipywidgets.Output(\n        layout=ipywidgets.Layout(height=\"60px\", max_width=\"300px\")\n    )\n\n    children = []\n    if self._band_count &lt; 3:\n        self._greyscale_radio_button.index = 0\n        self._band_1_dropdown.layout.width = \"300px\"\n        self._bands_hbox.children = [self._band_1_dropdown]\n        children = self._get_tool_layout(grayscale=True)\n\n        if len(self._palette_label.value) &gt; 0 and \",\" in self._palette_label.value:\n            colors = common.to_hex_colors(\n                [color.strip() for color in self._palette_label.value.split(\",\")]\n            )\n            self._render_colorbar(colors)\n    else:\n        self._rgb_radio_button.index = 0\n        sel_bands = self._sel_bands\n        if (sel_bands is None) or (len(sel_bands) &lt; 2):\n            sel_bands = band_names[0:3]\n        self._band_1_dropdown.value = sel_bands[0]\n        self._band_2_dropdown.value = sel_bands[1]\n        self._band_3_dropdown.value = sel_bands[2]\n        self._bands_hbox.children = [\n            self._band_1_dropdown,\n            self._band_2_dropdown,\n            self._band_3_dropdown,\n        ]\n        children = self._get_tool_layout(grayscale=False)\n\n    self._greyscale_radio_button.observe(self._radio1_observer, names=[\"value\"])\n    self._rgb_radio_button.observe(self._radio2_observer, names=[\"value\"])\n\n    super().__init__(\n        layout=ipywidgets.Layout(\n            padding=\"5px 0px 5px 8px\",  # top, right, bottom, left\n            # width=\"330px\",\n            max_height=\"305px\",\n            overflow=\"auto\",\n            display=\"block\",\n        ),\n        children=children,\n    )\n</code></pre>"},{"location":"pc/","title":"pc module","text":"<p>A module for Microsoft Planetary Computer (PC).</p>"},{"location":"pc/#beamgis.pc.get_bands","title":"<code>get_bands(collection, item=None)</code>","text":"<p>Get the bands of an item.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The collection the item is in.</p> required <code>item</code> <code>str</code> <p>The item to get the bands of.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of bands.</p> Source code in <code>beamgis/pc.py</code> <pre><code>def get_bands(collection: str, item: Optional[str] = None) -&gt; List[str]:\n    \"\"\"Get the bands of an item.\n\n    Args:\n        collection (str): The collection the item is in.\n        item (str): The item to get the bands of.\n\n    Returns:\n        list: A list of bands.\n    \"\"\"\n    if item is None:\n        item = get_first_item(collection, return_id=True)\n    return stac_bands(collection=collection, items=item)\n</code></pre>"},{"location":"pc/#beamgis.pc.get_first_item","title":"<code>get_first_item(collection, return_id=False)</code>","text":"<p>Get the first item in a collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The collection to get the first item from.</p> required <code>return_id</code> <code>bool</code> <p>If True, return the item's ID instead of the item itself.</p> <code>False</code> <p>Returns:</p> Type Description <code>pystac.Item</code> <p>The first item in the collection.</p> Source code in <code>beamgis/pc.py</code> <pre><code>def get_first_item(collection: str, return_id: Optional[bool] = False):\n    \"\"\"Get the first item in a collection.\n\n    Args:\n        collection (str): The collection to get the first item from.\n        return_id (bool, optional): If True, return the item's ID instead of the item itself.\n\n    Returns:\n        pystac.Item: The first item in the collection.\n    \"\"\"\n    catalog = Client.open(PC_ENDPOINT)\n    col = catalog.get_child(collection)\n    item = next(col.get_items())\n    if return_id:\n        return item.id\n    else:\n        return item\n</code></pre>"},{"location":"pc/#beamgis.pc.get_pc_collection_list","title":"<code>get_pc_collection_list()</code>","text":"<p>Get a list of collections in the Microsoft Planetary Computer catalog.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of collections.</p> Source code in <code>beamgis/pc.py</code> <pre><code>def get_pc_collection_list() -&gt; List[str]:\n    \"\"\"Get a list of collections in the Microsoft Planetary Computer catalog.\n\n    Returns:\n        list: A list of collections.\n    \"\"\"\n    inventory = get_pc_inventory()\n\n    names = []\n\n    for key in inventory:\n        names.append(f\"{key} - {inventory[key]['title']}\")\n    names.sort()\n\n    return names\n</code></pre>"},{"location":"pc/#beamgis.pc.get_pc_collections","title":"<code>get_pc_collections(verbose=False)</code>","text":"<p>Get a list of all collections in the Microsoft Planetary Computer catalog.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, print the collections to the console.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with collections IDs as keys and cllection titles as value.</p> Source code in <code>beamgis/pc.py</code> <pre><code>def get_pc_collections(verbose: Optional[bool] = False) -&gt; dict[str, str]:\n    \"\"\"Get a list of all collections in the Microsoft Planetary Computer catalog.\n\n    Args:\n        verbose (bool, optional): If True, print the collections to the console.\n\n    Returns:\n        dict: A dictionary with collections IDs as keys and cllection titles as value.\n    \"\"\"\n    catalog = Client.open(PC_ENDPOINT)\n    collections = catalog.get_children()\n    result = {}\n    for collection in collections:\n        result[collection.id] = collection.title\n        if verbose:\n            print(f\"{collection.id} - {collection.title}\")\n\n    return result\n</code></pre>"},{"location":"pc/#beamgis.pc.get_pc_inventory","title":"<code>get_pc_inventory(refresh=False, verbose=False)</code>","text":"<p>Get the inventory of the Microsoft Planetary Computer catalog.</p> <p>Parameters:</p> Name Type Description Default <code>refresh</code> <code>bool</code> <p>If True, refresh the inventory.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, print the collections to the console.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of collections and their bands.</p> Source code in <code>beamgis/pc.py</code> <pre><code>def get_pc_inventory(\n    refresh: Optional[bool] = False, verbose: Optional[bool] = False\n) -&gt; dict[str, dict[str, Union[str, list, str]]]:\n    \"\"\"Get the inventory of the Microsoft Planetary Computer catalog.\n\n    Args:\n        refresh (bool, optional): If True, refresh the inventory.\n        verbose (bool, optional): If True, print the collections to the console.\n\n    Returns:\n        dict: A dictionary of collections and their bands.\n    \"\"\"\n    import importlib.resources\n\n    pkg_dir = os.path.dirname(importlib.resources.files(\"leafmap\") / \"leafmap.py\")\n    filepath = os.path.join(pkg_dir, \"data/pc_inventory.json\")\n\n    if refresh:\n        catalog = Client.open(PC_ENDPOINT)\n        collections = catalog.get_children()\n        data = {}\n        for collection in collections:\n            try:\n                if verbose:\n                    print(f\"{collection.id} - {collection.title}\")\n                first_item = get_first_item(collection.id, return_id=True)\n                bands = stac_assets(collection=collection.id, item=first_item)\n                if isinstance(bands, list):\n                    data[collection.id] = {}\n                    data[collection.id][\"title\"] = collection.title\n                    data[collection.id][\"first_item\"] = first_item\n                    data[collection.id][\"bands\"] = bands\n            except Exception as e:\n                if verbose:\n                    print(f\"{collection.id} has no bands.\")\n\n        with open(filepath, \"w\") as f:\n            json.dump(data, f, indent=4)\n\n    else:\n        with open(filepath, \"r\") as f:\n            data = json.load(f)\n\n    return data\n</code></pre>"},{"location":"split_map/","title":"split_map module","text":"<p>This module provides a custom Map class that extends folium.Map</p>"},{"location":"split_map/#beamgis.foliumap.Map","title":"<code> Map            (Map)         </code>","text":"<p>A custom Map class that extends folium.Map.</p> Source code in <code>beamgis/foliumap.py</code> <pre><code>class Map(folium.Map):\n    \"\"\"A custom Map class that extends folium.Map.\"\"\"\n\n    def __init__(self, center=(0, 0), zoom=2, **kwargs):\n        \"\"\"Initializes the Map object.\n\n        Args:\n            center (tuple, optional): The initial center of the map as (latitude, longitude). Defaults to (0, 0).\n            zoom (int, optional): The initial zoom level of the map. Defaults to 2.\n            **kwargs: Additional keyword arguments for the folium.Map class.\n        \"\"\"\n        super().__init__(location=center, zoom_start=zoom, **kwargs)\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the folium.GeoJson layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n\n        geojson = folium.GeoJson(data=geojson, **kwargs)\n        geojson.add_to(self)\n\n        if zoom_to_layer and gdf is not None:\n            bounds = gdf.total_bounds\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_basemap(self, basemap=\"OpenStreetMap\"):\n        \"\"\"Add basemap to the map using Folium's built-in tiles or a custom TileLayer.\n\n        Args:\n            basemap (str or dict, optional): Basemap name (dotted format) or a custom basemap dict.\n                Examples:\n                    \"CartoDB.DarkMatter\"\n                    {\n                        \"tiles\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\",\n                        \"name\": \"OpenTopoMap\",\n                        \"attr\": \"\u00a9 OpenTopoMap contributors\"\n                    }\n        \"\"\"\n        # Built-in basemap mapping\n        basemap_mapping = {\n            \"OpenStreetMap\": \"OpenStreetMap\",\n            \"CartoDB.Positron\": \"CartoDB positron\",\n            \"CartoDB.DarkMatter\": \"CartoDB dark_matter\",\n        }\n\n        if isinstance(basemap, str):\n            if basemap not in basemap_mapping:\n                raise ValueError(\n                    f\"Basemap '{basemap}' not supported. Available options: {list(basemap_mapping.keys())}\"\n                )\n            tile_name = basemap_mapping[basemap]\n            tile_layer = folium.TileLayer(tiles=tile_name, name=basemap, control=True)\n        elif isinstance(basemap, dict):\n            required_keys = {\"tiles\", \"name\", \"attr\"}\n            if not required_keys.issubset(basemap):\n                raise ValueError(\n                    \"Custom basemap dict must include 'tiles', 'name', and 'attr'\"\n                )\n            tile_layer = folium.TileLayer(\n                tiles=basemap[\"tiles\"],\n                name=basemap[\"name\"],\n                attr=basemap[\"attr\"],\n                control=True,\n            )\n        else:\n            raise TypeError(\n                \"Basemap must be a string or a dictionary with 'tiles', 'name', and 'attr'.\"\n            )\n\n        tile_layer.add_to(self)\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        folium.LayerControl().add_to(self)\n\n    def add_split_map(\n        self,\n        left=\"openstreetmap\",\n        right=\"cartodbpositron\",\n        colormap_left=None,\n        colormap_right=None,\n        opacity_left=1.0,\n        opacity_right=1.0,\n        **kwargs,\n    ):\n        \"\"\"\n        Adds a split map view to the current map, allowing users to compare two different map layers side by side.\n\n        Parameters:\n            left (str): The tile layer or path to a raster file for the left side of the map.\n            right (str): The tile layer or path to a raster file for the right side of the map.\n            colormap_left (callable): Colormap function for the left raster layer (if applicable).\n            colormap_right (callable): Colormap function for the right raster layer (if applicable).\n            opacity_left (float): Opacity for the left layer.\n            opacity_right (float): Opacity for the right layer.\n            **kwargs: Additional keyword arguments to customize the tile layers.\n\n        Returns:\n            None\n        \"\"\"\n\n        # Handle left layer\n        if isinstance(left, str) and left.lower().endswith((\".tif\", \".tiff\")):\n            client_left = TileClient(left)\n            layer_left = get_folium_tile_layer(\n                client_left,\n                name=\"Left Layer\",\n                colormap=colormap_left,\n                opacity=opacity_left,\n                **kwargs,\n            )\n        else:\n            layer_left = folium.TileLayer(\n                left, name=\"Left Layer\", opacity=opacity_left, **kwargs\n            )\n\n        # Handle right layer\n        if isinstance(right, str) and right.lower().endswith((\".tif\", \".tiff\")):\n            client_right = TileClient(right)\n            layer_right = get_folium_tile_layer(\n                client_right,\n                name=\"Right Layer\",\n                colormap=colormap_right,\n                opacity=opacity_right,\n                **kwargs,\n            )\n        else:\n            layer_right = folium.TileLayer(\n                right, name=\"Right Layer\", opacity=opacity_right, **kwargs\n            )\n\n        # Add layers to map\n        layer_left.add_to(self)\n        layer_right.add_to(self)\n\n        # Add split map control\n        sbs = folium.plugins.SideBySideLayers(\n            layer_left=layer_left, layer_right=layer_right\n        )\n        sbs.add_to(self)\n\n    def add_heatmap(\n        self,\n        data: Union[str, List[List[float]], pd.DataFrame],\n        latitude: Optional[str] = \"latitude\",\n        longitude: Optional[str] = \"longitude\",\n        value: Optional[str] = \"value\",\n        name: Optional[str] = \"Heat map\",\n        radius: Optional[int] = 25,\n        **kwargs,\n    ):\n        \"\"\"Adds a heat map to the map. Reference: https://stackoverflow.com/a/54756617\n\n        Args:\n            data (str | list | pd.DataFrame): File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\n            latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n            longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n            value (str, optional): The column name of values. Defaults to \"value\".\n            name (str, optional): Layer name to use. Defaults to \"Heat map\".\n            radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n\n        Raises:\n            ValueError: If data is not a list.\n        \"\"\"\n        import pandas as pd\n\n        try:\n            if isinstance(data, str):\n                df = pd.read_csv(data)\n                data = df[[latitude, longitude, value]].values.tolist()\n            elif isinstance(data, pd.DataFrame):\n                data = data[[latitude, longitude, value]].values.tolist()\n            elif isinstance(data, list):\n                pass\n            else:\n                raise ValueError(\"data must be a list, a DataFrame, or a file path.\")\n\n            plugins.HeatMap(data, name=name, radius=radius, **kwargs).add_to(\n                folium.FeatureGroup(name=name).add_to(self)\n            )\n        except Exception as e:\n            raise Exception(e)\n</code></pre>"},{"location":"split_map/#beamgis.foliumap.Map.__init__","title":"<code>__init__(self, center=(0, 0), zoom=2, **kwargs)</code>  <code>special</code>","text":"<p>Initializes the Map object.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>The initial center of the map as (latitude, longitude). Defaults to (0, 0).</p> <code>(0, 0)</code> <code>zoom</code> <code>int</code> <p>The initial zoom level of the map. Defaults to 2.</p> <code>2</code> <code>**kwargs</code> <p>Additional keyword arguments for the folium.Map class.</p> <code>{}</code> Source code in <code>beamgis/foliumap.py</code> <pre><code>def __init__(self, center=(0, 0), zoom=2, **kwargs):\n    \"\"\"Initializes the Map object.\n\n    Args:\n        center (tuple, optional): The initial center of the map as (latitude, longitude). Defaults to (0, 0).\n        zoom (int, optional): The initial zoom level of the map. Defaults to 2.\n        **kwargs: Additional keyword arguments for the folium.Map class.\n    \"\"\"\n    super().__init__(location=center, zoom_start=zoom, **kwargs)\n</code></pre>"},{"location":"split_map/#beamgis.foliumap.Map.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap')</code>","text":"<p>Add basemap to the map using Folium's built-in tiles or a custom TileLayer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str or dict</code> <p>Basemap name (dotted format) or a custom basemap dict. Examples:     \"CartoDB.DarkMatter\"     {         \"tiles\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\",         \"name\": \"OpenTopoMap\",         \"attr\": \"\u00a9 OpenTopoMap contributors\"     }</p> <code>'OpenStreetMap'</code> Source code in <code>beamgis/foliumap.py</code> <pre><code>def add_basemap(self, basemap=\"OpenStreetMap\"):\n    \"\"\"Add basemap to the map using Folium's built-in tiles or a custom TileLayer.\n\n    Args:\n        basemap (str or dict, optional): Basemap name (dotted format) or a custom basemap dict.\n            Examples:\n                \"CartoDB.DarkMatter\"\n                {\n                    \"tiles\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\",\n                    \"name\": \"OpenTopoMap\",\n                    \"attr\": \"\u00a9 OpenTopoMap contributors\"\n                }\n    \"\"\"\n    # Built-in basemap mapping\n    basemap_mapping = {\n        \"OpenStreetMap\": \"OpenStreetMap\",\n        \"CartoDB.Positron\": \"CartoDB positron\",\n        \"CartoDB.DarkMatter\": \"CartoDB dark_matter\",\n    }\n\n    if isinstance(basemap, str):\n        if basemap not in basemap_mapping:\n            raise ValueError(\n                f\"Basemap '{basemap}' not supported. Available options: {list(basemap_mapping.keys())}\"\n            )\n        tile_name = basemap_mapping[basemap]\n        tile_layer = folium.TileLayer(tiles=tile_name, name=basemap, control=True)\n    elif isinstance(basemap, dict):\n        required_keys = {\"tiles\", \"name\", \"attr\"}\n        if not required_keys.issubset(basemap):\n            raise ValueError(\n                \"Custom basemap dict must include 'tiles', 'name', and 'attr'\"\n            )\n        tile_layer = folium.TileLayer(\n            tiles=basemap[\"tiles\"],\n            name=basemap[\"name\"],\n            attr=basemap[\"attr\"],\n            control=True,\n        )\n    else:\n        raise TypeError(\n            \"Basemap must be a string or a dictionary with 'tiles', 'name', and 'attr'.\"\n        )\n\n    tile_layer.add_to(self)\n</code></pre>"},{"location":"split_map/#beamgis.foliumap.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>beamgis/foliumap.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"split_map/#beamgis.foliumap.Map.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the folium.GeoJson layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>beamgis/foliumap.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the folium.GeoJson layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n\n    geojson = folium.GeoJson(data=geojson, **kwargs)\n    geojson.add_to(self)\n\n    if zoom_to_layer and gdf is not None:\n        bounds = gdf.total_bounds\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"split_map/#beamgis.foliumap.Map.add_heatmap","title":"<code>add_heatmap(self, data, latitude='latitude', longitude='longitude', value='value', name='Heat map', radius=25, **kwargs)</code>","text":"<p>Adds a heat map to the map. Reference: https://stackoverflow.com/a/54756617</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | list | pd.DataFrame</code> <p>File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv</p> required <code>latitude</code> <code>str</code> <p>The column name of latitude. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The column name of longitude. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>value</code> <code>str</code> <p>The column name of values. Defaults to \"value\".</p> <code>'value'</code> <code>name</code> <code>str</code> <p>Layer name to use. Defaults to \"Heat map\".</p> <code>'Heat map'</code> <code>radius</code> <code>int</code> <p>Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.</p> <code>25</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If data is not a list.</p> Source code in <code>beamgis/foliumap.py</code> <pre><code>def add_heatmap(\n    self,\n    data: Union[str, List[List[float]], pd.DataFrame],\n    latitude: Optional[str] = \"latitude\",\n    longitude: Optional[str] = \"longitude\",\n    value: Optional[str] = \"value\",\n    name: Optional[str] = \"Heat map\",\n    radius: Optional[int] = 25,\n    **kwargs,\n):\n    \"\"\"Adds a heat map to the map. Reference: https://stackoverflow.com/a/54756617\n\n    Args:\n        data (str | list | pd.DataFrame): File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\n        latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n        longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n        value (str, optional): The column name of values. Defaults to \"value\".\n        name (str, optional): Layer name to use. Defaults to \"Heat map\".\n        radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n\n    Raises:\n        ValueError: If data is not a list.\n    \"\"\"\n    import pandas as pd\n\n    try:\n        if isinstance(data, str):\n            df = pd.read_csv(data)\n            data = df[[latitude, longitude, value]].values.tolist()\n        elif isinstance(data, pd.DataFrame):\n            data = data[[latitude, longitude, value]].values.tolist()\n        elif isinstance(data, list):\n            pass\n        else:\n            raise ValueError(\"data must be a list, a DataFrame, or a file path.\")\n\n        plugins.HeatMap(data, name=name, radius=radius, **kwargs).add_to(\n            folium.FeatureGroup(name=name).add_to(self)\n        )\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"split_map/#beamgis.foliumap.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>beamgis/foliumap.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    folium.LayerControl().add_to(self)\n</code></pre>"},{"location":"split_map/#beamgis.foliumap.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>beamgis/foliumap.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"split_map/#beamgis.foliumap.Map.add_split_map","title":"<code>add_split_map(self, left='openstreetmap', right='cartodbpositron', colormap_left=None, colormap_right=None, opacity_left=1.0, opacity_right=1.0, **kwargs)</code>","text":"<p>Adds a split map view to the current map, allowing users to compare two different map layers side by side.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str</code> <p>The tile layer or path to a raster file for the left side of the map.</p> <code>'openstreetmap'</code> <code>right</code> <code>str</code> <p>The tile layer or path to a raster file for the right side of the map.</p> <code>'cartodbpositron'</code> <code>colormap_left</code> <code>callable</code> <p>Colormap function for the left raster layer (if applicable).</p> <code>None</code> <code>colormap_right</code> <code>callable</code> <p>Colormap function for the right raster layer (if applicable).</p> <code>None</code> <code>opacity_left</code> <code>float</code> <p>Opacity for the left layer.</p> <code>1.0</code> <code>opacity_right</code> <code>float</code> <p>Opacity for the right layer.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional keyword arguments to customize the tile layers.</p> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>beamgis/foliumap.py</code> <pre><code>def add_split_map(\n    self,\n    left=\"openstreetmap\",\n    right=\"cartodbpositron\",\n    colormap_left=None,\n    colormap_right=None,\n    opacity_left=1.0,\n    opacity_right=1.0,\n    **kwargs,\n):\n    \"\"\"\n    Adds a split map view to the current map, allowing users to compare two different map layers side by side.\n\n    Parameters:\n        left (str): The tile layer or path to a raster file for the left side of the map.\n        right (str): The tile layer or path to a raster file for the right side of the map.\n        colormap_left (callable): Colormap function for the left raster layer (if applicable).\n        colormap_right (callable): Colormap function for the right raster layer (if applicable).\n        opacity_left (float): Opacity for the left layer.\n        opacity_right (float): Opacity for the right layer.\n        **kwargs: Additional keyword arguments to customize the tile layers.\n\n    Returns:\n        None\n    \"\"\"\n\n    # Handle left layer\n    if isinstance(left, str) and left.lower().endswith((\".tif\", \".tiff\")):\n        client_left = TileClient(left)\n        layer_left = get_folium_tile_layer(\n            client_left,\n            name=\"Left Layer\",\n            colormap=colormap_left,\n            opacity=opacity_left,\n            **kwargs,\n        )\n    else:\n        layer_left = folium.TileLayer(\n            left, name=\"Left Layer\", opacity=opacity_left, **kwargs\n        )\n\n    # Handle right layer\n    if isinstance(right, str) and right.lower().endswith((\".tif\", \".tiff\")):\n        client_right = TileClient(right)\n        layer_right = get_folium_tile_layer(\n            client_right,\n            name=\"Right Layer\",\n            colormap=colormap_right,\n            opacity=opacity_right,\n            **kwargs,\n        )\n    else:\n        layer_right = folium.TileLayer(\n            right, name=\"Right Layer\", opacity=opacity_right, **kwargs\n        )\n\n    # Add layers to map\n    layer_left.add_to(self)\n    layer_right.add_to(self)\n\n    # Add split map control\n    sbs = folium.plugins.SideBySideLayers(\n        layer_left=layer_left, layer_right=layer_right\n    )\n    sbs.add_to(self)\n</code></pre>"},{"location":"split_map/#beamgis.foliumap.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>beamgis/foliumap.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"stac/","title":"stac module","text":""},{"location":"stac/#beamgis.stac.PlanetaryComputerEndpoint","title":"<code> PlanetaryComputerEndpoint            (TitilerEndpoint)         </code>","text":"<p>This class contains the methods for the Microsoft Planetary Computer endpoint.</p> Source code in <code>beamgis/stac.py</code> <pre><code>class PlanetaryComputerEndpoint(TitilerEndpoint):\n    \"\"\"This class contains the methods for the Microsoft Planetary Computer endpoint.\"\"\"\n\n    def __init__(\n        self,\n        endpoint: Optional[str] = \"https://planetarycomputer.microsoft.com/api/data/v1\",\n        name: Optional[str] = \"item\",\n        TileMatrixSetId: Optional[str] = \"WebMercatorQuad\",\n    ):\n        \"\"\"Initialize the PlanetaryComputerEndpoint object.\n\n        Args:\n            endpoint (str, optional): The endpoint of the titiler server. Defaults to \"https://planetarycomputer.microsoft.com/api/data/v1\".\n            name (str, optional): The name to be used in the file path. Defaults to \"item\".\n            TileMatrixSetId (str, optional): The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".\n        \"\"\"\n        super().__init__(endpoint, name, TileMatrixSetId)\n\n    def url_for_stac_collection(self):\n        return f\"{self.endpoint}/collection/{self.TileMatrixSetId}/tilejson.json\"\n\n    def url_for_collection_assets(self):\n        return f\"{self.endpoint}/collection/assets\"\n\n    def url_for_collection_bounds(self):\n        return f\"{self.endpoint}/collection/bounds\"\n\n    def url_for_collection_info(self):\n        return f\"{self.endpoint}/collection/info\"\n\n    def url_for_collection_info_geojson(self):\n        return f\"{self.endpoint}/collection/info.geojson\"\n\n    def url_for_collection_pixel_value(self, lon, lat):\n        return f\"{self.endpoint}/collection/point/{lon},{lat}\"\n\n    def url_for_collection_wmts(self):\n        return f\"{self.endpoint}/collection/{self.TileMatrixSetId}/WMTSCapabilities.xml\"\n\n    def url_for_collection_lat_lon_assets(self, lng, lat):\n        return f\"{self.endpoint}/collection/{lng},{lat}/assets\"\n\n    def url_for_collection_bbox_assets(self, minx, miny, maxx, maxy):\n        return f\"{self.endpoint}/collection/{minx},{miny},{maxx},{maxy}/assets\"\n\n    def url_for_stac_mosaic(self, searchid):\n        return f\"{self.endpoint}/mosaic/{searchid}/{self.TileMatrixSetId}/tilejson.json\"\n\n    def url_for_mosaic_info(self, searchid):\n        return f\"{self.endpoint}/mosaic/{searchid}/info\"\n\n    def url_for_mosaic_lat_lon_assets(self, searchid, lon, lat):\n        return f\"{self.endpoint}/mosaic/{searchid}/{lon},{lat}/assets\"\n</code></pre>"},{"location":"stac/#beamgis.stac.PlanetaryComputerEndpoint.__init__","title":"<code>__init__(self, endpoint='https://planetarycomputer.microsoft.com/api/data/v1', name='item', TileMatrixSetId='WebMercatorQuad')</code>  <code>special</code>","text":"<p>Initialize the PlanetaryComputerEndpoint object.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The endpoint of the titiler server. Defaults to \"https://planetarycomputer.microsoft.com/api/data/v1\".</p> <code>'https://planetarycomputer.microsoft.com/api/data/v1'</code> <code>name</code> <code>str</code> <p>The name to be used in the file path. Defaults to \"item\".</p> <code>'item'</code> <code>TileMatrixSetId</code> <code>str</code> <p>The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".</p> <code>'WebMercatorQuad'</code> Source code in <code>beamgis/stac.py</code> <pre><code>def __init__(\n    self,\n    endpoint: Optional[str] = \"https://planetarycomputer.microsoft.com/api/data/v1\",\n    name: Optional[str] = \"item\",\n    TileMatrixSetId: Optional[str] = \"WebMercatorQuad\",\n):\n    \"\"\"Initialize the PlanetaryComputerEndpoint object.\n\n    Args:\n        endpoint (str, optional): The endpoint of the titiler server. Defaults to \"https://planetarycomputer.microsoft.com/api/data/v1\".\n        name (str, optional): The name to be used in the file path. Defaults to \"item\".\n        TileMatrixSetId (str, optional): The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".\n    \"\"\"\n    super().__init__(endpoint, name, TileMatrixSetId)\n</code></pre>"},{"location":"stac/#beamgis.stac.TitilerEndpoint","title":"<code> TitilerEndpoint        </code>","text":"<p>This class contains the methods for the titiler endpoint.</p> Source code in <code>beamgis/stac.py</code> <pre><code>class TitilerEndpoint:\n    \"\"\"This class contains the methods for the titiler endpoint.\"\"\"\n\n    def __init__(\n        self,\n        endpoint: Optional[str] = None,\n        name: Optional[str] = \"stac\",\n        TileMatrixSetId: Optional[str] = \"WebMercatorQuad\",\n    ):\n        \"\"\"Initialize the TitilerEndpoint object.\n\n        Args:\n            endpoint (str, optional): The endpoint of the titiler server. Defaults to \"https://titiler.xyz\".\n            name (str, optional): The name to be used in the file path. Defaults to \"stac\".\n            TileMatrixSetId (str, optional): The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".\n        \"\"\"\n        self.endpoint = endpoint\n        self.name = name\n        self.TileMatrixSetId = TileMatrixSetId\n\n    def url_for_stac_item(self):\n        return f\"{self.endpoint}/{self.name}/{self.TileMatrixSetId}/tilejson.json\"\n\n    def url_for_stac_assets(self):\n        return f\"{self.endpoint}/{self.name}/assets\"\n\n    def url_for_stac_bounds(self):\n        return f\"{self.endpoint}/{self.name}/bounds\"\n\n    def url_for_stac_info(self):\n        return f\"{self.endpoint}/{self.name}/info\"\n\n    def url_for_stac_info_geojson(self):\n        return f\"{self.endpoint}/{self.name}/info.geojson\"\n\n    def url_for_stac_statistics(self):\n        return f\"{self.endpoint}/{self.name}/statistics\"\n\n    def url_for_stac_pixel_value(self, lon, lat):\n        return f\"{self.endpoint}/{self.name}/point/{lon},{lat}\"\n\n    def url_for_stac_wmts(self):\n        return (\n            f\"{self.endpoint}/{self.name}/{self.TileMatrixSetId}/WMTSCapabilities.xml\"\n        )\n</code></pre>"},{"location":"stac/#beamgis.stac.TitilerEndpoint.__init__","title":"<code>__init__(self, endpoint=None, name='stac', TileMatrixSetId='WebMercatorQuad')</code>  <code>special</code>","text":"<p>Initialize the TitilerEndpoint object.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The endpoint of the titiler server. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>name</code> <code>str</code> <p>The name to be used in the file path. Defaults to \"stac\".</p> <code>'stac'</code> <code>TileMatrixSetId</code> <code>str</code> <p>The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".</p> <code>'WebMercatorQuad'</code> Source code in <code>beamgis/stac.py</code> <pre><code>def __init__(\n    self,\n    endpoint: Optional[str] = None,\n    name: Optional[str] = \"stac\",\n    TileMatrixSetId: Optional[str] = \"WebMercatorQuad\",\n):\n    \"\"\"Initialize the TitilerEndpoint object.\n\n    Args:\n        endpoint (str, optional): The endpoint of the titiler server. Defaults to \"https://titiler.xyz\".\n        name (str, optional): The name to be used in the file path. Defaults to \"stac\".\n        TileMatrixSetId (str, optional): The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".\n    \"\"\"\n    self.endpoint = endpoint\n    self.name = name\n    self.TileMatrixSetId = TileMatrixSetId\n</code></pre>"},{"location":"stac/#beamgis.stac.check_titiler_endpoint","title":"<code>check_titiler_endpoint(titiler_endpoint=None)</code>","text":"<p>Returns the default titiler endpoint.</p> <p>Returns:</p> Type Description <code>object</code> <p>A titiler endpoint.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def check_titiler_endpoint(titiler_endpoint: Optional[str] = None):\n    \"\"\"Returns the default titiler endpoint.\n\n    Returns:\n        object: A titiler endpoint.\n    \"\"\"\n    if titiler_endpoint is None:\n        if os.environ.get(\"TITILER_ENDPOINT\") is not None:\n            titiler_endpoint = os.environ.get(\"TITILER_ENDPOINT\")\n\n            if titiler_endpoint == \"planetary-computer\":\n                titiler_endpoint = PlanetaryComputerEndpoint()\n        else:\n            titiler_endpoint = \"https://titiler.xyz\"\n    elif titiler_endpoint in [\"planetary-computer\", \"pc\"]:\n        titiler_endpoint = PlanetaryComputerEndpoint()\n\n    return titiler_endpoint\n</code></pre>"},{"location":"stac/#beamgis.stac.cog_bands","title":"<code>cog_bands(url, titiler_endpoint=None)</code>","text":"<p>Get band names of a Cloud Optimized GeoTIFF (COG).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of band names</p> Source code in <code>beamgis/stac.py</code> <pre><code>def cog_bands(\n    url: str,\n    titiler_endpoint: Optional[str] = None,\n) -&gt; List:\n    \"\"\"Get band names of a Cloud Optimized GeoTIFF (COG).\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n\n    Returns:\n        list: A list of band names\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    r = requests.get(\n        f\"{titiler_endpoint}/cog/info\",\n        params={\n            \"url\": url,\n        },\n    ).json()\n\n    bands = [b[0] for b in r[\"band_descriptions\"]]\n    return bands\n</code></pre>"},{"location":"stac/#beamgis.stac.cog_bounds","title":"<code>cog_bounds(url, titiler_endpoint=None)</code>","text":"<p>Get the bounding box of a Cloud Optimized GeoTIFF (COG).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of values representing [left, bottom, right, top]</p> Source code in <code>beamgis/stac.py</code> <pre><code>def cog_bounds(\n    url: str,\n    titiler_endpoint: Optional[str] = None,\n) -&gt; List:\n    \"\"\"Get the bounding box of a Cloud Optimized GeoTIFF (COG).\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n\n    Returns:\n        list: A list of values representing [left, bottom, right, top]\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    r = requests.get(f\"{titiler_endpoint}/cog/bounds\", params={\"url\": url}).json()\n\n    if \"bounds\" in r.keys():\n        bounds = r[\"bounds\"]\n    else:\n        bounds = None\n    return bounds\n</code></pre>"},{"location":"stac/#beamgis.stac.cog_center","title":"<code>cog_center(url, titiler_endpoint=None)</code>","text":"<p>Get the centroid of a Cloud Optimized GeoTIFF (COG).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple representing (longitude, latitude)</p> Source code in <code>beamgis/stac.py</code> <pre><code>def cog_center(\n    url: str,\n    titiler_endpoint: Optional[str] = None,\n) -&gt; Tuple:\n    \"\"\"Get the centroid of a Cloud Optimized GeoTIFF (COG).\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n\n    Returns:\n        tuple: A tuple representing (longitude, latitude)\n    \"\"\"\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    bounds = cog_bounds(url, titiler_endpoint)\n    center = ((bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2)  # (lat, lon)\n    return center\n</code></pre>"},{"location":"stac/#beamgis.stac.cog_info","title":"<code>cog_info(url, titiler_endpoint=None, return_geojson=False)</code>","text":"<p>Get band statistics of a Cloud Optimized GeoTIFF (COG).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band info.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def cog_info(\n    url: str,\n    titiler_endpoint: Optional[str] = None,\n    return_geojson: Optional[bool] = False,\n) -&gt; List:\n    \"\"\"Get band statistics of a Cloud Optimized GeoTIFF (COG).\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n\n    Returns:\n        list: A dictionary of band info.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    info = \"info\"\n    if return_geojson:\n        info = \"info.geojson\"\n\n    r = requests.get(\n        f\"{titiler_endpoint}/cog/{info}\",\n        params={\n            \"url\": url,\n        },\n    ).json()\n\n    return r\n</code></pre>"},{"location":"stac/#beamgis.stac.cog_mosaic","title":"<code>cog_mosaic(links, titiler_endpoint=None, username='anonymous', layername=None, overwrite=False, verbose=True, **kwargs)</code>","text":"<p>Creates a COG mosaic from a list of COG URLs.</p> <p>Parameters:</p> Name Type Description Default <code>links</code> <code>list</code> <p>A list containing COG HTTP URLs.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>username</code> <code>str</code> <p>User name for the titiler endpoint. Defaults to \"anonymous\".</p> <code>'anonymous'</code> <code>layername</code> <code>[type]</code> <p>Layer name to use. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the layer name if existing. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print out descriptive information. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>Exception</code> <p>If the COG mosaic fails to create.</p> <p>Returns:</p> Type Description <code>str</code> <p>The tile URL for the COG mosaic.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def cog_mosaic(\n    links: List,\n    titiler_endpoint: Optional[str] = None,\n    username: Optional[str] = \"anonymous\",\n    layername=None,\n    overwrite: Optional[bool] = False,\n    verbose: Optional[bool] = True,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Creates a COG mosaic from a list of COG URLs.\n\n    Args:\n        links (list): A list containing COG HTTP URLs.\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        username (str, optional): User name for the titiler endpoint. Defaults to \"anonymous\".\n        layername ([type], optional): Layer name to use. Defaults to None.\n        overwrite (bool, optional): Whether to overwrite the layer name if existing. Defaults to False.\n        verbose (bool, optional): Whether to print out descriptive information. Defaults to True.\n\n    Raises:\n        Exception: If the COG mosaic fails to create.\n\n    Returns:\n        str: The tile URL for the COG mosaic.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if layername is None:\n        layername = \"layer_X\"\n\n    try:\n        if verbose:\n            print(\"Creating COG masaic ...\")\n\n        # Create token\n        r = requests.post(\n            f\"{titiler_endpoint}/tokens/create\",\n            json={\"username\": username, \"scope\": [\"mosaic:read\", \"mosaic:create\"]},\n        ).json()\n        token = r[\"token\"]\n\n        # Create mosaic\n        requests.post(\n            f\"{titiler_endpoint}/mosaicjson/create\",\n            json={\n                \"username\": username,\n                \"layername\": layername,\n                \"files\": links,\n                # \"overwrite\": overwrite\n            },\n            params={\n                \"access_token\": token,\n            },\n        ).json()\n\n        r2 = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/{username}.{layername}/tilejson.json\",\n        ).json()\n\n        return r2[\"tiles\"][0]\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"stac/#beamgis.stac.cog_mosaic_from_file","title":"<code>cog_mosaic_from_file(filepath, skip_rows=0, titiler_endpoint=None, username='anonymous', layername=None, overwrite=False, verbose=True, **kwargs)</code>","text":"<p>Creates a COG mosaic from a csv/txt file stored locally for through HTTP URL.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Local path or HTTP URL to the csv/txt file containing COG URLs.</p> required <code>skip_rows</code> <code>int</code> <p>The number of rows to skip in the file. Defaults to 0.</p> <code>0</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>username</code> <code>str</code> <p>User name for the titiler endpoint. Defaults to \"anonymous\".</p> <code>'anonymous'</code> <code>layername</code> <code>[type]</code> <p>Layer name to use. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the layer name if existing. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print out descriptive information. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The tile URL for the COG mosaic.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def cog_mosaic_from_file(\n    filepath: str,\n    skip_rows: Optional[int] = 0,\n    titiler_endpoint: Optional[str] = None,\n    username: Optional[str] = \"anonymous\",\n    layername=None,\n    overwrite: Optional[bool] = False,\n    verbose: Optional[bool] = True,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Creates a COG mosaic from a csv/txt file stored locally for through HTTP URL.\n\n    Args:\n        filepath (str): Local path or HTTP URL to the csv/txt file containing COG URLs.\n        skip_rows (int, optional): The number of rows to skip in the file. Defaults to 0.\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        username (str, optional): User name for the titiler endpoint. Defaults to \"anonymous\".\n        layername ([type], optional): Layer name to use. Defaults to None.\n        overwrite (bool, optional): Whether to overwrite the layer name if existing. Defaults to False.\n        verbose (bool, optional): Whether to print out descriptive information. Defaults to True.\n\n    Returns:\n        str: The tile URL for the COG mosaic.\n    \"\"\"\n    import urllib\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    links = []\n    if filepath.startswith(\"http\"):\n        data = urllib.request.urlopen(filepath)\n        for line in data:\n            links.append(line.decode(\"utf-8\").strip())\n\n    else:\n        with open(filepath) as f:\n            links = [line.strip() for line in f.readlines()]\n\n    links = links[skip_rows:]\n    # print(links)\n    mosaic = cog_mosaic(\n        links, titiler_endpoint, username, layername, overwrite, verbose, **kwargs\n    )\n    return mosaic\n</code></pre>"},{"location":"stac/#beamgis.stac.cog_pixel_value","title":"<code>cog_pixel_value(lon, lat, url, bidx, titiler_endpoint=None, verbose=True, **kwargs)</code>","text":"<p>Get pixel value from COG.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Longitude of the pixel.</p> required <code>lat</code> <code>float</code> <p>Latitude of the pixel.</p> required <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., 'https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif'</p> required <code>bidx</code> <code>str</code> <p>Dataset band indexes (e.g bidx=1, bidx=1&amp;bidx=2&amp;bidx=3). Defaults to None.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Print status messages. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band info.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def cog_pixel_value(\n    lon: float,\n    lat: float,\n    url: str,\n    bidx: Optional[str],\n    titiler_endpoint: Optional[str] = None,\n    verbose: Optional[bool] = True,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get pixel value from COG.\n\n    Args:\n        lon (float): Longitude of the pixel.\n        lat (float): Latitude of the pixel.\n        url (str): HTTP URL to a COG, e.g., 'https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif'\n        bidx (str, optional): Dataset band indexes (e.g bidx=1, bidx=1&amp;bidx=2&amp;bidx=3). Defaults to None.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        verbose (bool, optional): Print status messages. Defaults to True.\n\n    Returns:\n        list: A dictionary of band info.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    kwargs[\"url\"] = url\n    if bidx is not None:\n        kwargs[\"bidx\"] = bidx\n\n    r = requests.get(f\"{titiler_endpoint}/cog/point/{lon},{lat}\", params=kwargs).json()\n    bands = cog_bands(url, titiler_endpoint)\n    # if isinstance(titiler_endpoint, str):\n    #     r = requests.get(f\"{titiler_endpoint}/cog/point/{lon},{lat}\", params=kwargs).json()\n    # else:\n    #     r = requests.get(\n    #         titiler_endpoint.url_for_stac_pixel_value(lon, lat), params=kwargs\n    #     ).json()\n\n    if \"detail\" in r:\n        if verbose:\n            print(r[\"detail\"])\n        return None\n    else:\n        values = r[\"values\"]\n        result = dict(zip(bands, values))\n        return result\n</code></pre>"},{"location":"stac/#beamgis.stac.cog_stats","title":"<code>cog_stats(url, titiler_endpoint=None)</code>","text":"<p>Get band statistics of a Cloud Optimized GeoTIFF (COG).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band statistics.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def cog_stats(\n    url: str,\n    titiler_endpoint: Optional[str] = None,\n) -&gt; List:\n    \"\"\"Get band statistics of a Cloud Optimized GeoTIFF (COG).\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n\n    Returns:\n        list: A dictionary of band statistics.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    r = requests.get(\n        f\"{titiler_endpoint}/cog/statistics\",\n        params={\n            \"url\": url,\n        },\n    ).json()\n\n    return r\n</code></pre>"},{"location":"stac/#beamgis.stac.cog_tile","title":"<code>cog_tile(url, bands=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get a tile layer from a Cloud Optimized GeoTIFF (COG).     Source code adapted from https://developmentseed.org/titiler/examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>bands</code> <code>list</code> <p>List of bands to use. Defaults to None.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>TiTiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to the titiler endpoint. For more information about the available arguments, see https://developmentseed.org/titiler/endpoints/cog/#tiles. For example, to apply a rescaling to multiple bands, use something like <code>rescale=[\"164,223\",\"130,211\",\"99,212\"]</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Returns the COG Tile layer URL and bounds.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def cog_tile(\n    url,\n    bands: str = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; Tuple:\n    \"\"\"Get a tile layer from a Cloud Optimized GeoTIFF (COG).\n        Source code adapted from https://developmentseed.org/titiler/examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        bands (list, optional): List of bands to use. Defaults to None.\n        titiler_endpoint (str, optional): TiTiler endpoint. Defaults to \"https://titiler.xyz\".\n        **kwargs: Additional arguments to pass to the titiler endpoint. For more information about the available arguments, see https://developmentseed.org/titiler/endpoints/cog/#tiles.\n            For example, to apply a rescaling to multiple bands, use something like `rescale=[\"164,223\",\"130,211\",\"99,212\"]`.\n\n    Returns:\n        tuple: Returns the COG Tile layer URL and bounds.\n    \"\"\"\n    import json\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    kwargs[\"url\"] = url\n\n    band_names = cog_bands(url, titiler_endpoint)\n\n    if isinstance(bands, str):\n        bands = [bands]\n\n    if bands is None and \"bidx\" not in kwargs:\n        if len(band_names) &gt;= 3:\n            kwargs[\"bidx\"] = [1, 2, 3]\n    elif isinstance(bands, list) and \"bidx\" not in kwargs:\n        if all(isinstance(x, int) for x in bands):\n            if len(set(bands)) == 1:\n                bands = bands[0]\n            kwargs[\"bidx\"] = bands\n        elif all(isinstance(x, str) for x in bands):\n            if len(set(bands)) == 1:\n                bands = bands[0]\n            kwargs[\"bidx\"] = [band_names.index(x) + 1 for x in bands]\n        else:\n            raise ValueError(\"Bands must be a list of integers or strings.\")\n\n    if \"palette\" in kwargs:\n        kwargs[\"colormap_name\"] = kwargs[\"palette\"].lower()\n        del kwargs[\"palette\"]\n\n    if \"bidx\" not in kwargs:\n        kwargs[\"bidx\"] = [1]\n    elif isinstance(kwargs[\"bidx\"], int):\n        kwargs[\"bidx\"] = [kwargs[\"bidx\"]]\n\n    if \"rescale\" not in kwargs and (\"colormap\" not in kwargs):\n        stats = cog_stats(url, titiler_endpoint)\n\n        if \"message\" not in stats:\n            try:\n                rescale = []\n                for i in band_names:\n                    rescale.append(\n                        \"{},{}\".format(\n                            stats[i][\"percentile_2\"],\n                            stats[i][\"percentile_98\"],\n                        )\n                    )\n                kwargs[\"rescale\"] = rescale\n            except Exception as e:\n                pass\n\n    if \"colormap\" in kwargs and isinstance(kwargs[\"colormap\"], dict):\n        kwargs[\"colormap\"] = json.dumps(kwargs[\"colormap\"])\n\n    TileMatrixSetId = \"WebMercatorQuad\"\n    if \"TileMatrixSetId\" in kwargs.keys():\n        TileMatrixSetId = kwargs[\"TileMatrixSetId\"]\n        kwargs.pop(\"TileMatrixSetId\")\n\n    if \"default_vis\" in kwargs.keys() and kwargs[\"default_vis\"]:\n        kwargs = {\"url\": url}\n\n    r = requests.get(\n        f\"{titiler_endpoint}/cog/{TileMatrixSetId}/tilejson.json\", params=kwargs\n    ).json()\n    return r[\"tiles\"][0]\n</code></pre>"},{"location":"stac/#beamgis.stac.cog_tile_vmin_vmax","title":"<code>cog_tile_vmin_vmax(url, bands=None, titiler_endpoint=None, percentile=True, **kwargs)</code>","text":"<p>Get a tile layer from a Cloud Optimized GeoTIFF (COG) and return the minimum and maximum values.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>bands</code> <code>list</code> <p>List of bands to use. Defaults to None.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>percentile</code> <code>bool</code> <p>Whether to use percentiles or not. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Returns the minimum and maximum values.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def cog_tile_vmin_vmax(\n    url: str,\n    bands: Optional[List] = None,\n    titiler_endpoint: Optional[str] = None,\n    percentile: Optional[bool] = True,\n    **kwargs,\n) -&gt; Tuple:\n    \"\"\"Get a tile layer from a Cloud Optimized GeoTIFF (COG) and return the minimum and maximum values.\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        bands (list, optional): List of bands to use. Defaults to None.\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        percentile (bool, optional): Whether to use percentiles or not. Defaults to True.\n    Returns:\n        tuple: Returns the minimum and maximum values.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    stats = cog_stats(url, titiler_endpoint)\n\n    if isinstance(bands, str):\n        bands = [bands]\n\n    if bands is not None:\n        stats = {s: stats[s] for s in stats if s in bands}\n\n    if percentile:\n        vmin = min([stats[s][\"percentile_2\"] for s in stats])\n        vmax = max([stats[s][\"percentile_98\"] for s in stats])\n    else:\n        vmin = min([stats[s][\"min\"] for s in stats])\n        vmax = max([stats[s][\"max\"] for s in stats])\n\n    return vmin, vmax\n</code></pre>"},{"location":"stac/#beamgis.stac.create_mosaicjson","title":"<code>create_mosaicjson(images, output)</code>","text":"<p>Create a mosaicJSON file from a list of images.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>str | list</code> <p>A list of image URLs or a URL to a text file containing a list of image URLs.</p> required <code>output</code> <code>str</code> <p>The output mosaicJSON file path.</p> required Source code in <code>beamgis/stac.py</code> <pre><code>def create_mosaicjson(images, output):\n    \"\"\"Create a mosaicJSON file from a list of images.\n\n    Args:\n        images (str | list): A list of image URLs or a URL to a text file containing a list of image URLs.\n        output (str): The output mosaicJSON file path.\n\n    \"\"\"\n    try:\n        from cogeo_mosaic.mosaic import MosaicJSON\n        from cogeo_mosaic.backends import MosaicBackend\n    except ImportError:\n        raise ImportError(\n            \"cogeo-mosaic is required to use this function. \"\n            \"Install with `pip install cogeo-mosaic`.\"\n        )\n\n    if isinstance(images, str):\n        if images.startswith(\"http\"):\n            import urllib.request\n\n            with urllib.request.urlopen(images) as f:\n                file_contents = f.read().decode(\"utf-8\")\n                images = file_contents.strip().split(\"\\n\")\n        elif not os.path.exists(images):\n            raise FileNotFoundError(f\"{images} does not exist.\")\n\n    elif not isinstance(images, list):\n        raise ValueError(\"images must be a list or a URL.\")\n\n    mosaic = MosaicJSON.from_urls(images)\n    with MosaicBackend(output, mosaic_def=mosaic) as f:\n        f.write(overwrite=True)\n</code></pre>"},{"location":"stac/#beamgis.stac.download_data_catalogs","title":"<code>download_data_catalogs(out_dir=None, quiet=True, overwrite=False)</code>","text":"<p>Download geospatial data catalogs from https://github.com/giswqs/geospatial-data-catalogs.</p> <p>Parameters:</p> Name Type Description Default <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to None.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Whether to suppress the download progress bar. Defaults to True.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the existing data catalog. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The path to the downloaded data catalog.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def download_data_catalogs(\n    out_dir: Optional[str] = None,\n    quiet: Optional[bool] = True,\n    overwrite: Optional[bool] = False,\n) -&gt; str:\n    \"\"\"Download geospatial data catalogs from https://github.com/giswqs/geospatial-data-catalogs.\n\n    Args:\n        out_dir (str, optional): The output directory. Defaults to None.\n        quiet (bool, optional): Whether to suppress the download progress bar. Defaults to True.\n        overwrite (bool, optional): Whether to overwrite the existing data catalog. Defaults to False.\n\n    Returns:\n        str: The path to the downloaded data catalog.\n    \"\"\"\n    import tempfile\n    import gdown\n    import zipfile\n\n    if out_dir is None:\n        out_dir = tempfile.gettempdir()\n    elif not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    url = \"https://github.com/giswqs/geospatial-data-catalogs/archive/refs/heads/master.zip\"\n\n    out_file = os.path.join(out_dir, \"geospatial-data-catalogs.zip\")\n    work_dir = os.path.join(out_dir, \"geospatial-data-catalogs-master\")\n\n    if os.path.exists(work_dir) and not overwrite:\n        return work_dir\n    else:\n        gdown.download(url, out_file, quiet=quiet)\n        with zipfile.ZipFile(out_file, \"r\") as zip_ref:\n            zip_ref.extractall(out_dir)\n        return work_dir\n</code></pre>"},{"location":"stac/#beamgis.stac.flatten_dict","title":"<code>flatten_dict(my_dict, parent_key=False, sep='.')</code>","text":"<p>Flattens a nested dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>my_dict</code> <code>dict</code> <p>The dictionary to flatten.</p> required <code>parent_key</code> <code>bool</code> <p>Whether to include the parent key. Defaults to False.</p> <code>False</code> <code>sep</code> <code>str</code> <p>The separator to use. Defaults to '.'.</p> <code>'.'</code> <p>Returns:</p> Type Description <code>dict</code> <p>The flattened dictionary.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def flatten_dict(my_dict, parent_key=False, sep=\".\"):\n    \"\"\"Flattens a nested dictionary.\n\n    Args:\n        my_dict (dict): The dictionary to flatten.\n        parent_key (bool, optional): Whether to include the parent key. Defaults to False.\n        sep (str, optional): The separator to use. Defaults to '.'.\n\n    Returns:\n        dict: The flattened dictionary.\n    \"\"\"\n\n    flat_dict = {}\n    for key, value in my_dict.items():\n        if not isinstance(value, dict):\n            flat_dict[key] = value\n        else:\n            sub_dict = flatten_dict(value)\n            for sub_key, sub_value in sub_dict.items():\n                if parent_key:\n                    flat_dict[parent_key + sep + sub_key] = sub_value\n                else:\n                    flat_dict[sub_key] = sub_value\n\n    return flat_dict\n</code></pre>"},{"location":"stac/#beamgis.stac.maxar_all_items","title":"<code>maxar_all_items(collection_id, return_gdf=True, assets=['visual'], verbose=True, **kwargs)</code>","text":"<p>Retrieve STAC items from Maxar's public STAC API.</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>str</code> <p>The collection ID, e.g., Kahramanmaras-turkey-earthquake-23 Use maxar_collections() to retrieve all available collection IDs.</p> required <code>return_gdf</code> <code>bool</code> <p>If True, return a GeoDataFrame. Defaults to True.</p> <code>True</code> <code>assets</code> <code>list</code> <p>A list of asset names to include in the GeoDataFrame. It can be \"visual\", \"ms_analytic\", \"pan_analytic\", \"data-mask\". Defaults to ['visual'].</p> <code>['visual']</code> <code>verbose</code> <code>bool</code> <p>If True, print progress. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the pystac Catalog.from_file() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GeoDataFrame | pystac.ItemCollection</code> <p>If return_gdf is True, return a GeoDataFrame.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def maxar_all_items(\n    collection_id: str,\n    return_gdf: Optional[bool] = True,\n    assets: Optional[List] = [\"visual\"],\n    verbose: Optional[bool] = True,\n    **kwargs,\n):\n    \"\"\"Retrieve STAC items from Maxar's public STAC API.\n\n    Args:\n        collection_id (str): The collection ID, e.g., Kahramanmaras-turkey-earthquake-23\n            Use maxar_collections() to retrieve all available collection IDs.\n        return_gdf (bool, optional): If True, return a GeoDataFrame. Defaults to True.\n        assets (list, optional): A list of asset names to include in the GeoDataFrame.\n            It can be \"visual\", \"ms_analytic\", \"pan_analytic\", \"data-mask\". Defaults to ['visual'].\n        verbose (bool, optional): If True, print progress. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the pystac Catalog.from_file() method.\n\n    Returns:\n        GeoDataFrame | pystac.ItemCollection: If return_gdf is True, return a GeoDataFrame.\n    \"\"\"\n\n    child_ids = maxar_child_collections(collection_id, **kwargs)\n    for index, child_id in enumerate(child_ids):\n        if verbose:\n            print(\n                f\"Processing ({str(index+1).zfill(len(str(len(child_ids))))} out of {len(child_ids)}): {child_id} ...\"\n            )\n        items = maxar_items(collection_id, child_id, return_gdf, assets, **kwargs)\n        if return_gdf:\n            if child_id == child_ids[0]:\n                gdf = items\n            else:\n                gdf = pd.concat([gdf, items], ignore_index=True)\n        else:\n            if child_id == child_ids[0]:\n                items_all = items\n            else:\n                items_all.extend(items)\n\n    if return_gdf:\n        return gdf\n    else:\n        return items_all\n</code></pre>"},{"location":"stac/#beamgis.stac.maxar_child_collections","title":"<code>maxar_child_collections(collection_id, return_ids=True, **kwargs)</code>","text":"<p>Get a list of Maxar child collections.</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>str</code> <p>The collection ID, e.g., Kahramanmaras-turkey-earthquake-23 Use maxar_collections() to retrieve all available collection IDs.</p> required <code>return_ids</code> <code>bool</code> <p>Whether to return the collection ids. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the pystac Catalog.from_file() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of Maxar child collections.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def maxar_child_collections(\n    collection_id: str, return_ids: Optional[bool] = True, **kwargs\n) -&gt; List:\n    \"\"\"Get a list of Maxar child collections.\n\n    Args:\n        collection_id (str): The collection ID, e.g., Kahramanmaras-turkey-earthquake-23\n            Use maxar_collections() to retrieve all available collection IDs.\n        return_ids (bool, optional): Whether to return the collection ids. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the pystac Catalog.from_file() method.\n\n    Returns:\n        list: A list of Maxar child collections.\n    \"\"\"\n\n    import tempfile\n    from pystac import Catalog\n\n    file_path = os.path.join(tempfile.gettempdir(), f\"maxar-{collection_id}.txt\")\n    if return_ids:\n        if os.path.exists(file_path):\n            with open(file_path, \"r\") as f:\n                return [line.strip() for line in f.readlines()]\n\n    if \"MAXAR_STAC_API\" in os.environ:\n        url = os.environ[\"MAXAR_STAC_API\"]\n    else:\n        url = \"https://maxar-opendata.s3.amazonaws.com/events/catalog.json\"\n\n    root_catalog = Catalog.from_file(url, **kwargs)\n\n    collections = root_catalog.get_child(collection_id).get_collections()\n\n    if return_ids:\n        collection_ids = [collection.id for collection in collections]\n        with open(file_path, \"w\") as f:\n            f.write(\"\\n\".join(collection_ids))\n        return collection_ids\n\n    else:\n        return collections\n</code></pre>"},{"location":"stac/#beamgis.stac.maxar_collection_url","title":"<code>maxar_collection_url(collection, dtype='geojson', raw=True)</code>","text":"<p>Retrieve the URL to a Maxar Open Data collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The collection ID, e.g., Kahramanmaras-turkey-earthquake-23. Use maxar_collections() to retrieve all available collection IDs.</p> required <code>dtype</code> <code>str</code> <p>The data type. It can be 'geojson' or 'tsv'. Defaults to 'geojson'.</p> <code>'geojson'</code> <code>raw</code> <code>bool</code> <p>If True, return the raw URL. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The URL to the collection.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def maxar_collection_url(collection, dtype=\"geojson\", raw=True):\n    \"\"\"Retrieve the URL to a Maxar Open Data collection.\n\n    Args:\n        collection (str): The collection ID, e.g., Kahramanmaras-turkey-earthquake-23.\n            Use maxar_collections() to retrieve all available collection IDs.\n        dtype (str, optional): The data type. It can be 'geojson' or 'tsv'. Defaults to 'geojson'.\n        raw (bool, optional): If True, return the raw URL. Defaults to True.\n\n    Returns:\n        str: The URL to the collection.\n    \"\"\"\n    collections = maxar_collections()\n    if collection not in collections:\n        raise ValueError(\n            f\"Invalid collection name. Use maxar_collections() to retrieve all available collection IDs.\"\n        )\n\n    if dtype not in [\"geojson\", \"tsv\"]:\n        raise ValueError(f\"Invalid dtype. It can be 'geojson' or 'tsv'.\")\n\n    if raw:\n        url = f\"https://raw.githubusercontent.com/giswqs/maxar-open-data/master/datasets/{collection}.{dtype}\"\n    else:\n        url = f\"https://github.com/giswqs/maxar-open-data/blob/master/datasets/{collection}.{dtype}\"\n    return url\n</code></pre>"},{"location":"stac/#beamgis.stac.maxar_collections","title":"<code>maxar_collections(return_ids=True, **kwargs)</code>","text":"<p>Get a list of Maxar collections.</p> <p>Parameters:</p> Name Type Description Default <code>return_ids</code> <code>bool</code> <p>Whether to return the collection ids. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the pystac Catalog.from_file() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list </code> <p>A list of Maxar collections.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def maxar_collections(return_ids: Optional[bool] = True, **kwargs) -&gt; List:\n    \"\"\"Get a list of Maxar collections.\n\n    Args:\n        return_ids (bool, optional): Whether to return the collection ids. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the pystac Catalog.from_file() method.\n\n    Returns:\n        list : A list of Maxar collections.\n    \"\"\"\n\n    import tempfile\n    from pystac import Catalog\n    import pandas as pd\n\n    if return_ids:\n        url = \"https://raw.githubusercontent.com/giswqs/maxar-open-data/master/datasets.csv\"\n        df = pd.read_csv(url)\n        return df[\"dataset\"].tolist()\n\n    file_path = os.path.join(tempfile.gettempdir(), \"maxar-collections.txt\")\n    if return_ids:\n        if os.path.exists(file_path):\n            with open(file_path, \"r\") as f:\n                return [line.strip() for line in f.readlines()]\n\n    if \"MAXAR_STAC_API\" in os.environ:\n        url = os.environ[\"MAXAR_STAC_API\"]\n    else:\n        url = \"https://maxar-opendata.s3.amazonaws.com/events/catalog.json\"\n\n    root_catalog = Catalog.from_file(url, **kwargs)\n\n    collections = root_catalog.get_collections()\n\n    # if return_ids:\n    #     collection_ids = [collection.id for collection in collections]\n    #     with open(file_path, \"w\") as f:\n    #         f.write(\"\\n\".join(collection_ids))\n\n    #     return collection_ids\n    # else:\n    return collections\n</code></pre>"},{"location":"stac/#beamgis.stac.maxar_download","title":"<code>maxar_download(images, out_dir=None, quiet=False, proxy=None, speed=None, use_cookies=True, verify=True, id=None, fuzzy=False, resume=False, overwrite=False)</code>","text":"<p>Download Mxar Open Data images.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>str | images</code> <p>The list of image links or a file path to a geojson or tsv containing the Maxar download links.</p> required <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to None.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress terminal output. Default is False.</p> <code>False</code> <code>proxy</code> <code>str</code> <p>Proxy. Defaults to None.</p> <code>None</code> <code>speed</code> <code>float</code> <p>Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.</p> <code>None</code> <code>use_cookies</code> <code>bool</code> <p>Flag to use cookies. Defaults to True.</p> <code>True</code> <code>verify</code> <code>bool | str</code> <p>Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.</p> <code>True</code> <code>id</code> <code>str</code> <p>Google Drive's file ID. Defaults to None.</p> <code>None</code> <code>fuzzy</code> <code>bool</code> <p>Fuzzy extraction of Google Drive's file Id. Defaults to False.</p> <code>False</code> <code>resume</code> <code>bool</code> <p>Resume the download from existing tmp file if possible. Defaults to False.</p> <code>False</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the file if it already exists. Defaults to False.</p> <code>False</code> Source code in <code>beamgis/stac.py</code> <pre><code>def maxar_download(\n    images,\n    out_dir=None,\n    quiet=False,\n    proxy=None,\n    speed=None,\n    use_cookies=True,\n    verify=True,\n    id=None,\n    fuzzy=False,\n    resume=False,\n    overwrite=False,\n):\n    \"\"\"Download Mxar Open Data images.\n\n    Args:\n        images (str | images): The list of image links or a file path to a geojson or tsv containing the Maxar download links.\n        out_dir (str, optional): The output directory. Defaults to None.\n        quiet (bool, optional): Suppress terminal output. Default is False.\n        proxy (str, optional): Proxy. Defaults to None.\n        speed (float, optional): Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.\n        use_cookies (bool, optional): Flag to use cookies. Defaults to True.\n        verify (bool | str, optional): Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string,\n            in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.\n        id (str, optional): Google Drive's file ID. Defaults to None.\n        fuzzy (bool, optional): Fuzzy extraction of Google Drive's file Id. Defaults to False.\n        resume (bool, optional): Resume the download from existing tmp file if possible. Defaults to False.\n        overwrite (bool, optional): Overwrite the file if it already exists. Defaults to False.\n\n    \"\"\"\n    import gdown\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if isinstance(images, str):\n        if images.endswith(\".geojson\"):\n            import geopandas as gpd\n\n            data = gpd.read_file(images)\n            images = data[\"visual\"].tolist()\n        elif images.endswith(\".tsv\"):\n            import pandas as pd\n\n            data = pd.read_csv(images, sep=\"\\t\")\n            images = data[\"visual\"].tolist()\n        else:\n            raise ValueError(f\"Invalid file type. It can be 'geojson' or 'tsv'.\")\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    for index, image in enumerate(images):\n        items = image.split(\"/\")\n        file_name = items[7] + \".tif\"\n        dir_name = items[-1].split(\"-\")[0]\n        if not os.path.exists(os.path.join(out_dir, dir_name)):\n            os.makedirs(os.path.join(out_dir, dir_name))\n        out_file = os.path.join(out_dir, dir_name, file_name)\n        if os.path.exists(out_file) and (not overwrite):\n            print(f\"{out_file} already exists. Skipping...\")\n            continue\n        if not quiet:\n            print(\n                f\"Downloading {str(index+1).zfill(len(str(len(images))))} out of {len(images)}: {dir_name}/{file_name}\"\n            )\n\n        gdown.download(\n            image, out_file, quiet, proxy, speed, use_cookies, verify, id, fuzzy, resume\n        )\n</code></pre>"},{"location":"stac/#beamgis.stac.maxar_items","title":"<code>maxar_items(collection_id, child_id, return_gdf=True, assets=['visual'], **kwargs)</code>","text":"<p>Retrieve STAC items from Maxar's public STAC API.</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>str</code> <p>The collection ID, e.g., Kahramanmaras-turkey-earthquake-23 Use maxar_collections() to retrieve all available collection IDs.</p> required <code>child_id</code> <code>str</code> <p>The child collection ID, e.g., 1050050044DE7E00 Use maxar_child_collections() to retrieve all available child collection IDs.</p> required <code>return_gdf</code> <code>bool</code> <p>If True, return a GeoDataFrame. Defaults to True.</p> <code>True</code> <code>assets</code> <code>list</code> <p>A list of asset names to include in the GeoDataFrame. It can be \"visual\", \"ms_analytic\", \"pan_analytic\", \"data-mask\". Defaults to ['visual'].</p> <code>['visual']</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the pystac Catalog.from_file() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GeoDataFrame | pystac.ItemCollection</code> <p>If return_gdf is True, return a GeoDataFrame.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def maxar_items(\n    collection_id: str,\n    child_id: str,\n    return_gdf: Optional[bool] = True,\n    assets: Optional[List] = [\"visual\"],\n    **kwargs,\n):\n    \"\"\"Retrieve STAC items from Maxar's public STAC API.\n\n    Args:\n        collection_id (str): The collection ID, e.g., Kahramanmaras-turkey-earthquake-23\n            Use maxar_collections() to retrieve all available collection IDs.\n        child_id (str): The child collection ID, e.g., 1050050044DE7E00\n            Use maxar_child_collections() to retrieve all available child collection IDs.\n        return_gdf (bool, optional): If True, return a GeoDataFrame. Defaults to True.\n        assets (list, optional): A list of asset names to include in the GeoDataFrame.\n            It can be \"visual\", \"ms_analytic\", \"pan_analytic\", \"data-mask\". Defaults to ['visual'].\n        **kwargs: Additional keyword arguments to pass to the pystac Catalog.from_file() method.\n\n    Returns:\n        GeoDataFrame | pystac.ItemCollection: If return_gdf is True, return a GeoDataFrame.\n    \"\"\"\n\n    import pickle\n    import tempfile\n    from pystac import Catalog, ItemCollection\n\n    file_path = os.path.join(\n        tempfile.gettempdir(), f\"maxar-{collection_id}-{child_id}.pkl\"\n    )\n\n    if os.path.exists(file_path):\n        with open(file_path, \"rb\") as f:\n            items = pickle.load(f)\n        if return_gdf:\n            import geopandas as gpd\n\n            gdf = gpd.GeoDataFrame.from_features(\n                pystac.ItemCollection(items).to_dict(), crs=\"EPSG:4326\"\n            )\n            # convert bbox column type from list to string\n            gdf[\"proj:bbox\"] = [\",\".join(map(str, l)) for l in gdf[\"proj:bbox\"]]\n            if assets is not None:\n                if isinstance(assets, str):\n                    assets = [assets]\n                elif not isinstance(assets, list):\n                    raise ValueError(\"assets must be a list or a string.\")\n\n                for asset in assets:\n                    links = []\n                    for item in items:\n                        if asset in item.get_assets():\n                            link = item.get_assets()[asset].get_absolute_href()\n                            links.append(link)\n                        else:\n                            links.append(\"\")\n\n                    gdf[asset] = links\n\n            return gdf\n        else:\n            return items\n\n    if \"MAXAR_STAC_API\" in os.environ:\n        url = os.environ[\"MAXAR_STAC_API\"]\n    else:\n        url = \"https://maxar-opendata.s3.amazonaws.com/events/catalog.json\"\n\n    root_catalog = Catalog.from_file(url, **kwargs)\n\n    collection = root_catalog.get_child(collection_id)\n    child = collection.get_child(child_id)\n\n    items = ItemCollection(child.get_all_items())\n\n    with open(file_path, \"wb\") as f:\n        pickle.dump(items, f)\n\n    if return_gdf:\n        import geopandas as gpd\n\n        gdf = gpd.GeoDataFrame.from_features(\n            pystac.ItemCollection(items).to_dict(), crs=\"EPSG:4326\"\n        )\n        # convert bbox column type from list to string\n        gdf[\"proj:bbox\"] = [\",\".join(map(str, l)) for l in gdf[\"proj:bbox\"]]\n        if assets is not None:\n            if isinstance(assets, str):\n                assets = [assets]\n            elif not isinstance(assets, list):\n                raise ValueError(\"assets must be a list or a string.\")\n\n            for asset in assets:\n                links = []\n                for item in items:\n                    if asset in item.get_assets():\n                        link = item.get_assets()[asset].get_absolute_href()\n                        links.append(link)\n                    else:\n                        links.append(\"\")\n\n                gdf[asset] = links\n\n        return gdf\n    else:\n        return items\n</code></pre>"},{"location":"stac/#beamgis.stac.maxar_refresh","title":"<code>maxar_refresh()</code>","text":"<p>Refresh the cached Maxar STAC items.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def maxar_refresh():\n    \"\"\"Refresh the cached Maxar STAC items.\"\"\"\n    import tempfile\n\n    temp_dir = tempfile.gettempdir()\n    for f in os.listdir(temp_dir):\n        if f.startswith(\"maxar-\"):\n            os.remove(os.path.join(temp_dir, f))\n\n    print(\"Maxar STAC items cache has been refreshed.\")\n</code></pre>"},{"location":"stac/#beamgis.stac.maxar_search","title":"<code>maxar_search(collection, start_date=None, end_date=None, bbox=None, within=False, align=True)</code>","text":"<p>Search Maxar Open Data by collection ID, date range, and/or bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The collection ID, e.g., Kahramanmaras-turkey-earthquake-23. Use maxar_collections() to retrieve all available collection IDs.</p> required <code>start_date</code> <code>str</code> <p>The start date, e.g., 2023-01-01. Defaults to None.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>The end date, e.g., 2023-12-31. Defaults to None.</p> <code>None</code> <code>bbox</code> <code>list | GeoDataFrame</code> <p>The bounding box to filter by. Can be a list of 4 coordinates or a file path or a GeoDataFrame.</p> <code>None</code> <code>within</code> <code>bool</code> <p>Whether to filter by the bounding box or the bounding box's interior. Defaults to False.</p> <code>False</code> <code>align</code> <code>bool</code> <p>If True, automatically aligns GeoSeries based on their indices. If False, the order of elements is preserved.</p> <code>True</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame containing the search results.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def maxar_search(\n    collection, start_date=None, end_date=None, bbox=None, within=False, align=True\n):\n    \"\"\"Search Maxar Open Data by collection ID, date range, and/or bounding box.\n\n    Args:\n        collection (str): The collection ID, e.g., Kahramanmaras-turkey-earthquake-23.\n            Use maxar_collections() to retrieve all available collection IDs.\n        start_date (str, optional): The start date, e.g., 2023-01-01. Defaults to None.\n        end_date (str, optional): The end date, e.g., 2023-12-31. Defaults to None.\n        bbox (list | GeoDataFrame): The bounding box to filter by. Can be a list of 4 coordinates or a file path or a GeoDataFrame.\n        within (bool, optional): Whether to filter by the bounding box or the bounding box's interior. Defaults to False.\n        align (bool, optional): If True, automatically aligns GeoSeries based on their indices. If False, the order of elements is preserved.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame containing the search results.\n    \"\"\"\n    import datetime\n    import pandas as pd\n    import geopandas as gpd\n    from shapely.geometry import Polygon\n\n    collections = maxar_collections()\n    if collection not in collections:\n        raise ValueError(\n            f\"Invalid collection name. Use maxar_collections() to retrieve all available collection IDs.\"\n        )\n\n    url = f\"https://raw.githubusercontent.com/giswqs/maxar-open-data/master/datasets/{collection}.geojson\"\n    data = gpd.read_file(url)\n\n    if bbox is not None:\n        bbox = gpd.GeoDataFrame(\n            geometry=[Polygon.from_bounds(*bbox)],\n            crs=\"epsg:4326\",\n        )\n        if within:\n            data = data[data.within(bbox.unary_union, align=align)]\n        else:\n            data = data[data.intersects(bbox.unary_union, align=align)]\n\n    date_field = \"datetime\"\n    new_field = f\"{date_field}_temp\"\n    data[new_field] = pd.to_datetime(data[date_field])\n\n    if end_date is None:\n        end_date = datetime.datetime.now().strftime(\"%Y-%m-%d\")\n\n    if start_date is None:\n        start_date = data[new_field].min()\n\n    mask = (data[new_field] &gt;= start_date) &amp; (data[new_field] &lt;= end_date)\n    result = data.loc[mask]\n    return result.drop(columns=[new_field], axis=1)\n</code></pre>"},{"location":"stac/#beamgis.stac.maxar_tile_url","title":"<code>maxar_tile_url(collection, tile, dtype='geojson', raw=True)</code>","text":"<p>Retrieve the URL to a Maxar Open Data tile.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The collection ID, e.g., Kahramanmaras-turkey-earthquake-23. Use maxar_collections() to retrieve all available collection IDs.</p> required <code>tile</code> <code>str</code> <p>The tile ID, e.g., 10300500D9F8E600.</p> required <code>dtype</code> <code>str</code> <p>The data type. It can be 'geojson', 'json' or 'tsv'. Defaults to 'geojson'.</p> <code>'geojson'</code> <code>raw</code> <code>bool</code> <p>If True, return the raw URL. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The URL to the tile.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def maxar_tile_url(collection, tile, dtype=\"geojson\", raw=True):\n    \"\"\"Retrieve the URL to a Maxar Open Data tile.\n\n    Args:\n\n        collection (str): The collection ID, e.g., Kahramanmaras-turkey-earthquake-23.\n            Use maxar_collections() to retrieve all available collection IDs.\n        tile (str): The tile ID, e.g., 10300500D9F8E600.\n        dtype (str, optional): The data type. It can be 'geojson', 'json' or 'tsv'. Defaults to 'geojson'.\n        raw (bool, optional): If True, return the raw URL. Defaults to True.\n\n    Returns:\n        str: The URL to the tile.\n    \"\"\"\n\n    collections = maxar_collections()\n    if collection not in collections:\n        raise ValueError(\n            f\"Invalid collection name. Use maxar_collections() to retrieve all available collection IDs.\"\n        )\n\n    if dtype not in [\"geojson\", \"json\", \"tsv\"]:\n        raise ValueError(f\"Invalid dtype. It can be 'geojson', 'json' or 'tsv'.\")\n\n    if raw:\n        url = f\"https://raw.githubusercontent.com/giswqs/maxar-open-data/master/datasets/{collection}/{tile}.{dtype}\"\n    else:\n        url = f\"https://github.com/giswqs/maxar-open-data/blob/master/datasets/{collection}/{tile}.{dtype}\"\n\n    return url\n</code></pre>"},{"location":"stac/#beamgis.stac.oam_search","title":"<code>oam_search(bbox=None, start_date=None, end_date=None, limit=100, return_gdf=True, **kwargs)</code>","text":"<p>Search OpenAerialMap (https://openaerialmap.org) and return a GeoDataFrame or list of image metadata.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list | str</code> <p>The bounding box [xmin, ymin, xmax, ymax] to search within. Defaults to None.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>The start date to search within, such as \"2015-04-20T00:00:00.000Z\". Defaults to None.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>The end date to search within, such as \"2015-04-21T00:00:00.000Z\". Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of results to return. Defaults to 100.</p> <code>100</code> <code>return_gdf</code> <code>bool</code> <p>If True, return a GeoDataFrame, otherwise return a list. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the API. See https://hotosm.github.io/oam-api/</p> <code>{}</code> <p>Returns:</p> Type Description <code>GeoDataFrame | list</code> <p>If return_gdf is True, return a GeoDataFrame. Otherwise, return a list.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def oam_search(\n    bbox=None, start_date=None, end_date=None, limit=100, return_gdf=True, **kwargs\n):\n    \"\"\"Search OpenAerialMap (https://openaerialmap.org) and return a GeoDataFrame or list of image metadata.\n\n    Args:\n        bbox (list | str, optional): The bounding box [xmin, ymin, xmax, ymax] to search within. Defaults to None.\n        start_date (str, optional): The start date to search within, such as \"2015-04-20T00:00:00.000Z\". Defaults to None.\n        end_date (str, optional): The end date to search within, such as \"2015-04-21T00:00:00.000Z\". Defaults to None.\n        limit (int, optional): The maximum number of results to return. Defaults to 100.\n        return_gdf (bool, optional): If True, return a GeoDataFrame, otherwise return a list. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the API. See https://hotosm.github.io/oam-api/\n\n    Returns:\n        GeoDataFrame | list: If return_gdf is True, return a GeoDataFrame. Otherwise, return a list.\n    \"\"\"\n\n    from shapely.geometry import Polygon\n    import geopandas as gpd\n\n    url = \"https://api.openaerialmap.org/meta\"\n    if bbox is not None:\n        if isinstance(bbox, str):\n            bbox = [float(x) for x in bbox.split(\",\")]\n        if not isinstance(bbox, list):\n            raise ValueError(\"bbox must be a list.\")\n        if len(bbox) != 4:\n            raise ValueError(\"bbox must be a list of 4 numbers.\")\n        bbox = \",\".join(map(str, bbox))\n        kwargs[\"bbox\"] = bbox\n\n    if start_date is not None:\n        kwargs[\"acquisition_from\"] = start_date\n\n    if end_date is not None:\n        kwargs[\"acquisition_to\"] = end_date\n\n    if limit is not None:\n        kwargs[\"limit\"] = limit\n\n    try:\n        r = requests.get(url, params=kwargs).json()\n        if \"results\" in r:\n            results = []\n            for result in r[\"results\"]:\n                if \"geojson\" in result:\n                    del result[\"geojson\"]\n                if \"projection\" in result:\n                    del result[\"projection\"]\n                if \"footprint\" in result:\n                    del result[\"footprint\"]\n                result = flatten_dict(result)\n                results.append(result)\n\n            if not return_gdf:\n                return results\n            else:\n                df = pd.DataFrame(results)\n\n                polygons = [Polygon.from_bounds(*bbox) for bbox in df[\"bbox\"]]\n                gdf = gpd.GeoDataFrame(geometry=polygons, crs=\"epsg:4326\")\n\n                return pd.concat([gdf, df], axis=1)\n\n        else:\n            print(\"No results found.\")\n            return None\n\n    except Exception as e:\n        return None\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_assets","title":"<code>stac_assets(url=None, collection=None, item=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get all assets of a STAC item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of assets.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_assets(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get all assets of a STAC item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        list: A list of assets.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if isinstance(url, pystac.Item):\n        try:\n            url = url.self_href\n        except Exception as e:\n            print(e)\n\n    if url is not None:\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(f\"{titiler_endpoint}/stac/assets\", params=kwargs).json()\n    else:\n        r = requests.get(titiler_endpoint.url_for_stac_assets(), params=kwargs).json()\n\n    return r\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_bands","title":"<code>stac_bands(url=None, collection=None, item=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get band names of a single SpatialTemporal Asset Catalog (STAC) item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of band names</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_bands(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get band names of a single SpatialTemporal Asset Catalog (STAC) item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        list: A list of band names\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if isinstance(url, pystac.Item):\n        try:\n            url = url.self_href\n        except Exception as e:\n            print(e)\n\n    if url is not None:\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(f\"{titiler_endpoint}/stac/assets\", params=kwargs).json()\n    else:\n        r = requests.get(titiler_endpoint.url_for_stac_assets(), params=kwargs).json()\n\n    return r\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_bounds","title":"<code>stac_bounds(url=None, collection=None, item=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the bounding box of a single SpatialTemporal Asset Catalog (STAC) item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of values representing [left, bottom, right, top]</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_bounds(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get the bounding box of a single SpatialTemporal Asset Catalog (STAC) item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        list: A list of values representing [left, bottom, right, top]\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if isinstance(url, pystac.Item):\n        try:\n            url = url.self_href\n        except Exception as e:\n            print(e)\n\n    if url is not None:\n        kwargs[\"url\"] = url\n        response = requests.get(url)\n        r = response.json()\n        if \"mosaicjson\" in r:\n            if \"bounds\" in r:\n                return r[\"bounds\"]\n\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(f\"{titiler_endpoint}/stac/bounds\", params=kwargs).json()\n    else:\n        r = requests.get(titiler_endpoint.url_for_stac_bounds(), params=kwargs).json()\n\n    bounds = r[\"bounds\"]\n    return bounds\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_center","title":"<code>stac_center(url=None, collection=None, item=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the centroid of a single SpatialTemporal Asset Catalog (STAC) item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple representing (longitude, latitude)</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_center(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; Tuple[float, float]:\n    \"\"\"Get the centroid of a single SpatialTemporal Asset Catalog (STAC) item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        tuple: A tuple representing (longitude, latitude)\n    \"\"\"\n\n    if isinstance(url, pystac.Item):\n        try:\n            url = url.self_href\n        except Exception as e:\n            print(e)\n\n    bounds = stac_bounds(url, collection, item, titiler_endpoint, **kwargs)\n    center = ((bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2)  # (lon, lat)\n    return center\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_client","title":"<code>stac_client(url, headers=None, parameters=None, ignore_conformance=False, modifier=None, request_modifier=None, stac_io=None, return_col_id=False, get_root=True, **kwargs)</code>","text":"<p>Get the STAC client. It wraps the pystac.Client.open() method. See     https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.open</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of a STAC Catalog.</p> required <code>headers</code> <code>dict</code> <p>A dictionary of additional headers to use in all requests made to any part of this Catalog/API. Defaults to None.</p> <code>None</code> <code>parameters</code> <code>dict</code> <p>Optional dictionary of query string parameters to include in all requests. Defaults to None.</p> <code>None</code> <code>ignore_conformance</code> <code>bool</code> <p>Ignore any advertised Conformance Classes in this Catalog/API. This means that functions will skip checking conformance, and may throw an unknown error if that feature is not supported, rather than a NotImplementedError. Defaults to False.</p> <code>False</code> <code>modifier</code> <code>function</code> <p>A callable that modifies the children collection and items returned by this Client. This can be useful for injecting authentication parameters into child assets to access data from non-public sources. Defaults to None.</p> <code>None</code> <code>request_modifier</code> <code>function</code> <p>A callable that either modifies a Request instance or returns a new one. This can be useful for injecting Authentication headers and/or signing fully-formed requests (e.g. signing requests using AWS SigV4). The callable should expect a single argument, which will be an instance of requests.Request. If the callable returns a requests.Request, that will be used. Alternately, the callable may simply modify the provided request object and return None.</p> <code>None</code> <code>stac_io</code> <code>pystac.stac_io</code> <p>A StacApiIO object to use for I/O requests. Generally, leave this to the default. However in cases where customized I/O processing is required, a custom instance can be provided here.</p> <code>None</code> <code>return_col_id</code> <code>bool</code> <p>Return the collection ID. Defaults to False.</p> <code>False</code> <code>get_root</code> <code>bool</code> <p>Get the root link of the STAC object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the pystac.Client.open() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>pystac.Client</code> <p>The STAC client.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_client(\n    url: str,\n    headers: Optional[Dict] = None,\n    parameters: Optional[Dict] = None,\n    ignore_conformance: Optional[bool] = False,\n    modifier: Optional[Callable] = None,\n    request_modifier: Optional[Callable] = None,\n    stac_io=None,\n    return_col_id: Optional[bool] = False,\n    get_root: Optional[bool] = True,\n    **kwargs,\n):\n    \"\"\"Get the STAC client. It wraps the pystac.Client.open() method. See\n        https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.open\n\n    Args:\n        url (str): The URL of a STAC Catalog.\n        headers (dict, optional):  A dictionary of additional headers to use in all requests\n            made to any part of this Catalog/API. Defaults to None.\n        parameters (dict, optional): Optional dictionary of query string parameters to include in all requests.\n            Defaults to None.\n        ignore_conformance (bool, optional): Ignore any advertised Conformance Classes in this Catalog/API.\n            This means that functions will skip checking conformance, and may throw an unknown error\n            if that feature is not supported, rather than a NotImplementedError. Defaults to False.\n        modifier (function, optional): A callable that modifies the children collection and items\n            returned by this Client. This can be useful for injecting authentication parameters\n            into child assets to access data from non-public sources. Defaults to None.\n        request_modifier (function, optional): A callable that either modifies a Request instance or returns\n            a new one. This can be useful for injecting Authentication headers and/or signing fully-formed\n            requests (e.g. signing requests using AWS SigV4). The callable should expect a single argument,\n            which will be an instance of requests.Request. If the callable returns a requests.Request, that\n            will be used. Alternately, the callable may simply modify the provided request object and\n            return None.\n        stac_io (pystac.stac_io, optional): A StacApiIO object to use for I/O requests. Generally, leave\n            this to the default. However in cases where customized I/O processing is required, a custom\n            instance can be provided here.\n        return_col_id (bool, optional): Return the collection ID. Defaults to False.\n        get_root (bool, optional): Get the root link of the STAC object. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the pystac.Client.open() method.\n\n    Returns:\n        pystac.Client: The STAC client.\n    \"\"\"\n    from pystac_client import Client\n\n    collection_id = None\n\n    if not get_root:\n        return_col_id = False\n\n    try:\n        if get_root:\n            root = stac_root_link(url, return_col_id=return_col_id)\n        else:\n            root = url\n\n        if return_col_id:\n            client = Client.open(\n                root[0],\n                headers,\n                parameters,\n                ignore_conformance,\n                modifier,\n                request_modifier,\n                stac_io,\n                **kwargs,\n            )\n            collection_id = root[1]\n            return client, collection_id\n        else:\n            client = Client.open(\n                root,\n                headers,\n                parameters,\n                ignore_conformance,\n                modifier,\n                request_modifier,\n                stac_io,\n                **kwargs,\n            )\n            return client, client.id\n\n    except Exception as e:\n        print(e)\n        return None\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_collections","title":"<code>stac_collections(url, return_ids=False, get_root=True, **kwargs)</code>","text":"<p>Get the collection IDs of a STAC catalog.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The STAC catalog URL.</p> required <code>return_ids</code> <code>bool</code> <p>Return collection IDs. Defaults to False.</p> <code>False</code> <code>get_root</code> <code>bool</code> <p>Get the root link of the STAC object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the stac_client() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of collection IDs.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_collections(\n    url: str, return_ids: Optional[bool] = False, get_root=True, **kwargs\n) -&gt; List:\n    \"\"\"Get the collection IDs of a STAC catalog.\n\n    Args:\n        url (str): The STAC catalog URL.\n        return_ids (bool, optional): Return collection IDs. Defaults to False.\n        get_root (bool, optional): Get the root link of the STAC object. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the stac_client() method.\n\n    Returns:\n        list: A list of collection IDs.\n    \"\"\"\n    try:\n        client, _ = stac_client(url, get_root=get_root, **kwargs)\n        collections = client.get_all_collections()\n\n        if return_ids:\n            return [c.id for c in collections]\n        else:\n            return collections\n\n    except Exception as e:\n        print(e)\n        return None\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_info","title":"<code>stac_info(url=None, collection=None, item=None, assets=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get band info of a STAC item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band info.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_info(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    assets: Union[str, List] = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get band info of a STAC item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        list: A dictionary of band info.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if isinstance(url, pystac.Item):\n        try:\n            url = url.self_href\n        except Exception as e:\n            print(e)\n\n    if url is not None:\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n    if assets is not None:\n        kwargs[\"assets\"] = assets\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(f\"{titiler_endpoint}/stac/info\", params=kwargs).json()\n    else:\n        r = requests.get(titiler_endpoint.url_for_stac_info(), params=kwargs).json()\n\n    return r\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_info_geojson","title":"<code>stac_info_geojson(url=None, collection=None, item=None, assets=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get band info of a STAC item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band info.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_info_geojson(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    assets: Union[str, List] = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get band info of a STAC item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        list: A dictionary of band info.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if isinstance(url, pystac.Item):\n        try:\n            url = url.self_href\n        except Exception as e:\n            print(e)\n\n    if url is not None:\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n    if assets is not None:\n        kwargs[\"assets\"] = assets\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(f\"{titiler_endpoint}/stac/info.geojson\", params=kwargs).json()\n    else:\n        r = requests.get(\n            titiler_endpoint.url_for_stac_info_geojson(), params=kwargs\n        ).json()\n\n    return r\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_min_max","title":"<code>stac_min_max(url=None, collection=None, item=None, assets=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the min and max values of a STAC item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band statistics.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_min_max(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    assets: Union[str, List] = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get the min and max values of a STAC item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        list: A dictionary of band statistics.\n    \"\"\"\n\n    stats = stac_stats(url, collection, item, assets, titiler_endpoint, **kwargs)\n\n    values = stats.values()\n\n    try:\n        min_values = [v[\"min\"] for v in values]\n        max_values = [v[\"max\"] for v in values]\n\n        return min(min_values), max(max_values)\n    except Exception as e:\n        return None, None\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_object_type","title":"<code>stac_object_type(url, **kwargs)</code>","text":"<p>Get the STAC object type.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The STAC object URL.</p> required <code>**kwargs</code> <p>Keyword arguments for pystac.STACObject.from_file(). Defaults to None.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The STAC object type, can be catalog, collection, or item.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_object_type(url: str, **kwargs) -&gt; str:\n    \"\"\"Get the STAC object type.\n\n    Args:\n        url (str): The STAC object URL.\n        **kwargs: Keyword arguments for pystac.STACObject.from_file(). Defaults to None.\n\n    Returns:\n        str: The STAC object type, can be catalog, collection, or item.\n    \"\"\"\n    try:\n        obj = pystac.STACObject.from_file(url, **kwargs)\n\n        if isinstance(obj, pystac.Collection):\n            return \"collection\"\n        elif isinstance(obj, pystac.Item):\n            return \"item\"\n        elif isinstance(obj, pystac.Catalog):\n            return \"catalog\"\n\n    except Exception as e:\n        print(e)\n        return None\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_pixel_value","title":"<code>stac_pixel_value(lon, lat, url=None, collection=None, item=None, assets=None, titiler_endpoint=None, verbose=True, **kwargs)</code>","text":"<p>Get pixel value from STAC assets.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Longitude of the pixel.</p> required <code>lat</code> <code>float</code> <p>Latitude of the pixel.</p> required <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Print out the error message. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of pixel values for each asset.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_pixel_value(\n    lon: float,\n    lat: float,\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    assets: Union[str, List] = None,\n    titiler_endpoint: Optional[str] = None,\n    verbose: Optional[bool] = True,\n    **kwargs,\n):\n    \"\"\"Get pixel value from STAC assets.\n\n    Args:\n        lon (float): Longitude of the pixel.\n        lat (float): Latitude of the pixel.\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        verbose (bool, optional): Print out the error message. Defaults to True.\n\n    Returns:\n        list: A dictionary of pixel values for each asset.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if isinstance(url, pystac.Item):\n        try:\n            url = url.self_href\n        except Exception as e:\n            print(e)\n\n    if url is not None:\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n\n    if assets is None:\n        assets = stac_assets(\n            url=url,\n            collection=collection,\n            item=item,\n            titiler_endpoint=titiler_endpoint,\n        )\n    kwargs[\"assets\"] = assets\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n\n        r = requests.get(\n            f\"{titiler_endpoint}/stac/point/{lon},{lat}\", params=kwargs\n        ).json()\n    else:\n        r = requests.get(\n            titiler_endpoint.url_for_stac_pixel_value(lon, lat), params=kwargs\n        ).json()\n\n    if \"detail\" in r:\n        if verbose:\n            print(r[\"detail\"])\n        return None\n    else:\n        values = r[\"values\"]\n        if isinstance(assets, str):\n            assets = assets.split(\",\")\n        result = dict(zip(assets, values))\n        return result\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_root_link","title":"<code>stac_root_link(url, return_col_id=False, **kwargs)</code>","text":"<p>Get the root link of a STAC object.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The STAC object URL.</p> required <code>return_col_id</code> <code>bool</code> <p>Return the collection ID if the STAC object is a collection. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Keyword arguments for pystac.STACObject.from_file(). Defaults to None.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The root link of the STAC object.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_root_link(url: str, return_col_id: Optional[bool] = False, **kwargs) -&gt; str:\n    \"\"\"Get the root link of a STAC object.\n\n    Args:\n        url (str): The STAC object URL.\n        return_col_id (bool, optional): Return the collection ID if the STAC object is a collection. Defaults to False.\n        **kwargs: Keyword arguments for pystac.STACObject.from_file(). Defaults to None.\n\n    Returns:\n        str: The root link of the STAC object.\n    \"\"\"\n    collection_id = None\n    try:\n        obj = pystac.STACObject.from_file(url, **kwargs)\n        if isinstance(obj, pystac.Collection):\n            collection_id = obj.id\n        href = obj.get_root_link().get_href()\n\n        if not url.startswith(href):\n            href = obj.get_self_href()\n\n        if return_col_id:\n            return href, collection_id\n        else:\n            return href\n\n    except Exception as e:\n        print(e)\n        if return_col_id:\n            return None, None\n        else:\n            return None\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_search","title":"<code>stac_search(url, method='POST', max_items=None, limit=100, ids=None, collections=None, bbox=None, intersects=None, datetime=None, query=None, filter=None, filter_lang=None, sortby=None, fields=None, get_collection=False, get_items=False, get_assets=False, get_links=False, get_gdf=False, get_info=False, get_root=True, **kwargs)</code>","text":"<p>Search a STAC API. The function wraps the pysatc_client.Client.search() method. See     https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.search</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The STAC API URL.</p> required <code>method</code> <code>str</code> <p>The HTTP method to use when making a request to the service. This must be either \"GET\", \"POST\", or None. If None, this will default to \"POST\". If a \"POST\" request receives a 405 status for the response, it will automatically retry with \"GET\" for all subsequent requests. Defaults to \"POST\".</p> <code>'POST'</code> <code>max_items</code> <code>init</code> <p>The maximum number of items to return from the search, even if there are more matching results. This client to limit the total number of Items returned from the items(), item_collections(), and items_as_dicts methods(). The client will continue to request pages of items until the number of max items is reached. This parameter defaults to 100. Setting this to None will allow iteration over a possibly very large number of results.. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>A recommendation to the service as to the number of items to return per page of results. Defaults to 100.</p> <code>100</code> <code>ids</code> <code>list</code> <p>List of one or more Item ids to filter on. Defaults to None.</p> <code>None</code> <code>collections</code> <code>list</code> <p>List of one or more Collection IDs or pystac.Collection instances. Only Items in one of the provided Collections will be searched. Defaults to None.</p> <code>None</code> <code>bbox</code> <code>list | tuple</code> <p>A list, tuple, or iterator representing a bounding box of 2D or 3D coordinates. Results will be filtered to only those intersecting the bounding box. Defaults to None.</p> <code>None</code> <code>intersects</code> <code>str | dict</code> <p>A string or dictionary representing a GeoJSON geometry, or an object that implements a geo_interface property, as supported by several libraries including Shapely, ArcPy, PySAL, and geojson. Results filtered to only those intersecting the geometry. Defaults to None.</p> <code>None</code> <code>datetime</code> <code>str</code> <p>Either a single datetime or datetime range used to filter results. You may express a single datetime using a datetime.datetime instance, a RFC 3339-compliant timestamp, or a simple date string (see below). Instances of datetime.datetime may be either timezone aware or unaware. Timezone aware instances will be converted to a UTC timestamp before being passed to the endpoint. Timezone unaware instances are assumed to represent UTC timestamps. You may represent a datetime range using a \"/\" separated string as described in the spec, or a list, tuple, or iterator of 2 timestamps or datetime instances. For open-ended ranges, use either \"..\" ('2020-01-01:00:00:00Z/..', ['2020-01-01:00:00:00Z', '..']) or a value of None (['2020-01-01:00:00:00Z', None]). If using a simple date string, the datetime can be specified in YYYY-mm-dd format, optionally truncating to YYYY-mm or just YYYY. Simple date strings will be expanded to include the entire time period. Defaults to None.</p> <code>None</code> <code>query</code> <code>list</code> <p>List or JSON of query parameters as per the STAC API query extension. such as {\"eo:cloud_cover\":{\"lt\":10}}. Defaults to None.</p> <code>None</code> <code>filter</code> <code>dict</code> <p>JSON of query parameters as per the STAC API filter extension. Defaults to None.</p> <code>None</code> <code>filter_lang</code> <code>str</code> <p>Language variant used in the filter body. If filter is a dictionary or not provided, defaults to \u2018cql2-json\u2019. If filter is a string, defaults to cql2-text. Defaults to None.</p> <code>None</code> <code>sortby</code> <code>str | list</code> <p>A single field or list of fields to sort the response by. such as [{ 'field': 'properties.eo:cloud_cover', 'direction': 'asc' }]. Defaults to None.</p> <code>None</code> <code>fields</code> <code>list</code> <p>A list of fields to include in the response. Note this may result in invalid STAC objects, as they may not have required fields. Use items_as_dicts to avoid object unmarshalling errors. Defaults to None.</p> <code>None</code> <code>get_collection</code> <code>bool</code> <p>True to return a pystac.ItemCollection. Defaults to False.</p> <code>False</code> <code>get_items</code> <code>bool</code> <p>True to return a list of pystac.Item. Defaults to False.</p> <code>False</code> <code>get_assets</code> <code>bool</code> <p>True to return a list of pystac.Asset. Defaults to False.</p> <code>False</code> <code>get_links</code> <code>bool</code> <p>True to return a list of links. Defaults to False.</p> <code>False</code> <code>get_gdf</code> <code>bool</code> <p>True to return a GeoDataFrame. Defaults to False.</p> <code>False</code> <code>get_info</code> <code>bool</code> <p>True to return a dictionary of STAC items. Defaults to False.</p> <code>False</code> <code>get_root</code> <code>bool</code> <p>Get the root link of the STAC object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the stac_client() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list | pystac.ItemCollection </code> <p>The search results as a list of links or a pystac.ItemCollection.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_search(\n    url: str,\n    method: Optional[str] = \"POST\",\n    max_items: Optional[int] = None,\n    limit: Optional[int] = 100,\n    ids: Optional[List] = None,\n    collections: Optional[List] = None,\n    bbox: Optional[Union[List, Tuple]] = None,\n    intersects: Optional[Union[str, Dict]] = None,\n    datetime: Optional[str] = None,\n    query: Optional[List] = None,\n    filter: Optional[Dict] = None,\n    filter_lang: Optional[str] = None,\n    sortby: Optional[Union[List, str]] = None,\n    fields: Optional[List] = None,\n    get_collection: Optional[bool] = False,\n    get_items: Optional[bool] = False,\n    get_assets: Optional[bool] = False,\n    get_links: Optional[bool] = False,\n    get_gdf: Optional[bool] = False,\n    get_info: Optional[bool] = False,\n    get_root: Optional[bool] = True,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Search a STAC API. The function wraps the pysatc_client.Client.search() method. See\n        https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.search\n\n    Args:\n        url (str): The STAC API URL.\n        method (str, optional): The HTTP method to use when making a request to the service.\n            This must be either \"GET\", \"POST\", or None. If None, this will default to \"POST\".\n            If a \"POST\" request receives a 405 status for the response, it will automatically\n            retry with \"GET\" for all subsequent requests. Defaults to \"POST\".\n        max_items (init, optional): The maximum number of items to return from the search,\n            even if there are more matching results. This client to limit the total number of\n            Items returned from the items(), item_collections(), and items_as_dicts methods().\n            The client will continue to request pages of items until the number of max items\n            is reached. This parameter defaults to 100. Setting this to None will allow iteration\n            over a possibly very large number of results.. Defaults to None.\n        limit (int, optional): A recommendation to the service as to the number of items to\n            return per page of results. Defaults to 100.\n        ids (list, optional): List of one or more Item ids to filter on. Defaults to None.\n        collections (list, optional): List of one or more Collection IDs or pystac.Collection instances.\n            Only Items in one of the provided Collections will be searched. Defaults to None.\n        bbox (list | tuple, optional): A list, tuple, or iterator representing a bounding box of 2D\n            or 3D coordinates. Results will be filtered to only those intersecting the bounding box.\n            Defaults to None.\n        intersects (str | dict, optional):  A string or dictionary representing a GeoJSON geometry, or\n            an object that implements a __geo_interface__ property, as supported by several\n            libraries including Shapely, ArcPy, PySAL, and geojson. Results filtered to only\n            those intersecting the geometry. Defaults to None.\n        datetime (str, optional): Either a single datetime or datetime range used to filter results.\n            You may express a single datetime using a datetime.datetime instance, a RFC 3339-compliant\n            timestamp, or a simple date string (see below). Instances of datetime.datetime may be either\n            timezone aware or unaware. Timezone aware instances will be converted to a UTC timestamp\n            before being passed to the endpoint. Timezone unaware instances are assumed to represent\n            UTC timestamps. You may represent a datetime range using a \"/\" separated string as described\n            in the spec, or a list, tuple, or iterator of 2 timestamps or datetime instances.\n            For open-ended ranges, use either \"..\" ('2020-01-01:00:00:00Z/..', ['2020-01-01:00:00:00Z', '..'])\n            or a value of None (['2020-01-01:00:00:00Z', None]). If using a simple date string,\n            the datetime can be specified in YYYY-mm-dd format, optionally truncating to\n            YYYY-mm or just YYYY. Simple date strings will be expanded to include the entire\n            time period. Defaults to None.\n        query (list, optional): List or JSON of query parameters as per the STAC API query extension.\n            such as {\"eo:cloud_cover\":{\"lt\":10}}. Defaults to None.\n        filter (dict, optional): JSON of query parameters as per the STAC API filter extension. Defaults to None.\n        filter_lang (str, optional): Language variant used in the filter body. If filter is a dictionary\n            or not provided, defaults to \u2018cql2-json\u2019. If filter is a string, defaults to cql2-text. Defaults to None.\n        sortby (str | list, optional): A single field or list of fields to sort the response by.\n            such as [{ 'field': 'properties.eo:cloud_cover', 'direction': 'asc' }]. Defaults to None.\n        fields (list, optional): A list of fields to include in the response. Note this may result in\n            invalid STAC objects, as they may not have required fields. Use items_as_dicts to avoid object\n            unmarshalling errors. Defaults to None.\n        get_collection (bool, optional): True to return a pystac.ItemCollection. Defaults to False.\n        get_items (bool, optional): True to return a list of pystac.Item. Defaults to False.\n        get_assets (bool, optional): True to return a list of pystac.Asset. Defaults to False.\n        get_links (bool, optional): True to return a list of links. Defaults to False.\n        get_gdf (bool, optional): True to return a GeoDataFrame. Defaults to False.\n        get_info (bool, optional): True to return a dictionary of STAC items. Defaults to False.\n        get_root (bool, optional): Get the root link of the STAC object. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the stac_client() function.\n\n    Returns:\n        list | pystac.ItemCollection : The search results as a list of links or a pystac.ItemCollection.\n    \"\"\"\n\n    client, collection_id = stac_client(\n        url, return_col_id=True, get_root=get_root, **kwargs\n    )\n\n    if client is None:\n        return None\n    else:\n        if isinstance(intersects, dict) and \"geometry\" in intersects:\n            intersects = intersects[\"geometry\"]\n\n        if collection_id is not None and collections is None:\n            collections = [collection_id]\n\n        search = client.search(\n            method=method,\n            max_items=max_items,\n            limit=limit,\n            ids=ids,\n            collections=collections,\n            bbox=bbox,\n            intersects=intersects,\n            datetime=datetime,\n            query=query,\n            filter=filter,\n            filter_lang=filter_lang,\n            sortby=sortby,\n            fields=fields,\n        )\n\n        if get_collection:\n            return search.item_collection()\n        elif get_items:\n            return list(search.items())\n        elif get_assets:\n            assets = {}\n            for item in search.items():\n                assets[item.id] = {}\n                for key, value in item.get_assets().items():\n                    assets[item.id][key] = value.href\n            return assets\n        elif get_links:\n            return [item.get_self_href() for item in search.items()]\n        elif get_gdf:\n            import geopandas as gpd\n\n            gdf = gpd.GeoDataFrame.from_features(\n                search.item_collection().to_dict(), crs=\"EPSG:4326\"\n            )\n            return gdf\n        elif get_info:\n            items = search.items()\n            info = {}\n            for item in items:\n                info[item.id] = {\n                    \"id\": item.id,\n                    \"href\": item.get_self_href(),\n                    \"bands\": list(item.get_assets().keys()),\n                    \"assets\": item.get_assets(),\n                }\n            return info\n        else:\n            return search\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_search_to_df","title":"<code>stac_search_to_df(search, **kwargs)</code>","text":"<p>Convert STAC search result to a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <code>pystac_client.item_search</code> <p>The search result returned by leafmap.stac_search().</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the DataFrame.drop() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A Pandas DataFrame object.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_search_to_df(search, **kwargs) -&gt; pd.DataFrame:\n    \"\"\"Convert STAC search result to a DataFrame.\n\n    Args:\n        search (pystac_client.item_search): The search result returned by leafmap.stac_search().\n        **kwargs: Additional keyword arguments to pass to the DataFrame.drop() function.\n\n    Returns:\n        DataFrame: A Pandas DataFrame object.\n    \"\"\"\n    gdf = stac_search_to_gdf(search)\n    return gdf.drop(columns=[\"geometry\"], **kwargs)\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_search_to_dict","title":"<code>stac_search_to_dict(search, **kwargs)</code>","text":"<p>Convert STAC search result to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <code>pystac_client.item_search</code> <p>The search result returned by leafmap.stac_search().</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of STAC items, with the stac item id as the key, and the stac item as the value.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_search_to_dict(search, **kwargs) -&gt; Dict:\n    \"\"\"Convert STAC search result to a dictionary.\n\n    Args:\n        search (pystac_client.item_search): The search result returned by leafmap.stac_search().\n\n    Returns:\n        dict: A dictionary of STAC items, with the stac item id as the key, and the stac item as the value.\n    \"\"\"\n\n    items = list(search.item_collection())\n    info = {}\n    for item in items:\n        info[item.id] = {\n            \"id\": item.id,\n            \"href\": item.get_self_href(),\n            \"bands\": list(item.get_assets().keys()),\n            \"assets\": item.get_assets(),\n        }\n        links = {}\n        assets = item.get_assets()\n        for key, value in assets.items():\n            links[key] = value.href\n        info[item.id][\"links\"] = links\n    return info\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_search_to_gdf","title":"<code>stac_search_to_gdf(search, **kwargs)</code>","text":"<p>Convert STAC search result to a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <code>pystac_client.item_search</code> <p>The search result returned by leafmap.stac_search().</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the GeoDataFrame.from_features() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame object.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_search_to_gdf(search, **kwargs):\n    \"\"\"Convert STAC search result to a GeoDataFrame.\n\n    Args:\n        search (pystac_client.item_search): The search result returned by leafmap.stac_search().\n        **kwargs: Additional keyword arguments to pass to the GeoDataFrame.from_features() function.\n\n    Returns:\n        GeoDataFrame: A GeoPandas GeoDataFrame object.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.GeoDataFrame.from_features(\n        search.item_collection().to_dict(), crs=\"EPSG:4326\", **kwargs\n    )\n    return gdf\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_search_to_list","title":"<code>stac_search_to_list(search, **kwargs)</code>","text":"<p>Convert STAC search result to a list.</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <code>pystac_client.item_search</code> <p>The search result returned by leafmap.stac_search().</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of STAC items.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_search_to_list(search, **kwargs) -&gt; List:\n    \"\"\"Convert STAC search result to a list.\n\n    Args:\n        search (pystac_client.item_search): The search result returned by leafmap.stac_search().\n\n    Returns:\n        list: A list of STAC items.\n    \"\"\"\n\n    return search.item_collections()\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_stats","title":"<code>stac_stats(url=None, collection=None, item=None, assets=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get band statistics of a STAC item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band statistics.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_stats(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    assets: Union[str, List] = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get band statistics of a STAC item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        list: A dictionary of band statistics.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if isinstance(url, pystac.Item):\n        try:\n            url = url.self_href\n        except Exception as e:\n            print(e)\n\n    if url is not None:\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n    if assets is not None:\n        kwargs[\"assets\"] = assets\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(f\"{titiler_endpoint}/stac/statistics\", params=kwargs).json()\n    else:\n        r = requests.get(\n            titiler_endpoint.url_for_stac_statistics(), params=kwargs\n        ).json()\n\n    return r\n</code></pre>"},{"location":"stac/#beamgis.stac.stac_tile","title":"<code>stac_tile(url=None, collection=None, item=None, assets=None, bands=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get a tile layer from a single SpatialTemporal Asset Catalog (STAC) item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>bands</code> <code>list</code> <p>A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"https://planetarycomputer.microsoft.com/api/data/v1\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Returns the STAC Tile layer URL.</p> Source code in <code>beamgis/stac.py</code> <pre><code>def stac_tile(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    assets: Union[str, List] = None,\n    bands: list = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Get a tile layer from a single SpatialTemporal Asset Catalog (STAC) item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"https://planetarycomputer.microsoft.com/api/data/v1\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        str: Returns the STAC Tile layer URL.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if isinstance(url, pystac.Item):\n        try:\n            url = url.self_href\n        except Exception as e:\n            print(e)\n\n    if url is not None:\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n\n    if \"palette\" in kwargs:\n        kwargs[\"colormap_name\"] = kwargs[\"palette\"].lower()\n        del kwargs[\"palette\"]\n\n    if isinstance(bands, list) and len(set(bands)) == 1:\n        bands = bands[0]\n\n    if isinstance(assets, list) and len(set(assets)) == 1:\n        assets = assets[0]\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if \"expression\" in kwargs and (\"asset_as_band\" not in kwargs):\n        kwargs[\"asset_as_band\"] = True\n\n    mosaic_json = False\n\n    if isinstance(titiler_endpoint, PlanetaryComputerEndpoint):\n        if isinstance(bands, str):\n            bands = bands.split(\",\")\n        if isinstance(assets, str):\n            assets = assets.split(\",\")\n        if assets is None and (bands is not None):\n            assets = bands\n        else:\n            kwargs[\"bidx\"] = bands\n\n        kwargs[\"assets\"] = assets\n\n        if (\n            (assets is not None)\n            and (\"asset_expression\" not in kwargs)\n            and (\"expression\" not in kwargs)\n            and (\"rescale\" not in kwargs)\n        ):\n            stats = stac_stats(\n                collection=collection,\n                item=item,\n                assets=assets,\n                titiler_endpoint=titiler_endpoint,\n            )\n            if \"detail\" not in stats:\n                try:\n                    percentile_2 = min([stats[s][\"percentile_2\"] for s in stats])\n                    percentile_98 = max([stats[s][\"percentile_98\"] for s in stats])\n                except:\n                    percentile_2 = min(\n                        [\n                            stats[s][list(stats[s].keys())[0]][\"percentile_2\"]\n                            for s in stats\n                        ]\n                    )\n                    percentile_98 = max(\n                        [\n                            stats[s][list(stats[s].keys())[0]][\"percentile_98\"]\n                            for s in stats\n                        ]\n                    )\n                kwargs[\"rescale\"] = f\"{percentile_2},{percentile_98}\"\n            else:\n                print(stats[\"detail\"])  # When operation times out.\n\n    else:\n        data = requests.get(url).json()\n        if \"mosaicjson\" in data:\n            mosaic_json = True\n\n        if isinstance(bands, str):\n            bands = bands.split(\",\")\n        if isinstance(assets, str):\n            assets = assets.split(\",\")\n\n        if assets is None:\n            if bands is not None:\n                assets = bands\n            else:\n                bnames = stac_bands(url)\n                if isinstance(bnames, list):\n                    if len(bnames) &gt;= 3:\n                        assets = bnames[0:3]\n                    else:\n                        assets = bnames[0]\n                else:\n                    assets = None\n\n        else:\n            kwargs[\"asset_bidx\"] = bands\n        if assets is not None:\n            kwargs[\"assets\"] = assets\n\n        if (\n            (assets is not None)\n            and (\"asset_expression\" not in kwargs)\n            and (\"expression\" not in kwargs)\n            and (\"rescale\" not in kwargs)\n        ):\n            stats = stac_stats(\n                url=url,\n                assets=assets,\n                titiler_endpoint=titiler_endpoint,\n            )\n            if \"detail\" not in stats:\n                try:\n                    percentile_2 = min([stats[s][\"percentile_2\"] for s in stats])\n                    percentile_98 = max([stats[s][\"percentile_98\"] for s in stats])\n                except:\n                    percentile_2 = min(\n                        [\n                            stats[s][list(stats[s].keys())[0]][\"percentile_2\"]\n                            for s in stats\n                        ]\n                    )\n                    percentile_98 = max(\n                        [\n                            stats[s][list(stats[s].keys())[0]][\"percentile_98\"]\n                            for s in stats\n                        ]\n                    )\n                kwargs[\"rescale\"] = f\"{percentile_2},{percentile_98}\"\n            else:\n                print(stats[\"detail\"])  # When operation times out.\n\n    TileMatrixSetId = \"WebMercatorQuad\"\n    if \"TileMatrixSetId\" in kwargs.keys():\n        TileMatrixSetId = kwargs[\"TileMatrixSetId\"]\n        kwargs.pop(\"TileMatrixSetId\")\n\n    if mosaic_json:\n        r = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/{TileMatrixSetId}/tilejson.json\",\n            params=kwargs,\n        ).json()\n    else:\n        if isinstance(titiler_endpoint, str):\n            r = requests.get(\n                f\"{titiler_endpoint}/stac/{TileMatrixSetId}/tilejson.json\",\n                params=kwargs,\n            ).json()\n        else:\n            r = requests.get(titiler_endpoint.url_for_stac_item(), params=kwargs).json()\n\n    return r[\"tiles\"][0]\n</code></pre>"},{"location":"toolbar/","title":"toolbar module","text":"<p>Module for dealing with the toolbar.</p>"},{"location":"toolbar/#beamgis.toolbar.census_widget","title":"<code>census_widget(m)</code>","text":"<p>Widget for adding US Census data.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>beamgis/toolbar.py</code> <pre><code>def census_widget(m):\n    \"\"\"Widget for adding US Census data.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    # from owslib.wms import WebMapService\n\n    census_dict = get_census_dict()\n    m.add_census_data(\"Census 2020\", \"States\")\n\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"filter\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    wms = widgets.Dropdown(\n        options=census_dict.keys(),\n        value=\"Census 2020\",\n        description=\"WMS:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    layer = widgets.Dropdown(\n        options=census_dict[\"Census 2020\"][\"layers\"],\n        value=\"States\",\n        description=\"Layer:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    checkbox = widgets.Checkbox(\n        description=\"Replace existing census data layer\",\n        value=True,\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=widget_width),\n    )\n\n    # output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        wms,\n        layer,\n        checkbox,\n        # output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def wms_change(change):\n        layer.options = census_dict[change[\"new\"]][\"layers\"]\n        layer.value = layer.options[0]\n\n    wms.observe(wms_change, \"value\")\n\n    def layer_change(change):\n        if change[\"new\"] != \"\":\n            if checkbox.value:\n                m.layers = m.layers[:-1]\n            m.add_census_data(wms.value, layer.value)\n\n            # with output:\n            #     w = WebMapService(census_dict[wms.value][\"url\"])\n            #     output.outputs = ()\n            #     print(w[layer.value].abstract)\n\n    layer.observe(layer_change, \"value\")\n\n    toolbar_button.value = True\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.change_basemap","title":"<code>change_basemap(m, position='topright')</code>","text":"<p>Widget for changing basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>object</code> <p>leafmap.Map.</p> required Source code in <code>beamgis/toolbar.py</code> <pre><code>def change_basemap(m, position: Optional[str] = \"topright\"):\n    \"\"\"Widget for changing basemaps.\n\n    Args:\n        m (object): leafmap.Map.\n    \"\"\"\n    from .basemaps import get_xyz_dict\n    from .leafmap import basemaps, get_basemap\n\n    xyz_dict = get_xyz_dict()\n\n    value = \"OpenStreetMap\"\n\n    dropdown = widgets.Dropdown(\n        options=list(basemaps.keys()),\n        value=value,\n        layout=widgets.Layout(width=\"200px\"),\n    )\n\n    close_btn = widgets.Button(\n        icon=\"times\",\n        tooltip=\"Close the basemap widget\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    basemap_widget = widgets.HBox([dropdown, close_btn])\n\n    def on_click(change):\n        if change[\"new\"]:\n            basemap_name = dropdown.value\n            if basemap_name not in m.get_layer_names():\n                m.add_basemap(basemap_name)\n                if basemap_name in xyz_dict:\n                    if \"bounds\" in xyz_dict[basemap_name]:\n                        bounds = xyz_dict[basemap_name][\"bounds\"]\n                        bounds = [\n                            bounds[0][1],\n                            bounds[0][0],\n                            bounds[1][1],\n                            bounds[1][0],\n                        ]\n                        m.zoom_to_bounds(bounds)\n\n    dropdown.observe(on_click, \"value\")\n\n    def close_click(change):\n        m.toolbar_reset()\n        if m.basemap_ctrl is not None and m.basemap_ctrl in m.controls:\n            m.remove_control(m.basemap_ctrl)\n        basemap_widget.close()\n\n    close_btn.on_click(close_click)\n\n    basemap_control = ipyleaflet.WidgetControl(widget=basemap_widget, position=position)\n    m.add(basemap_control)\n    m.basemap_ctrl = basemap_control\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.download_osm","title":"<code>download_osm(m)</code>","text":"<p>Widget for downloading OSM data.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>beamgis/toolbar.py</code> <pre><code>def download_osm(m):\n    \"\"\"Widget for downloading OSM data.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"gear\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    checkbox = widgets.Checkbox(\n        description=\"Checkbox\",\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=widget_width),\n    )\n\n    dropdown = widgets.Dropdown(\n        options=[\"Option 1\", \"Option 2\", \"Option 3\"],\n        value=None,\n        description=\"Dropdown:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    int_slider = widgets.IntSlider(\n        min=1,\n        max=100,\n        description=\"Int Slider: \",\n        readout=False,\n        continuous_update=True,\n        layout=widgets.Layout(width=\"220px\", padding=padding),\n        style=style,\n    )\n\n    int_slider_label = widgets.Label()\n\n    # widgets.jslink((int_slider, \"value\"), (int_slider_label, \"value\"))\n    def int_slider_changed(change):\n        if change[\"new\"]:\n            int_slider_label.value = str(int_slider.value)\n\n    int_slider.observe(int_slider_changed, \"value\")\n\n    float_slider = widgets.FloatSlider(\n        min=1,\n        max=100,\n        description=\"Float Slider: \",\n        readout=False,\n        continuous_update=True,\n        layout=widgets.Layout(width=\"220px\", padding=padding),\n        style=style,\n    )\n\n    float_slider_label = widgets.Label()\n\n    # widgets.jslink((float_slider, \"value\"), (float_slider_label, \"value\"))\n    def float_slider_changed(change):\n        if change[\"new\"]:\n            float_slider_label.value = str(float_slider.value)\n\n    float_slider.observe(float_slider_changed, \"value\")\n\n    color = widgets.ColorPicker(\n        concise=False,\n        description=\"Color:\",\n        value=\"white\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    text = widgets.Text(\n        value=\"\",\n        description=\"Textbox:\",\n        placeholder=\"Placeholder\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    textarea = widgets.Textarea(\n        placeholder=\"Placeholder\",\n        layout=widgets.Layout(width=widget_width),\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n    buttons.style.button_padding = \"0px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        checkbox,\n        widgets.HBox([int_slider, int_slider_label]),\n        widgets.HBox([float_slider, float_slider_label]),\n        dropdown,\n        text,\n        color,\n        textarea,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            with output:\n                output.outputs = ()\n                print(\"Running ...\")\n        elif change[\"new\"] == \"Reset\":\n            textarea.value = \"\"\n            output.outputs = ()\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = True\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.edit_draw_gui","title":"<code>edit_draw_gui(m)</code>","text":"<p>Generates a tool GUI for editing vector data attribute table.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>beamgis/toolbar.py</code> <pre><code>def edit_draw_gui(m):\n    \"\"\"Generates a tool GUI for editing vector data attribute table.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import ipysheet\n    import pandas as pd\n\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n    m.edit_mode = True\n\n    n_props = len(m.get_draw_props())\n    if n_props == 0:\n        n_props = 1\n\n    if \"MAX_PROPS\" in os.environ:\n        max_props = int(os.environ[\"MAX_PROPS\"])\n    else:\n        max_props = n_props + 10\n\n    sheet = ipysheet.from_dataframe(m.get_draw_props(n_props, return_df=True))\n    m.edit_sheet = sheet\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n    m.edit_output = output\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Edit attribute table\",\n        icon=\"pencil-square-o\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    open_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Open vector data\",\n        icon=\"folder-open\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    save_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Save to file\",\n        icon=\"floppy-o\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    refresh_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Get attribute\",\n        icon=\"refresh\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n    m.edit_refresh = refresh_button\n\n    int_slider = widgets.IntSlider(\n        min=n_props,\n        max=max_props,\n        description=\"Rows:\",\n        readout=False,\n        continuous_update=True,\n        layout=widgets.Layout(width=\"85px\", padding=padding),\n        style=style,\n    )\n\n    int_slider_label = widgets.Label()\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"64px\"\n\n    with output:\n        output.outputs = ()\n        display(m.edit_sheet)\n\n    def int_slider_changed(change):\n        if change[\"new\"]:\n            int_slider_label.value = str(int_slider.value)\n            m.edit_sheet.rows = int_slider.value\n            m.num_attributes = int_slider.value\n            with output:\n                output.outputs = ()\n                m.edit_sheet = ipysheet.from_dataframe(\n                    m.get_draw_props(n=int_slider.value, return_df=True)\n                )\n                display(m.edit_sheet)\n\n    int_slider.observe(int_slider_changed, \"value\")\n    m.num_attributes = int_slider.value\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [\n        close_button,\n        toolbar_button,\n        open_button,\n        save_button,\n        refresh_button,\n        int_slider,\n        int_slider_label,\n    ]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        output,\n        buttons,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n                m.edit_mode = False\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def open_chooser_callback(chooser):\n        with output:\n            import geopandas as gpd\n\n            gdf = gpd.read_file(chooser.selected)\n            geojson = gdf_to_geojson(gdf, epsg=4326, tuple_to_list=True)\n            m.draw_control.data = m.draw_control.data + (geojson[\"features\"])\n            m.draw_features = m.draw_features + (geojson[\"features\"])\n            open_button.value = False\n\n            m.edit_props = gdf.drop([\"geometry\"], axis=1).columns.tolist()\n            int_slider.value = len(m.edit_props)\n\n        if m.open_control in m.controls:\n            m.remove_control(m.open_control)\n            delattr(m, \"open_control\")\n\n    def open_btn_click(change):\n        if change[\"new\"]:\n            save_button.value = False\n\n            open_chooser = FileChooser(\n                os.getcwd(),\n                sandbox_path=m.sandbox_path,\n                layout=widgets.Layout(width=\"454px\"),\n            )\n            open_chooser.filter_pattern = [\"*.shp\", \"*.geojson\", \"*.gpkg\"]\n            open_chooser.use_dir_icons = True\n            open_chooser.register_callback(open_chooser_callback)\n\n            open_control = ipyleaflet.WidgetControl(\n                widget=open_chooser, position=\"topright\"\n            )\n            m.add(open_control)\n            m.open_control = open_control\n\n    open_button.observe(open_btn_click, \"value\")\n\n    def chooser_callback(chooser):\n        m.save_draw_features(chooser.selected, indent=None)\n        if m.file_control in m.controls:\n            m.remove_control(m.file_control)\n            delattr(m, \"file_control\")\n        with output:\n            print(f\"Saved to {chooser.selected}\")\n\n    def save_btn_click(change):\n        if change[\"new\"]:\n            save_button.value = False\n\n            file_chooser = FileChooser(\n                os.getcwd(),\n                sandbox_path=m.sandbox_path,\n                layout=widgets.Layout(width=\"454px\"),\n            )\n            file_chooser.filter_pattern = [\"*.shp\", \"*.geojson\", \"*.gpkg\"]\n            file_chooser.default_filename = \"data.geojson\"\n            file_chooser.use_dir_icons = True\n            file_chooser.register_callback(chooser_callback)\n\n            file_control = ipyleaflet.WidgetControl(\n                widget=file_chooser, position=\"topright\"\n            )\n            m.add(file_control)\n            m.file_control = file_control\n\n    save_button.observe(save_btn_click, \"value\")\n\n    def refresh_btn_click(change):\n        if change[\"new\"]:\n            refresh_button.value = False\n            if m.draw_control.last_action == \"edited\":\n                with output:\n                    geometries = [\n                        feature[\"geometry\"] for feature in m.draw_control.data\n                    ]\n                    if len(m.draw_features) &gt; 0:\n                        if (\n                            m.draw_features[-1][\"geometry\"]\n                            == m.draw_control.last_draw[\"geometry\"]\n                        ):\n                            m.draw_features.pop()\n                    for feature in m.draw_features:\n                        if feature[\"geometry\"] not in geometries:\n                            feature[\"geometry\"] = m.draw_control.last_draw[\"geometry\"]\n                            values = []\n                            props = ipysheet.to_dataframe(m.edit_sheet)[\"Key\"].tolist()\n                            for prop in props:\n                                if prop in feature[\"properties\"]:\n                                    values.append(feature[\"properties\"][prop])\n                                else:\n                                    values.append(\"\")\n                            df = pd.DataFrame({\"Key\": props, \"Value\": values})\n                            df.index += 1\n                            m.edit_sheet = ipysheet.from_dataframe(df)\n                            output.outputs = ()\n                            display(m.edit_sheet)\n\n    refresh_button.observe(refresh_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            with output:\n                output.outputs = ()\n                display(m.edit_sheet)\n                if len(m.draw_control.data) == 0:\n                    print(\"Please draw a feature first.\")\n                else:\n                    if m.draw_control.last_action == \"edited\":\n                        m.update_draw_features()\n                    m.update_draw_props(ipysheet.to_dataframe(m.edit_sheet))\n        elif change[\"new\"] == \"Reset\":\n            m.edit_sheet = ipysheet.from_dataframe(\n                m.get_draw_props(int_slider.value, return_df=True)\n            )\n            with output:\n                output.outputs = ()\n                display(m.edit_sheet)\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n                m.edit_mode = False\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = True\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.inspector_gui","title":"<code>inspector_gui(m, position='topright', opened=True)</code>","text":"<p>Generates a tool GUI template using ipywidgets.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>beamgis/toolbar.py</code> <pre><code>def inspector_gui(\n    m,\n    position: Optional[str] = \"topright\",\n    opened: Optional[bool] = True,\n):\n    \"\"\"Generates a tool GUI template using ipywidgets.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import pandas as pd\n\n    widget_width = \"250px\"\n    padding = \"0px 5px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    if m is not None:\n        marker_cluster = ipyleaflet.MarkerCluster(name=\"Inspector Markers\")\n        setattr(m, \"pixel_values\", [])\n        setattr(m, \"marker_cluster\", marker_cluster)\n\n        if not hasattr(m, \"interact_mode\"):\n            setattr(m, \"interact_mode\", False)\n\n        if not hasattr(m, \"inspector_output\"):\n            inspector_output = widgets.Output(\n                layout=widgets.Layout(width=widget_width, padding=\"0px 5px 5px 5px\")\n            )\n            setattr(m, \"inspector_output\", inspector_output)\n\n        output = m.inspector_output\n        output.outputs = ()\n\n        if not hasattr(m, \"inspector_add_marker\"):\n            inspector_add_marker = widgets.Checkbox(\n                description=\"Add Marker at clicked location\",\n                value=True,\n                indent=False,\n                layout=widgets.Layout(padding=padding, width=widget_width),\n            )\n            setattr(m, \"inspector_add_marker\", inspector_add_marker)\n        add_marker = m.inspector_add_marker\n\n        if not hasattr(m, \"inspector_bands_chk\"):\n            inspector_bands_chk = widgets.Checkbox(\n                description=\"Get pixel value for visible bands only\",\n                indent=False,\n                layout=widgets.Layout(padding=padding, width=widget_width),\n            )\n            setattr(m, \"inspector_bands_chk\", inspector_bands_chk)\n        bands_chk = m.inspector_bands_chk\n\n        if not hasattr(m, \"inspector_class_label\"):\n            inspector_label = widgets.Text(\n                value=\"\",\n                description=\"Class label:\",\n                placeholder=\"Add a label to the marker\",\n                style=style,\n                layout=widgets.Layout(width=widget_width, padding=padding),\n            )\n            setattr(m, \"inspector_class_label\", inspector_label)\n        label = m.inspector_class_label\n\n        options = []\n        if hasattr(m, \"cog_layer_dict\"):\n            options = list(m.cog_layer_dict.keys())\n            options.sort()\n        if len(options) == 0:\n            default_option = None\n        else:\n            default_option = options[0]\n        if not hasattr(m, \"inspector_dropdown\"):\n            inspector_dropdown = widgets.Dropdown(\n                options=options,\n                value=default_option,\n                description=\"Select a layer:\",\n                layout=widgets.Layout(width=widget_width, padding=padding),\n                style=style,\n            )\n            setattr(m, \"inspector_dropdown\", inspector_dropdown)\n\n        dropdown = m.inspector_dropdown\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"info\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Download\", \"Reset\", \"Close\"],\n        tooltips=[\"Download\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    if len(options) == 0:\n        with output:\n            print(\"No COG/STAC layers available\")\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        add_marker,\n        label,\n        dropdown,\n        bands_chk,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def chk_change(change):\n        if hasattr(m, \"pixel_values\"):\n            m.pixel_values = []\n        if hasattr(m, \"marker_cluster\"):\n            m.marker_cluster.markers = []\n        output.outputs = ()\n\n    bands_chk.observe(chk_change, \"value\")\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                if hasattr(m, \"inspector_mode\"):\n                    delattr(m, \"inspector_mode\")\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n                m.default_style = {\"cursor\": \"default\"}\n\n                m.marker_cluster.markers = []\n                m.pixel_values = []\n                marker_cluster_layer = m.find_layer(\"Inspector Markers\")\n                if marker_cluster_layer is not None:\n                    m.remove_layer(marker_cluster_layer)\n\n                if hasattr(m, \"pixel_values\"):\n                    delattr(m, \"pixel_values\")\n\n                if hasattr(m, \"marker_cluster\"):\n                    delattr(m, \"marker_cluster\")\n\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Download\":\n            with output:\n                output.outputs = ()\n                if len(m.pixel_values) == 0:\n                    print(\n                        \"No pixel values available. Click on the map to start collection data.\"\n                    )\n                else:\n                    print(\"Downloading pixel values...\")\n                    df = pd.DataFrame(m.pixel_values)\n                    temp_csv = temp_file_path(\"csv\")\n                    df.to_csv(temp_csv, index=False)\n                    link = create_download_link(temp_csv)\n                    with output:\n                        output.outputs = ()\n                        display(link)\n        elif change[\"new\"] == \"Reset\":\n            label.value = \"\"\n            output.outputs = ()\n            if hasattr(m, \"pixel_values\"):\n                m.pixel_values = []\n            if hasattr(m, \"marker_cluster\"):\n                m.marker_cluster.markers = []\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                if hasattr(m, \"inspector_mode\"):\n                    delattr(m, \"inspector_mode\")\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n                m.default_style = {\"cursor\": \"default\"}\n                m.marker_cluster.markers = []\n                marker_cluster_layer = m.find_layer(\"Inspector Markers\")\n                if marker_cluster_layer is not None:\n                    m.remove_layer(marker_cluster_layer)\n                m.pixel_values = []\n\n                if hasattr(m, \"pixel_values\"):\n                    delattr(m, \"pixel_values\")\n\n                if hasattr(m, \"marker_cluster\"):\n                    delattr(m, \"marker_cluster\")\n\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = opened\n\n    def handle_interaction(**kwargs):\n        latlon = kwargs.get(\"coordinates\")\n        lat = round(latlon[0], 4)\n        lon = round(latlon[1], 4)\n        if (\n            kwargs.get(\"type\") == \"click\"\n            and hasattr(m, \"inspector_mode\")\n            and m.inspector_mode\n        ):\n            m.default_style = {\"cursor\": \"wait\"}\n\n            with output:\n                output.outputs = ()\n                print(\"Getting pixel value ...\")\n\n                layer_dict = m.cog_layer_dict[dropdown.value]\n\n            if layer_dict[\"type\"] == \"STAC\":\n                if bands_chk.value:\n                    assets = layer_dict[\"assets\"]\n                else:\n                    assets = None\n\n                result = stac_pixel_value(\n                    lon,\n                    lat,\n                    layer_dict[\"url\"],\n                    layer_dict[\"collection\"],\n                    layer_dict[\"item\"],\n                    assets,\n                    layer_dict[\"titiler_endpoint\"],\n                    verbose=False,\n                )\n\n                if result is not None:\n                    with output:\n                        output.clear_output()\n                        print(f\"lat, lon: {lat:.4f}, {lon:.4f}\\n\")\n                        for key in result:\n                            print(f\"{key}: {result[key]}\")\n\n                        result[\"latitude\"] = lat\n                        result[\"longitude\"] = lon\n                        result[\"label\"] = label.value\n                        m.pixel_values.append(result)\n                    if add_marker.value:\n                        markers = list(m.marker_cluster.markers)\n                        markers.append(ipyleaflet.Marker(location=latlon))\n                        m.marker_cluster.markers = markers\n\n                else:\n                    with output:\n                        output.clear_output()\n                        print(\"No pixel value available\")\n                        bounds = m.cog_layer_dict[m.inspector_dropdown.value][\"bounds\"]\n                        m.zoom_to_bounds(bounds)\n            elif layer_dict[\"type\"] == \"COG\":\n\n                if m.inspector_bands_chk.value:\n                    indexes = layer_dict[\"indexes\"]\n                else:\n                    indexes = list(range(1, len(layer_dict[\"band_names\"]) + 1))\n\n                result = cog_pixel_value(\n                    lon, lat, layer_dict[\"url\"], indexes, verbose=False\n                )\n                if result is not None:\n                    with output:\n                        output.clear_output()\n                        print(f\"lat, lon: {lat:.4f}, {lon:.4f}\\n\")\n                        for key in result:\n                            print(f\"{key}: {result[key]}\")\n\n                        result[\"latitude\"] = lat\n                        result[\"longitude\"] = lon\n                        result[\"label\"] = label.value\n                        m.pixel_values.append(result)\n                    if add_marker.value:\n                        markers = list(m.marker_cluster.markers)\n                        markers.append(ipyleaflet.Marker(location=latlon))\n                        m.marker_cluster.markers = markers\n                else:\n                    with output:\n                        output.outputs = ()\n                        print(\"No pixel value available\")\n                        bounds = m.cog_layer_dict[m.inspector_dropdown.value][\"bounds\"]\n                        m.zoom_to_bounds(bounds)\n\n            elif layer_dict[\"type\"] == \"LOCAL\":\n                try:\n                    data = local_tile_pixel_value(\n                        lon, lat, layer_dict[\"tile_client\"], verbose=False\n                    )\n\n                    result = {}\n                    band_names = data.band_names\n                    values = data.array.data.tolist()\n                    for i, band in enumerate(band_names):\n                        result[band] = values[i]\n\n                    if m.inspector_bands_chk.value:\n                        vis_bands = m.cog_layer_dict[m.inspector_dropdown.value][\n                            \"vis_bands\"\n                        ]\n                        new_result = {}\n                        for key in result:\n                            if key in vis_bands:\n                                new_result[key] = result[key]\n                        result = new_result\n\n                    with output:\n                        output.clear_output()\n                        print(f\"lat, lon: {lat:.4f}, {lon:.4f}\\n\")\n                        for key in result:\n                            print(f\"{key}: {result[key]}\")\n\n                        result[\"latitude\"] = lat\n                        result[\"longitude\"] = lon\n                        result[\"label\"] = label.value\n                        m.pixel_values.append(result)\n                    if add_marker.value:\n                        markers = list(m.marker_cluster.markers)\n                        markers.append(ipyleaflet.Marker(location=latlon))\n                        m.marker_cluster.markers = markers\n\n                except Exception as e:\n                    with output:\n                        output.clear_output()\n                        print(e)\n                        # bounds = m.cog_layer_dict[m.inspector_dropdown.value][\"bounds\"]\n                        # m.zoom_to_bounds(bounds)\n\n            m.default_style = {\"cursor\": \"crosshair\"}\n\n    if m is not None:\n        if not hasattr(m, \"marker_cluster\"):\n            setattr(m, \"marker_cluster\", marker_cluster)\n        m.add(marker_cluster)\n\n        if not m.interact_mode:\n            m.on_interaction(handle_interaction)\n            m.interact_mode = True\n\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=position\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n\n        if not hasattr(m, \"inspector_mode\"):\n            if hasattr(m, \"cog_layer_dict\"):\n                setattr(m, \"inspector_mode\", True)\n            else:\n                setattr(m, \"inspector_mode\", False)\n\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.layer_manager_gui","title":"<code>layer_manager_gui(m, position='topright', opened=True, return_widget=False)</code>","text":"<p>Creates a layer manager widget.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>geemap.Map</code> <p>The geemap.Map object.</p> required <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> <code>return_widget</code> <code>bool</code> <p>Whether to return the widget. Defaults to False.</p> <code>False</code> Source code in <code>beamgis/toolbar.py</code> <pre><code>def layer_manager_gui(\n    m,\n    position: Optional[str] = \"topright\",\n    opened: Optional[bool] = True,\n    return_widget: Optional[bool] = False,\n):\n    \"\"\"Creates a layer manager widget.\n\n    Args:\n        m (geemap.Map): The geemap.Map object.\n        position (str, optional): The position of the widget. Defaults to \"topright\".\n        return_widget (bool, optional): Whether to return the widget. Defaults to False.\n    \"\"\"\n\n    layers_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Layer Manager\",\n        icon=\"server\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [layers_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = []\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_header]\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [layers_button]\n\n    layers_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            layers_button.value = False\n            m.toolbar_reset()\n            if m.layer_manager is not None and m.layer_manager in m.controls:\n                m.remove_control(m.layer_manager)\n                m.layer_manager = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def layers_btn_click(change):\n        if change[\"new\"]:\n            layers_hbox = []\n            all_layers_chk = widgets.Checkbox(\n                value=False,\n                description=\"All layers on/off\",\n                indent=False,\n                layout=widgets.Layout(height=\"18px\", padding=\"0px 8px 25px 8px\"),\n            )\n            all_layers_chk.layout.width = \"30ex\"\n            layers_hbox.append(all_layers_chk)\n\n            def all_layers_chk_changed(change):\n                if change[\"new\"]:\n                    for layer in m.layers:\n                        if hasattr(layer, \"visible\"):\n                            layer.visible = True\n                else:\n                    for layer in m.layers:\n                        if hasattr(layer, \"visible\"):\n                            layer.visible = False\n\n            all_layers_chk.observe(all_layers_chk_changed, \"value\")\n\n            layers = [lyr for lyr in m.layers if lyr.name]\n\n            # if the layers contain unsupported layers (e.g., GeoJSON, GeoData), adds the ipyleaflet built-in LayerControl\n            if len(layers) &lt; (len(m.layers) - 1):\n                if m.layer_control is None:\n                    layer_control = ipyleaflet.LayersControl(position=\"topright\")\n                    m.layer_control = layer_control\n                if m.layer_control not in m.controls:\n                    m.add(m.layer_control)\n\n            # for non-TileLayer, use layer.style={'opacity':0, 'fillOpacity': 0} to turn layer off.\n            for layer in layers:\n                visible = True\n                if hasattr(layer, \"visible\"):\n                    visible = layer.visible\n                layer_chk = widgets.Checkbox(\n                    value=visible,\n                    description=layer.name,\n                    indent=False,\n                    layout=widgets.Layout(height=\"18px\"),\n                )\n                layer_chk.layout.width = \"25ex\"\n\n                if layer in m.geojson_layers:\n                    try:\n                        opacity = max(\n                            layer.style[\"opacity\"], layer.style[\"fillOpacity\"]\n                        )\n                    except KeyError:\n                        opacity = 1.0\n                elif hasattr(layer, \"opacity\"):\n                    opacity = layer.opacity\n                else:\n                    opacity = 1.0\n\n                layer_opacity = widgets.FloatSlider(\n                    value=opacity,\n                    min=0,\n                    max=1,\n                    step=0.01,\n                    readout=False,\n                    layout=widgets.Layout(width=\"80px\"),\n                )\n                layer_settings = widgets.Button(\n                    icon=\"gear\",\n                    tooltip=layer.name,\n                    layout=widgets.Layout(\n                        width=\"25px\", height=\"25px\", padding=\"0px 0px 0px 0px\"\n                    ),\n                )\n\n                def layer_settings_click(b):\n                    if b.tooltip in m.cog_layer_dict:\n                        m._add_layer_editor(\n                            position=\"topright\",\n                            layer_dict=m.cog_layer_dict[b.tooltip],\n                        )\n\n                layer_settings.on_click(layer_settings_click)\n\n                def layer_opacity_changed(change):\n                    if change[\"new\"]:\n                        layer.style = {\n                            \"opacity\": change[\"new\"],\n                            \"fillOpacity\": change[\"new\"],\n                        }\n\n                if hasattr(layer, \"visible\"):\n                    widgets.jslink((layer_chk, \"value\"), (layer, \"visible\"))\n\n                if layer in m.geojson_layers:\n                    layer_opacity.observe(layer_opacity_changed, \"value\")\n                elif hasattr(layer, \"opacity\"):\n                    widgets.jsdlink((layer_opacity, \"value\"), (layer, \"opacity\"))\n\n                hbox = widgets.HBox(\n                    [layer_chk, layer_settings, layer_opacity],\n                    layout=widgets.Layout(padding=\"0px 8px 0px 8px\"),\n                )\n                layers_hbox.append(hbox)\n                m.layer_widget = layers_hbox\n\n            toolbar_header.children = [close_button, layers_button]\n            toolbar_footer.children = layers_hbox\n\n        else:\n            toolbar_header.children = [layers_button]\n\n    layers_button.observe(layers_btn_click, \"value\")\n    layers_button.value = opened\n\n    if not hasattr(m, \"_layer_manager_widget\"):\n        m._layer_manager_widget = toolbar_footer\n\n    if return_widget:\n        return m.layer_widget\n    else:\n        layer_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=position\n        )\n\n        if layer_control not in m.controls:\n            m.add_control(layer_control)\n            m.layer_manager = layer_control\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.main_toolbar","title":"<code>main_toolbar(m)</code>","text":"<p>Creates the main toolbar and adds it to the map.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leafmap Map object.</p> required Source code in <code>beamgis/toolbar.py</code> <pre><code>def main_toolbar(m):\n    \"\"\"Creates the main toolbar and adds it to the map.\n\n    Args:\n        m (leafmap.Map): The leafmap Map object.\n    \"\"\"\n    all_tools = {\n        \"map\": {\n            \"name\": \"basemap\",\n            \"tooltip\": \"Change basemap\",\n        },\n        \"globe\": {\n            \"name\": \"split_map\",\n            \"tooltip\": \"Split-panel map\",\n        },\n        \"adjust\": {\n            \"name\": \"planet\",\n            \"tooltip\": \"Planet imagery\",\n        },\n        \"folder-open\": {\n            \"name\": \"open_data\",\n            \"tooltip\": \"Open local vector/raster data\",\n        },\n        \"gears\": {\n            \"name\": \"whitebox\",\n            \"tooltip\": \"WhiteboxTools for local geoprocessing\",\n        },\n        \"fast-forward\": {\n            \"name\": \"timeslider\",\n            \"tooltip\": \"Activate the time slider\",\n        },\n        \"eraser\": {\n            \"name\": \"eraser\",\n            \"tooltip\": \"Remove all drawn features\",\n        },\n        \"camera\": {\n            \"name\": \"save_map\",\n            \"tooltip\": \"Save map as HTML or image\",\n        },\n        \"filter\": {\n            \"name\": \"census\",\n            \"tooltip\": \"Get US Census data\",\n        },\n        \"info\": {\n            \"name\": \"inspector\",\n            \"tooltip\": \"Get COG/STAC pixel value\",\n        },\n        \"search\": {\n            \"name\": \"search_xyz\",\n            \"tooltip\": \"Search XYZ tile services\",\n        },\n        \"download\": {\n            \"name\": \"download_osm\",\n            \"tooltip\": \"Download OSM data\",\n        },\n        \"picture-o\": {\n            \"name\": \"raster\",\n            \"tooltip\": \"Open COG/STAC dataset\",\n        },\n        \"search-plus\": {\n            \"name\": \"search_geojson\",\n            \"tooltip\": \"Search features in GeoJSON layer\",\n        },\n        \"table\": {\n            \"name\": \"attribute_table\",\n            \"tooltip\": \"Open attribute table\",\n        },\n        \"pencil-square-o\": {\n            \"name\": \"edit_vector\",\n            \"tooltip\": \"Create vector data\",\n        },\n        \"stack-exchange\": {\n            \"name\": \"stac\",\n            \"tooltip\": \"Discover STAC Catalog\",\n        },\n        \"plane\": {\n            \"name\": \"oam\",\n            \"tooltip\": \"Search OpenAerialMap\",\n        },\n        # \"spinner\": {\n        #     \"name\": \"placeholder2\",\n        #     \"tooltip\": \"This is a placeholder\",\n        # },\n        # \"question\": {\n        #     \"name\": \"help\",\n        #     \"tooltip\": \"Get help\",\n        # },\n    }\n\n    # if m.sandbox_path is None and (os.environ.get(\"USE_VOILA\") is not None):\n    #     voila_tools = [\"camera\", \"folder-open\", \"gears\"]\n\n    #     for item in voila_tools:\n    #         if item in tools.keys():\n    #             del tools[item]\n\n    tools = {}\n    for tool in all_tools:\n        if os.environ.get(all_tools[tool][\"name\"].upper(), \"\").upper() != \"FALSE\":\n            tools[tool] = all_tools[tool]\n\n    icons = list(tools.keys())\n    tooltips = [item[\"tooltip\"] for item in list(tools.values())]\n    toolnames = [item[\"name\"].upper() for item in list(all_tools.values())]\n    toolnames.sort()\n    setattr(m, \"_ENV_VARS\", toolnames)\n\n    icon_width = \"32px\"\n    icon_height = \"32px\"\n    n_cols = 3\n    n_rows = math.ceil(len(icons) / n_cols)\n\n    toolbar_grid = widgets.GridBox(\n        children=[\n            widgets.ToggleButton(\n                layout=widgets.Layout(\n                    width=\"auto\", height=\"auto\", padding=\"0px 0px 0px 4px\"\n                ),\n                button_style=\"primary\",\n                icon=icons[i],\n                tooltip=tooltips[i],\n            )\n            for i in range(len(icons))\n        ],\n        layout=widgets.Layout(\n            width=\"109px\",\n            grid_template_columns=(icon_width + \" \") * n_cols,\n            grid_template_rows=(icon_height + \" \") * n_rows,\n            grid_gap=\"1px 1px\",\n            padding=\"5px\",\n        ),\n    )\n    m.toolbar = toolbar_grid\n\n    def tool_callback(change):\n        if change[\"new\"]:\n            current_tool = change[\"owner\"]\n            for tool in toolbar_grid.children:\n                if tool is not current_tool:\n                    tool.value = False\n            tool = change[\"owner\"]\n            tool_name = tools[tool.icon][\"name\"]\n\n            if tool_name == \"basemap\":\n                change_basemap(m)\n            if tool_name == \"split_map\":\n                split_basemaps(m)\n            if tool_name == \"planet\":\n                split_basemaps(m, layers_dict=planet_tiles())\n            elif tool_name == \"open_data\":\n                open_data_widget(m)\n            elif tool_name == \"eraser\":\n                if m.draw_control is not None:\n                    m.draw_control.clear()\n                    m.user_roi = None\n                    m.user_rois = None\n                    m.draw_features = []\n            elif tool_name == \"whitebox\":\n                import whiteboxgui.whiteboxgui as wbt\n\n                tools_dict = wbt.get_wbt_dict()\n                wbt_toolbox = wbt.build_toolbox(\n                    tools_dict,\n                    max_width=\"800px\",\n                    max_height=\"500px\",\n                    sandbox_path=m.sandbox_path,\n                )\n                wbt_control = ipyleaflet.WidgetControl(\n                    widget=wbt_toolbox, position=\"bottomright\"\n                )\n                m.whitebox = wbt_control\n                m.add(wbt_control)\n            elif tool_name == \"timeslider\":\n                m.add_time_slider()\n            elif tool_name == \"save_map\":\n                save_map((m))\n            elif tool_name == \"census\":\n                census_widget(m)\n            elif tool_name == \"inspector\":\n                inspector_gui(m)\n            elif tool_name == \"search_xyz\":\n                search_basemaps(m)\n            elif tool_name == \"download_osm\":\n                download_osm(m)\n            elif tool_name == \"raster\":\n                open_raster_gui(m)\n            elif tool_name == \"search_geojson\":\n                search_geojson_gui(m)\n            elif tool_name == \"attribute_table\":\n                select_table_gui(m)\n            elif tool_name == \"edit_vector\":\n                edit_draw_gui(m)\n            elif tool_name == \"stac\":\n                stac_gui(m)\n            elif tool_name == \"oam\":\n                oam_search_gui(m)\n            elif tool_name == \"help\":\n                import webbrowser\n\n                webbrowser.open_new_tab(\"https://leafmap.org\")\n                current_tool.value = False\n        else:\n            # tool = change[\"owner\"]\n            # tool_name = tools[tool.icon][\"name\"]\n            pass\n\n        m.toolbar_reset()\n\n    for tool in toolbar_grid.children:\n        tool.observe(tool_callback, \"value\")\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"wrench\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n    m.toolbar_button = toolbar_button\n\n    layers_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Layers\",\n        icon=\"server\",\n        layout=widgets.Layout(height=\"28px\", width=\"72px\"),\n    )\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [layers_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [toolbar_grid]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                layers_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            layers_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not layers_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def layers_btn_click(change):\n        if change[\"new\"]:\n            toolbar_footer.children = layer_manager_gui(m, return_widget=True)\n            toolbar_button.value = False\n        else:\n            toolbar_footer.children = [toolbar_grid]\n\n    layers_button.observe(layers_btn_click, \"value\")\n\n    toolbar_control = ipyleaflet.WidgetControl(\n        widget=toolbar_widget, position=\"topright\"\n    )\n\n    m.add(toolbar_control)\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.nasa_data_gui","title":"<code>nasa_data_gui(m, position='topright', opened=True, default_dataset='GEDI_L4A_AGB_Density_V2_1_2056', **kwargs)</code>","text":"<p>Search NASA Earth data interactive</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> <code>opened</code> <code>bool</code> <p>Whether to open the widget. Defaults to True.</p> <code>True</code> <code>default_dataset</code> <code>str</code> <p>The default dataset. Defaults to \"GEDI_L4A_AGB_Density_V2_1_2056\".</p> <code>'GEDI_L4A_AGB_Density_V2_1_2056'</code> <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>beamgis/toolbar.py</code> <pre><code>def nasa_data_gui(\n    m,\n    position: Optional[str] = \"topright\",\n    opened: Optional[bool] = True,\n    default_dataset: Optional[str] = \"GEDI_L4A_AGB_Density_V2_1_2056\",\n    **kwargs,\n):\n    \"\"\"Search NASA Earth data interactive\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n        position (str, optional): The position of the widget. Defaults to \"topright\".\n        opened (bool, optional): Whether to open the widget. Defaults to True.\n        default_dataset (str, optional): The default dataset. Defaults to \"GEDI_L4A_AGB_Density_V2_1_2056\".\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import pandas as pd\n    from datetime import datetime\n\n    widget_width = \"400px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    if not hasattr(m, \"_NASA_DATA\"):\n        url = \"https://github.com/opengeos/NASA-Earth-Data/raw/main/nasa_earth_data.tsv\"\n        df = pd.read_csv(url, sep=\"\\t\")\n        setattr(m, \"_NASA_DATA\", df)\n        names = df[\"ShortName\"].tolist()\n        setattr(m, \"_NASA_DATA_NAMES\", names)\n\n    default_title = m._NASA_DATA[m._NASA_DATA[\"ShortName\"] == default_dataset][\n        \"EntryTitle\"\n    ].values[0]\n\n    output = widgets.Output(\n        layout=widgets.Layout(width=widget_width, padding=padding, overflow=\"auto\")\n    )\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Search NASA Earth data\",\n        icon=\"search\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    keyword = widgets.Text(\n        value=\"\",\n        description=\"Keyword:\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    short_name = widgets.Dropdown(\n        options=m._NASA_DATA_NAMES,\n        value=default_dataset,\n        description=\"Short Name:\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    title = widgets.Text(\n        value=default_title,\n        description=\"Title:\",\n        style=style,\n        disabled=True,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    max_items = widgets.IntText(\n        value=50,\n        description=\"Max items:\",\n        style=style,\n        layout=widgets.Layout(width=\"125px\", padding=padding),\n    )\n\n    bbox = widgets.Text(\n        value=\"\",\n        description=\"Bounding box:\",\n        placeholder=\"xmin, ymin, xmax, ymax\",\n        style=style,\n        layout=widgets.Layout(width=\"271px\", padding=padding),\n    )\n\n    start_date = widgets.DatePicker(\n        description=\"Start date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=\"198px\", padding=padding),\n    )\n    end_date = widgets.DatePicker(\n        description=\"End date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=\"198px\", padding=padding),\n    )\n\n    dataset = widgets.Dropdown(\n        value=None,\n        description=\"Dataset:\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Search\", \"Display\", \"Reset\", \"Close\"],\n        tooltips=[\"Get Items\", \"Display Image\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"65px\"\n\n    def change_keyword(change):\n        short_name.options = nasa_datasets(\n            keyword.value, df=m._NASA_DATA, return_short_name=True\n        )\n\n    keyword.on_submit(change_keyword)\n\n    def change_dataset(change):\n        title.value = m._NASA_DATA[m._NASA_DATA[\"ShortName\"] == short_name.value][\n            \"EntryTitle\"\n        ].values[0]\n        dataset.value = None\n        dataset.options = []\n\n    short_name.observe(change_dataset, \"value\")\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        keyword,\n        short_name,\n        title,\n        widgets.HBox([max_items, bbox]),\n        widgets.HBox([start_date, end_date]),\n        dataset,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Search\":\n            with output:\n                output.clear_output()\n                with output:\n                    print(\"Searching...\")\n\n                    if bbox.value.strip() == \"\":\n                        if m.user_roi_bounds() is not None:\n                            bounds = tuple(m.user_roi_bounds())\n                        else:\n                            bounds = (\n                                m.bounds[0][1],\n                                m.bounds[0][0],\n                                m.bounds[1][1],\n                                m.bounds[1][0],\n                            )\n                    else:\n                        bounds = tuple(map(float, bbox.value.split(\",\")))\n                        if len(bounds) != 4:\n                            print(\"Please provide a valid bounding box.\")\n                            bounds = None\n\n                    if start_date.value is not None and end_date.value is not None:\n                        date_range = (str(start_date.value), str(end_date.value))\n                    elif start_date.value is not None:\n                        date_range = (\n                            str(start_date.value),\n                            datetime.today().strftime(\"%Y-%m-%d\"),\n                        )\n                    else:\n                        date_range = None\n\n                    output.clear_output(wait=True)\n                    try:\n                        results, gdf = nasa_data_search(\n                            count=max_items.value,\n                            short_name=short_name.value,\n                            bbox=bounds,\n                            temporal=date_range,\n                            return_gdf=True,\n                        )\n\n                        if len(results) &gt; 0:\n                            if \"Footprints\" in m.get_layer_names():\n                                m.remove(m.find_layer(\"Footprints\"))\n                            if (\n                                hasattr(m, \"_NASA_DATA_CTRL\")\n                                and m._NASA_DATA_CTRL in m.controls\n                            ):\n                                m.remove(m._NASA_DATA_CTRL)\n\n                            style = {\n                                # \"stroke\": True,\n                                \"color\": \"#3388ff\",\n                                \"weight\": 2,\n                                \"opacity\": 1,\n                                \"fill\": True,\n                                \"fillColor\": \"#3388ff\",\n                                \"fillOpacity\": 0.1,\n                            }\n\n                            hover_style = {\n                                \"weight\": style[\"weight\"] + 2,\n                                \"fillOpacity\": 0,\n                                \"color\": \"yellow\",\n                            }\n\n                            m.add_gdf(\n                                gdf,\n                                layer_name=\"Footprints\",\n                                info_mode=\"on_click\",\n                                zoom_to_layer=False,\n                                style=style,\n                                hover_style=hover_style,\n                            )\n                            setattr(m, \"_NASA_DATA_CTRL\", m.controls[-1])\n\n                            dataset.options = gdf[\"native-id\"].values.tolist()\n                            dataset.value = dataset.options[0]\n\n                            setattr(m, \"_NASA_DATA_GDF\", gdf)\n                            setattr(m, \"_NASA_DATA_RESULTS\", results)\n                            output.clear_output()\n\n                    except Exception as e:\n                        print(e)\n\n        elif change[\"new\"] == \"Display\":\n            output.clear_output()\n            with output:\n                print(\"To be implemented...\")\n\n        elif change[\"new\"] == \"Reset\":\n            keyword.value = \"\"\n            short_name.options = m._NASA_DATA_NAMES\n            short_name.value = default_dataset\n            title.value = default_title\n            max_items.value = 50\n            bbox.value = \"\"\n            bbox.placeholder = \"xmin, ymin, xmax, ymax\"\n            start_date.value = None\n            end_date.value = None\n            dataset.options = []\n            dataset.value = None\n            output.clear_output()\n\n            if \"Footprints\" in m.get_layer_names():\n                m.remove(m.find_layer(\"Footprints\"))\n            if hasattr(m, \"_NASA_DATA_CTRL\") and m._NASA_DATA_CTRL in m.controls:\n                m.remove(m._NASA_DATA_CTRL)\n\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = opened\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=position\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.nasa_opera_gui","title":"<code>nasa_opera_gui(m, position='topright', opened=True, default_dataset='OPERA_L3_DSWX-HLS_V1', **kwargs)</code>","text":"<p>Search NASA Earth data interactive</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> <code>opened</code> <code>bool</code> <p>Whether to open the widget. Defaults to True.</p> <code>True</code> <code>default_dataset</code> <code>str</code> <p>The default dataset. Defaults to \"OPERA_L3_DSWX-HLS_V1\".</p> <code>'OPERA_L3_DSWX-HLS_V1'</code> <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>beamgis/toolbar.py</code> <pre><code>def nasa_opera_gui(\n    m,\n    position: Optional[str] = \"topright\",\n    opened: Optional[bool] = True,\n    default_dataset: Optional[str] = \"OPERA_L3_DSWX-HLS_V1\",\n    **kwargs,\n):\n    \"\"\"Search NASA Earth data interactive\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n        position (str, optional): The position of the widget. Defaults to \"topright\".\n        opened (bool, optional): Whether to open the widget. Defaults to True.\n        default_dataset (str, optional): The default dataset. Defaults to \"OPERA_L3_DSWX-HLS_V1\".\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import pandas as pd\n    from datetime import datetime\n    import boto3\n    import rasterio as rio\n    from rasterio.session import AWSSession\n    import xarray as xr\n    import matplotlib.pyplot as plt\n\n    widget_width = \"400px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    colormaps = plt.colormaps()\n    cmap_options = [cmap for cmap in colormaps if (len(cmap) &lt; 20 and cmap.islower())]\n    cmap_options.sort()\n\n    if not hasattr(m, \"_NASA_DATA\"):\n\n        data = {\n            \"ShortName\": [\n                \"OPERA_L2_CSLC-S1-STATIC_V1\",\n                \"OPERA_L2_CSLC-S1_V1\",\n                \"OPERA_L2_RTC-S1-STATIC_V1\",\n                \"OPERA_L2_RTC-S1_V1\",\n                \"OPERA_L3_DIST-ALERT-HLS_V1\",\n                \"OPERA_L3_DIST-ANN-HLS_V1\",\n                \"OPERA_L3_DSWX-HLS_V1\",\n                \"OPERA_L3_DSWX-S1_V1\",\n            ],\n            \"EntryTitle\": [\n                \"OPERA Coregistered Single-Look Complex from Sentinel-1 Static Layers validated product (Version 1)\",\n                \"OPERA Coregistered Single-Look Complex from Sentinel-1 validated product (Version 1)\",\n                \"OPERA Radiometric Terrain Corrected SAR Backscatter from Sentinel-1 Static Layers validated product (Version 1)\",\n                \"OPERA Radiometric Terrain Corrected SAR Backscatter from Sentinel-1 validated product (Version 1)\",\n                \"OPERA Land Surface Disturbance Alert from Harmonized Landsat Sentinel-2 product (Version 1)\",\n                \"OPERA Land Surface Disturbance Annual from Harmonized Landsat Sentinel-2 product (Version 1)\",\n                \"OPERA Dynamic Surface Water Extent from Harmonized Landsat Sentinel-2 product (Version 1)\",\n                \"OPERA Dynamic Surface Water Extent from Sentinel-1 (Version 1)\",\n            ],\n        }\n\n        df = pd.DataFrame(data)\n        setattr(m, \"_NASA_DATA\", df)\n        names = df[\"ShortName\"].tolist()\n        setattr(m, \"_NASA_DATA_NAMES\", names)\n\n    # Generates the temporary\n    s3_cred_endpoint = \"https://archive.podaac.earthdata.nasa.gov/s3credentials\"\n\n    def get_temp_creds():\n        temp_creds_url = s3_cred_endpoint\n        return requests.get(temp_creds_url).json()\n\n    temp_creds_req = get_temp_creds()\n\n    session = boto3.Session(\n        aws_access_key_id=temp_creds_req[\"accessKeyId\"],\n        aws_secret_access_key=temp_creds_req[\"secretAccessKey\"],\n        aws_session_token=temp_creds_req[\"sessionToken\"],\n        region_name=\"us-west-2\",\n    )\n\n    rio_env = rio.Env(\n        AWSSession(session),\n        GDAL_DISABLE_READDIR_ON_OPEN=\"EMPTY_DIR\",\n        CPL_VSIL_CURL_ALLOWED_EXTENSIONS=\"TIF, TIFF\",\n        GDAL_HTTP_COOKIEFILE=os.path.expanduser(\"~/cookies.txt\"),\n        GDAL_HTTP_COOKIEJAR=os.path.expanduser(\"~/cookies.txt\"),\n    )\n    rio_env.__enter__()\n\n    default_title = m._NASA_DATA[m._NASA_DATA[\"ShortName\"] == default_dataset][\n        \"EntryTitle\"\n    ].values[0]\n\n    output = widgets.Output(\n        layout=widgets.Layout(width=widget_width, padding=padding, overflow=\"auto\")\n    )\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Search NASA Earth data\",\n        icon=\"search\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    short_name = widgets.Dropdown(\n        options=m._NASA_DATA_NAMES,\n        value=default_dataset,\n        description=\"Short Name:\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    title = widgets.Text(\n        value=default_title,\n        description=\"Title:\",\n        style=style,\n        disabled=True,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    max_items = widgets.IntText(\n        value=50,\n        description=\"Max items:\",\n        style=style,\n        layout=widgets.Layout(width=\"125px\", padding=padding),\n    )\n\n    bbox = widgets.Text(\n        value=\"\",\n        description=\"Bounding box:\",\n        placeholder=\"xmin, ymin, xmax, ymax\",\n        style=style,\n        layout=widgets.Layout(width=\"271px\", padding=padding),\n    )\n\n    start_date = widgets.DatePicker(\n        description=\"Start date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=\"198px\", padding=padding),\n    )\n    end_date = widgets.DatePicker(\n        description=\"End date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=\"198px\", padding=padding),\n    )\n\n    dataset = widgets.Dropdown(\n        value=None,\n        description=\"Dataset:\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    layer = widgets.Dropdown(\n        value=None,\n        description=\"Layer:\",\n        style=style,\n        layout=widgets.Layout(width=\"200px\", padding=padding),\n    )\n\n    palette = widgets.Dropdown(\n        options=cmap_options,\n        value=None,\n        description=\"Colormap:\",\n        style=style,\n        layout=widgets.Layout(width=\"200px\", padding=padding),\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Search\", \"Display\", \"Reset\", \"Close\"],\n        tooltips=[\"Get Items\", \"Display Image\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"65px\"\n\n    def change_dataset(change):\n        title.value = m._NASA_DATA[m._NASA_DATA[\"ShortName\"] == short_name.value][\n            \"EntryTitle\"\n        ].values[0]\n        dataset.value = None\n        dataset.options = []\n        layer.value = None\n        layer.options = []\n\n    short_name.observe(change_dataset, \"value\")\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        short_name,\n        title,\n        widgets.HBox([max_items, bbox]),\n        widgets.HBox([start_date, end_date]),\n        dataset,\n        widgets.HBox([layer, palette]),\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Search\":\n            with output:\n                output.clear_output()\n                with output:\n                    print(\"Searching...\")\n\n                    if bbox.value.strip() == \"\":\n                        if m.user_roi_bounds() is not None:\n                            bounds = tuple(m.user_roi_bounds())\n                        else:\n                            bounds = (\n                                m.bounds[0][1],\n                                m.bounds[0][0],\n                                m.bounds[1][1],\n                                m.bounds[1][0],\n                            )\n                    else:\n                        bounds = tuple(map(float, bbox.value.split(\",\")))\n                        if len(bounds) != 4:\n                            print(\"Please provide a valid bounding box.\")\n                            bounds = None\n\n                    if start_date.value is not None and end_date.value is not None:\n                        date_range = (str(start_date.value), str(end_date.value))\n                    elif start_date.value is not None:\n                        date_range = (\n                            str(start_date.value),\n                            datetime.today().strftime(\"%Y-%m-%d\"),\n                        )\n                    else:\n                        date_range = None\n\n                    output.clear_output(wait=True)\n                    try:\n                        results, gdf = nasa_data_search(\n                            count=max_items.value,\n                            short_name=short_name.value,\n                            bbox=bounds,\n                            temporal=date_range,\n                            return_gdf=True,\n                        )\n\n                        if len(results) &gt; 0:\n                            if \"Footprints\" in m.get_layer_names():\n                                m.remove(m.find_layer(\"Footprints\"))\n                            if (\n                                hasattr(m, \"_NASA_DATA_CTRL\")\n                                and m._NASA_DATA_CTRL in m.controls\n                            ):\n                                m.remove(m._NASA_DATA_CTRL)\n\n                            style = {\n                                # \"stroke\": True,\n                                \"color\": \"#3388ff\",\n                                \"weight\": 2,\n                                \"opacity\": 1,\n                                \"fill\": True,\n                                \"fillColor\": \"#3388ff\",\n                                \"fillOpacity\": 0.1,\n                            }\n\n                            hover_style = {\n                                \"weight\": style[\"weight\"] + 2,\n                                \"fillOpacity\": 0,\n                                \"color\": \"yellow\",\n                            }\n\n                            m.add_gdf(\n                                gdf,\n                                layer_name=\"Footprints\",\n                                info_mode=\"on_click\",\n                                zoom_to_layer=False,\n                                style=style,\n                                hover_style=hover_style,\n                            )\n                            setattr(m, \"_NASA_DATA_CTRL\", m.controls[-1])\n\n                            dataset.options = gdf[\"native-id\"].values.tolist()\n                            dataset.value = dataset.options[0]\n\n                            setattr(m, \"_NASA_DATA_GDF\", gdf)\n                            setattr(m, \"_NASA_DATA_RESULTS\", results)\n\n                            if len(m._NASA_DATA_RESULTS) &gt; 0:\n                                links = m._NASA_DATA_RESULTS[0].data_links()\n                                layer.options = [link.split(\"_\")[-1] for link in links]\n                                layer.value = layer.options[0]\n                            else:\n                                layer.options = []\n                                layer.value = None\n\n                            output.clear_output()\n\n                    except Exception as e:\n                        print(e)\n\n        elif change[\"new\"] == \"Display\":\n            output.clear_output()\n            with output:\n                print(\"Loading...\")\n                links = m._NASA_DATA_RESULTS[\n                    dataset.options.index(dataset.value)\n                ].data_links()\n                link = links[layer.index]\n                try:\n                    if link.endswith(\".tif\"):\n                        ds = xr.open_dataset(link, engine=\"rasterio\")\n                        setattr(m, \"_NASA_DATA_DS\", ds)\n                        da = ds[\"band_data\"]\n                        nodata = os.environ.get(\"NODATA\", 0)\n                        da = da.fillna(nodata)\n                        try:\n                            colormap = get_image_colormap(ds)\n                        except Exception as e:\n                            colormap = None\n                        image = array_to_image(da, colormap=colormap)\n                        setattr(m, \"_NASA_DATA_IMAGE\", image)\n                        name_prefix = layer.value.split(\".\")[0]\n                        items = dataset.value.split(\"_\")\n                        name_suffix = items[3] + \"_\" + items[4][:8] + \"_\" + items[6]\n                        layer_name = f\"{name_prefix}_{name_suffix}\"\n                        m.add_raster(\n                            image,\n                            zoom_to_layer=True,\n                            colormap=palette.value,\n                            nodata=nodata,\n                            layer_name=layer_name,\n                        )\n                        output.clear_output()\n                    else:\n                        output.clear_output()\n                        print(\"Only GeoTIFF files are supported.\")\n                except Exception as e:\n                    output.clear_output()\n                    print(e)\n\n        elif change[\"new\"] == \"Reset\":\n            short_name.options = m._NASA_DATA_NAMES\n            short_name.value = default_dataset\n            title.value = default_title\n            max_items.value = 50\n            bbox.value = \"\"\n            bbox.placeholder = \"xmin, ymin, xmax, ymax\"\n            start_date.value = None\n            end_date.value = None\n            dataset.options = []\n            dataset.value = None\n            layer.options = []\n            layer.value = None\n            palette.value = None\n            output.clear_output()\n\n            if \"Footprints\" in m.get_layer_names():\n                m.remove(m.find_layer(\"Footprints\"))\n            if hasattr(m, \"_NASA_DATA_CTRL\") and m._NASA_DATA_CTRL in m.controls:\n                m.remove(m._NASA_DATA_CTRL)\n\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = opened\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=position\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.oam_search_gui","title":"<code>oam_search_gui(m, position='topright', opened=True)</code>","text":"<p>Generates a tool GUI template using ipywidgets. Icons can be found at https://fontawesome.com/v4/icons</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>beamgis/toolbar.py</code> <pre><code>def oam_search_gui(\n    m,\n    position: Optional[str] = \"topright\",\n    opened: Optional[bool] = True,\n):\n    \"\"\"Generates a tool GUI template using ipywidgets. Icons can be found at https://fontawesome.com/v4/icons\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"plane\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    dropdown = widgets.Dropdown(\n        options=[\"Map bounds\", \"User drawn ROI\", \"Custom bbox\"],\n        value=\"Map bounds\",\n        description=\"bbox:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    start_date = widgets.DatePicker(\n        description=\"start date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n    end_date = widgets.DatePicker(\n        description=\"end date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    checkbox = widgets.Checkbox(\n        description=\"Additional parameters\",\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=widget_width),\n    )\n\n    textarea = widgets.Textarea(\n        placeholder=\"Addition parameters as a dictionary, e.g., {'platform': 'UAV'}\",\n        layout=widgets.Layout(width=widget_width),\n    )\n\n    params_hbox = widgets.HBox()\n\n    def checkbox_changed(change):\n        if checkbox.value:\n            params_hbox.children = [textarea]\n        else:\n            params_hbox.children = []\n\n    checkbox.observe(checkbox_changed, \"value\")\n\n    int_slider = widgets.IntSlider(\n        value=100,\n        min=1,\n        max=200,\n        description=\"Limit: \",\n        readout=False,\n        continuous_update=True,\n        layout=widgets.Layout(width=\"220px\", padding=padding),\n        style=style,\n    )\n\n    int_slider_label = widgets.Label(\"100\")\n\n    def int_slider_changed(change):\n        if change[\"new\"]:\n            int_slider_label.value = str(int_slider.value)\n\n    int_slider.observe(int_slider_changed, \"value\")\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Search\", \"Reset\", \"Close\"],\n        tooltips=[\"Search\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        dropdown,\n        start_date,\n        end_date,\n        widgets.HBox([int_slider, int_slider_label]),\n        checkbox,\n        params_hbox,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Search\":\n            with output:\n                output.outputs = ()\n                if m is not None:\n                    if dropdown.value == \"Map bounds\":\n                        bbox = m.get_bbox()\n                    elif dropdown.value == \"User drawn ROI\":\n                        bbox = m.user_roi_bounds()\n                    else:\n                        bbox = None\n\n                    if start_date.value is not None:\n                        start = str(start_date.value)\n                    else:\n                        start = None\n                    if end_date.value is not None:\n                        end = str(end_date.value)\n                    else:\n                        end = None\n\n                    if (\n                        checkbox.value\n                        and textarea.value.strip().startswith(\"{\")\n                        and textarea.value.strip().endswith(\"}\")\n                    ):\n                        params = eval(textarea.value)\n                    else:\n                        params = {}\n\n                    limit = int_slider.value\n\n                    m.oam_search(bbox, start, end, limit=limit, **params)\n\n        elif change[\"new\"] == \"Reset\":\n            textarea.value = \"\"\n            dropdown.value = \"Map bounds\"\n            start_date.value = None\n            end_date.value = None\n            checkbox.value = False\n            int_slider.value = 100\n            output.outputs = ()\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = opened\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=position\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.open_data_widget","title":"<code>open_data_widget(m)</code>","text":"<p>A widget for opening local vector/raster data.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>object</code> <p>leafmap.Map</p> required Source code in <code>beamgis/toolbar.py</code> <pre><code>def open_data_widget(m):\n    \"\"\"A widget for opening local vector/raster data.\n\n    Args:\n        m (object): leafmap.Map\n    \"\"\"\n    import warnings\n    from .colormaps import list_colormaps\n\n    warnings.filterwarnings(\"ignore\")\n\n    padding = \"0px 0px 0px 5px\"\n    style = {\"description_width\": \"initial\"}\n\n    file_type = widgets.ToggleButtons(\n        options=[\"Shapefile\", \"GeoJSON\", \"CSV\", \"Vector\", \"Raster\"],\n        tooltips=[\n            \"Open a shapefile\",\n            \"Open a GeoJSON file\",\n            \"Open a vector dataset\",\n            \"Create points from CSV\",\n            \"Open a vector dataset\",\n            \"Open a raster dataset\",\n        ],\n    )\n    file_type.style.button_width = \"88px\"\n\n    filepath = widgets.Text(\n        value=\"\",\n        description=\"File path or http URL:\",\n        tooltip=\"Enter a file path or http URL to vector data\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n    http_widget = widgets.HBox()\n\n    file_chooser = FileChooser(\n        os.getcwd(), sandbox_path=m.sandbox_path, layout=widgets.Layout(width=\"454px\")\n    )\n    file_chooser.filter_pattern = \"*.shp\"\n    file_chooser.use_dir_icons = True\n\n    layer_name = widgets.Text(\n        value=\"Shapefile\",\n        description=\"Enter a layer name:\",\n        tooltip=\"Enter a layer name for the selected file\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    longitude = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Longitude:\",\n        layout=widgets.Layout(width=\"149px\", padding=padding),\n        style=style,\n    )\n\n    latitude = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Latitude:\",\n        layout=widgets.Layout(width=\"149px\", padding=padding),\n        style=style,\n    )\n\n    label = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Label:\",\n        layout=widgets.Layout(width=\"149px\", padding=padding),\n        style=style,\n    )\n\n    point_check = widgets.Checkbox(\n        description=\"Is it a point layer?\",\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=\"150px\"),\n        style=style,\n    )\n\n    point_popup = widgets.SelectMultiple(\n        options=[\n            \"None\",\n        ],\n        value=[\"None\"],\n        description=\"Popup attributes:\",\n        disabled=False,\n        style=style,\n    )\n\n    csv_widget = widgets.HBox()\n    point_widget = widgets.HBox()\n\n    def point_layer_check(change):\n        if point_check.value:\n            if filepath.value.strip() != \"\":\n                m.default_style = {\"cursor\": \"wait\"}\n                point_popup.options = vector_col_names(filepath.value)\n                point_popup.value = [point_popup.options[0]]\n\n            point_widget.children = [point_check, point_popup]\n        else:\n            point_widget.children = [point_check]\n\n    point_check.observe(point_layer_check)\n\n    ok_cancel = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    # ok_cancel.style.button_width = \"50px\"\n\n    bands = widgets.Text(\n        value=None,\n        description=\"Band:\",\n        tooltip=\"Enter a list of band indices\",\n        style=style,\n        layout=widgets.Layout(width=\"150px\", padding=padding),\n    )\n\n    vmin = widgets.Text(\n        value=None,\n        description=\"vmin:\",\n        tooltip=\"Minimum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"148px\"),\n    )\n\n    vmax = widgets.Text(\n        value=None,\n        description=\"vmax:\",\n        tooltip=\"Maximum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"148px\"),\n    )\n\n    nodata = widgets.Text(\n        value=None,\n        description=\"Nodata:\",\n        tooltip=\"Nodata the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"150px\", padding=padding),\n    )\n\n    palette = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"palette:\",\n        layout=widgets.Layout(width=\"300px\"),\n        style=style,\n    )\n\n    raster_options = widgets.VBox()\n\n    def filepath_change(_):\n        if file_type.value == \"Raster\":\n            pass\n            # if (\n            #     filepath.value.startswith(\"http\")\n            #     or filepath.value.endswith(\".txt\")\n            #     or filepath.value.endswith(\".csv\")\n            # ):\n            #     bands.disabled = True\n            #     palette.disabled = False\n            #     # x_dim.disabled = True\n            #     # y_dim.disabled = True\n            # else:\n            #     bands.disabled = False\n            #     palette.disabled = False\n            #     # x_dim.disabled = True\n            #     # y_dim.disabled = True\n\n    filepath.observe(filepath_change, \"value\")\n\n    tool_output = widgets.Output(\n        layout=widgets.Layout(max_height=\"150px\", max_width=\"500px\", overflow=\"auto\")\n    )\n\n    main_widget = widgets.VBox(\n        [\n            file_type,\n            file_chooser,\n            http_widget,\n            csv_widget,\n            layer_name,\n            point_widget,\n            raster_options,\n            ok_cancel,\n            tool_output,\n        ]\n    )\n\n    tool_output_ctrl = ipyleaflet.WidgetControl(widget=main_widget, position=\"topright\")\n\n    if m.tool_output_ctrl is not None and m.tool_output_ctrl in m.controls:\n        m.remove_control(m.tool_output_ctrl)\n\n    def bands_changed(change):\n        if change[\"new\"] and \",\" in change[\"owner\"].value:\n            palette.value = None\n            palette.disabled = True\n        else:\n            palette.disabled = False\n\n    bands.observe(bands_changed, \"value\")\n\n    def chooser_callback(chooser):\n        filepath.value = file_chooser.selected\n\n        if file_type.value == \"CSV\":\n            import pandas as pd\n\n            df = pd.read_csv(filepath.value)\n            col_names = df.columns.values.tolist()\n            longitude.options = col_names\n            latitude.options = col_names\n            label.options = col_names\n\n            if \"longitude\" in col_names:\n                longitude.value = \"longitude\"\n            if \"latitude\" in col_names:\n                latitude.value = \"latitude\"\n            if \"name\" in col_names:\n                label.value = \"name\"\n\n    file_chooser.register_callback(chooser_callback)\n\n    def file_type_changed(change):\n        ok_cancel.value = None\n        file_chooser.default_path = os.getcwd()\n        file_chooser.reset()\n        layer_name.value = file_type.value\n        csv_widget.children = []\n        filepath.value = \"\"\n        tool_output.outputs = ()\n\n        if change[\"new\"] == \"Shapefile\":\n            file_chooser.filter_pattern = \"*.shp\"\n            raster_options.children = []\n            point_widget.children = []\n            point_check.value = False\n            http_widget.children = []\n        elif change[\"new\"] == \"GeoJSON\":\n            file_chooser.filter_pattern = [\"*.geojson\", \"*.json\"]\n            raster_options.children = []\n            point_widget.children = []\n            point_check.value = False\n            http_widget.children = [filepath]\n        elif change[\"new\"] == \"Vector\":\n            file_chooser.filter_pattern = \"*.*\"\n            raster_options.children = []\n            point_widget.children = [point_check]\n            point_check.value = False\n            http_widget.children = [filepath]\n        elif change[\"new\"] == \"CSV\":\n            file_chooser.filter_pattern = [\"*.csv\", \"*.CSV\"]\n            csv_widget.children = [longitude, latitude, label]\n            raster_options.children = []\n            point_widget.children = []\n            point_check.value = False\n            http_widget.children = [filepath]\n        elif change[\"new\"] == \"Raster\":\n            file_chooser.filter_pattern = [\"*.tif\", \"*.img\"]\n            palette.options = list_colormaps(add_extra=True)\n            palette.value = None\n            raster_options.children = [\n                widgets.HBox([bands, vmin, vmax]),\n                widgets.HBox([nodata, palette]),\n            ]\n            point_widget.children = []\n            point_check.value = False\n            http_widget.children = [filepath]\n\n    def ok_cancel_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            m.default_style = {\"cursor\": \"wait\"}\n            file_path = filepath.value\n\n            with tool_output:\n                tool_output.outputs = ()\n                if file_path.strip() != \"\":\n                    ext = os.path.splitext(file_path)[1]\n                    if point_check.value:\n                        popup = list(point_popup.value)\n                        if len(popup) == 1:\n                            popup = popup[0]\n                        m.add_point_layer(\n                            file_path,\n                            popup=popup,\n                            layer_name=layer_name.value,\n                        )\n                    elif ext.lower() == \".shp\":\n                        m.add_shp(file_path, style={}, layer_name=layer_name.value)\n                    elif ext.lower() == \".geojson\":\n                        m.add_geojson(file_path, style={}, layer_name=layer_name.value)\n\n                    elif ext.lower() == \".csv\" and file_type.value == \"CSV\":\n                        m.add_xy_data(\n                            file_path,\n                            x=longitude.value,\n                            y=latitude.value,\n                            label=label.value,\n                            layer_name=layer_name.value,\n                        )\n\n                    elif (\n                        ext.lower() in [\".tif\", \"img\"]\n                    ) and file_type.value == \"Raster\":\n                        band = None\n                        vis_min = None\n                        vis_max = None\n                        vis_nodata = None\n\n                        try:\n                            if len(bands.value) &gt; 0:\n                                band = int(bands.value)\n                            if len(vmin.value) &gt; 0:\n                                vis_min = float(vmin.value)\n                            if len(vmax.value) &gt; 0:\n                                vis_max = float(vmax.value)\n                            if len(nodata.value) &gt; 0:\n                                vis_nodata = float(nodata.value)\n                        except Exception as _:\n                            pass\n\n                        m.add_raster(\n                            file_path,\n                            layer_name=layer_name.value,\n                            band=band,\n                            palette=palette.value,\n                            vmin=vis_min,\n                            vmax=vis_max,\n                            nodata=vis_nodata,\n                        )\n\n                else:\n                    print(\"Please select a file to open.\")\n\n            m.toolbar_reset()\n            m.default_style = {\"cursor\": \"default\"}\n\n        elif change[\"new\"] == \"Reset\":\n            file_chooser.reset()\n            tool_output.outputs = ()\n            filepath.value = \"\"\n            m.toolbar_reset()\n        elif change[\"new\"] == \"Close\":\n            if m.tool_output_ctrl is not None and m.tool_output_ctrl in m.controls:\n                m.remove_control(m.tool_output_ctrl)\n                m.tool_output_ctrl = None\n                m.toolbar_reset()\n\n        ok_cancel.value = None\n\n    file_type.observe(file_type_changed, names=\"value\")\n    ok_cancel.observe(ok_cancel_clicked, names=\"value\")\n    # file_chooser.register_callback(chooser_callback)\n\n    m.add(tool_output_ctrl)\n    m.tool_output_ctrl = tool_output_ctrl\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.open_raster_gui","title":"<code>open_raster_gui(m)</code>","text":"<p>A widget for opening local/remote COG/STAC data.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>object</code> <p>leafmap.Map</p> required Source code in <code>beamgis/toolbar.py</code> <pre><code>def open_raster_gui(m):\n    \"\"\"A widget for opening local/remote COG/STAC data.\n\n    Args:\n        m (object): leafmap.Map\n    \"\"\"\n\n    padding = \"0px 0px 0px 5px\"\n    style = {\"description_width\": \"initial\"}\n\n    tool_output = widgets.Output(\n        layout=widgets.Layout(max_height=\"150px\", max_width=\"500px\", overflow=\"auto\")\n    )\n\n    file_type = widgets.ToggleButtons(\n        options=[\"GeoTIFF\", \"COG\", \"STAC\", \"Microsoft\"],\n        tooltips=[\n            \"Open a local GeoTIFF file\",\n            \"Open a remote COG file\",\n            \"Open a remote STAC item\",\n            \"Create COG from Microsoft Planetary Computer\",\n        ],\n    )\n    file_type.style.button_width = \"110px\"\n\n    file_chooser = FileChooser(\n        os.getcwd(), sandbox_path=m.sandbox_path, layout=widgets.Layout(width=\"454px\")\n    )\n    file_chooser.filter_pattern = [\"*.tif\", \"*.tiff\"]\n    file_chooser.use_dir_icons = True\n\n    source_widget = widgets.VBox([file_chooser])\n\n    http_url = widgets.Text(\n        value=\"\",\n        description=\"HTTP URL:\",\n        tooltip=\"Enter an http URL to COG file\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    collection = widgets.Dropdown(\n        options=[\"landsat-8-c2-l2 - Landsat 8 Collection 2 Level-2\"],\n        value=\"landsat-8-c2-l2 - Landsat 8 Collection 2 Level-2\",\n        description=\"PC Collection:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    items = widgets.Text(\n        value=\"LC08_L2SP_047027_20201204_02_T1\",\n        description=\"STAC Items:\",\n        tooltip=\"STAC Item ID\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    assets = widgets.Text(\n        value=\"SR_B7,SR_B5,SR_B4\",\n        description=\"STAC Assets:\",\n        tooltip=\"STAC Asset ID\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    layer_name = widgets.Text(\n        value=\"GeoTIFF\",\n        description=\"Enter a layer name:\",\n        tooltip=\"Enter a layer name for the selected file\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    ok_cancel = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    # ok_cancel.style.button_width = \"50px\"\n\n    bands = widgets.Text(\n        value=None,\n        description=\"Band:\",\n        tooltip=\"Enter a list of band indices\",\n        style=style,\n        layout=widgets.Layout(width=\"150px\", padding=padding),\n    )\n\n    band_width = \"149px\"\n    red = widgets.Dropdown(\n        value=None,\n        options=[],\n        description=\"Red:\",\n        tooltip=\"Select a band for the red channel\",\n        style=style,\n        layout=widgets.Layout(width=band_width, padding=padding),\n    )\n\n    green = widgets.Dropdown(\n        value=None,\n        options=[],\n        description=\"Green:\",\n        tooltip=\"Select a band for the green channel\",\n        style=style,\n        layout=widgets.Layout(width=\"148px\", padding=padding),\n    )\n\n    blue = widgets.Dropdown(\n        value=None,\n        options=[],\n        description=\"Blue:\",\n        tooltip=\"Select a band for the blue channel\",\n        style=style,\n        layout=widgets.Layout(width=band_width, padding=padding),\n    )\n\n    vmin = widgets.Text(\n        value=None,\n        description=\"vmin:\",\n        tooltip=\"Minimum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"148px\", padding=padding),\n    )\n\n    vmax = widgets.Text(\n        value=None,\n        description=\"vmax:\",\n        tooltip=\"Maximum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"148px\", padding=padding),\n    )\n\n    nodata = widgets.Text(\n        value=None,\n        description=\"Nodata:\",\n        tooltip=\"Nodata the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"150px\", padding=padding),\n    )\n\n    local_tile_palettes = list_palettes(add_extra=True)\n    cog_stac_palettes = list_palettes(lowercase=True)\n    palette_options = local_tile_palettes\n    palette = widgets.Dropdown(\n        options=palette_options,\n        value=None,\n        description=\"palette:\",\n        layout=widgets.Layout(width=\"300px\", padding=padding),\n        style=style,\n    )\n\n    checkbox = widgets.Checkbox(\n        value=False,\n        description=\"Additional params\",\n        indent=False,\n        layout=widgets.Layout(width=\"154px\", padding=padding),\n        style=style,\n    )\n\n    add_params_text1 = \"Additional parameters in the format of a dictionary, for example, \\n {'palette': ['#006633', '#E5FFCC', '#662A00', '#D8D8D8', '#F5F5F5']}\"\n    add_params_text2 = \"Additional parameters in the format of a dictionary, for example, \\n {'expression': '(SR_B5-SR_B4)/(SR_B5+SR_B4)'}\"\n    add_params = widgets.Textarea(\n        value=\"\",\n        placeholder=add_params_text1,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n        style=style,\n    )\n\n    params_widget = widgets.HBox()\n\n    raster_options = widgets.VBox()\n    raster_options.children = [\n        widgets.HBox([red, green, blue]),\n        widgets.HBox([vmin, vmax, nodata]),\n        widgets.HBox([palette, checkbox]),\n        params_widget,\n    ]\n\n    def collection_changed(change):\n        if change[\"new\"]:\n            if not hasattr(m, \"pc_inventory\"):\n                setattr(m, \"pc_inventory\", pc.get_pc_inventory())\n            col_name = change[\"new\"].split(\" - \")[0]\n            items.value = m.pc_inventory[col_name][\"first_item\"]\n            band_names = m.pc_inventory[col_name][\"bands\"]\n            red.options = band_names\n            green.options = band_names\n            blue.options = band_names\n\n            if change[\"new\"] == \"landsat-8-c2-l2 - Landsat 8 Collection 2 Level-2\":\n                items.value = \"LC08_L2SP_047027_20201204_02_T1\"\n                assets.value = \"SR_B7,SR_B5,SR_B4\"\n                red.value = \"SR_B7\"\n                green.value = \"SR_B5\"\n                blue.value = \"SR_B4\"\n            elif change[\"new\"] == \"sentinel-2-l2a - Sentinel-2 Level-2A\":\n                items.value = \"S2B_MSIL2A_20190629T212529_R043_T06VVN_20201006T080531\"\n                assets.value = \"B08,B04,B03\"\n                red.value = \"B08\"\n                green.value = \"B04\"\n                blue.value = \"B03\"\n            else:\n                if len(band_names) &gt; 2:\n                    assets.value = \",\".join(band_names[:3])\n                    red.value = band_names[0]\n                    green.value = band_names[1]\n                    blue.value = band_names[2]\n                else:\n                    assets.value = band_names[0]\n                    red.value = band_names[0]\n                    green.value = band_names[0]\n                    blue.value = band_names[0]\n\n    collection.observe(collection_changed, names=\"value\")\n\n    def band_changed(change):\n        if change[\"name\"]:\n            if not checkbox.value:\n                if file_type.value == \"GeoTIFF\":\n                    if hasattr(m, \"tile_client\"):\n                        min_max = local_tile_vmin_vmax(\n                            m.tile_client, bands=[red.value, green.value, blue.value]\n                        )\n                        vmin.value = str(min_max[0])\n                        vmax.value = str(min_max[1])\n                elif file_type.value == \"Microsoft\":\n                    if len(set([red.value, green.value, blue.value])) == 1:\n                        assets.value = f\"{red.value}\"\n                    else:\n                        assets.value = f\"{red.value},{green.value},{blue.value}\"\n\n    red.observe(band_changed, names=\"value\")\n    green.observe(band_changed, names=\"value\")\n    blue.observe(band_changed, names=\"value\")\n\n    def checkbox_changed(change):\n        if change[\"new\"]:\n            params_widget.children = [add_params]\n        else:\n            params_widget.children = []\n\n    checkbox.observe(checkbox_changed, names=\"value\")\n\n    def url_change(change):\n        if change[\"new\"] and change[\"new\"].startswith(\"http\"):\n            with tool_output:\n                try:\n                    print(\"Retrieving band names...\")\n                    if file_type.value == \"COG\":\n                        bandnames = cog_bands(change[\"new\"])\n                    elif file_type.value == \"STAC\":\n                        bandnames = stac_bands(change[\"new\"])\n                    red.options = bandnames\n                    green.options = bandnames\n                    blue.options = bandnames\n                    if len(bandnames) &gt; 2:\n                        red.value = bandnames[0]\n                        green.value = bandnames[1]\n                        blue.value = bandnames[2]\n                    else:\n                        red.value = bandnames[0]\n                        green.value = bandnames[0]\n                        blue.value = bandnames[0]\n                    tool_output.outputs = ()\n\n                except Exception as e:\n                    print(e)\n                    print(\"Error loading URL.\")\n                    return\n        else:\n            red.options = []\n            green.options = []\n            blue.options = []\n            vmin.value = \"\"\n            vmax.value = \"\"\n            nodata.value = \"\"\n            palette.value = None\n\n    http_url.observe(url_change, names=\"value\")\n\n    main_widget = widgets.VBox(\n        [\n            file_type,\n            source_widget,\n            layer_name,\n            raster_options,\n            ok_cancel,\n            tool_output,\n        ]\n    )\n\n    tool_output_ctrl = ipyleaflet.WidgetControl(widget=main_widget, position=\"topright\")\n\n    if m.tool_output_ctrl is not None and m.tool_output_ctrl in m.controls:\n        m.remove_control(m.tool_output_ctrl)\n\n    def bands_changed(change):\n        if change[\"new\"] and \",\" in change[\"owner\"].value:\n            palette.value = None\n            palette.disabled = True\n        else:\n            palette.disabled = False\n\n    bands.observe(bands_changed, \"value\")\n\n    def chooser_callback(chooser):\n        try:\n            source = file_chooser.selected\n            tile_layer, tile_client = get_local_tile_layer(source, return_client=True)\n            if not hasattr(m, \"tile_client\"):\n                setattr(m, \"tile_client\", tile_client)\n            bandnames = local_tile_bands(tile_client)\n            red.options = bandnames\n            green.options = bandnames\n            blue.options = bandnames\n            if len(bandnames) &gt; 2:\n                red.value = bandnames[0]\n                green.value = bandnames[1]\n                blue.value = bandnames[2]\n                min_max = local_tile_vmin_vmax(\n                    tile_client, bands=[red.value, green.value, blue.value]\n                )\n                vmin.value = str(min_max[0])\n                vmax.value = str(min_max[1])\n            else:\n                red.value = bandnames[0]\n                green.value = bandnames[0]\n                blue.value = bandnames[0]\n                min_max = local_tile_vmin_vmax(tile_client)\n                vmin.value = str(min_max[0])\n                vmax.value = str(min_max[1])\n        except Exception as e:\n            with tool_output:\n                print(e)\n\n    file_chooser.register_callback(chooser_callback)\n\n    def file_type_changed(change):\n        ok_cancel.value = None\n        file_chooser.default_path = os.getcwd()\n        file_chooser.reset()\n        layer_name.value = file_type.value\n        http_url.value = \"\"\n        tool_output.outputs = ()\n        red.value = None\n        green.value = None\n        blue.value = None\n        vmin.value = \"\"\n        vmax.value = \"\"\n        nodata.value = \"\"\n        palette.value = None\n\n        if change[\"new\"] == \"GeoTIFF\":\n            source_widget.children = [file_chooser]\n            file_chooser.filter_pattern = [\"*.tif\", \"*.tiff\"]\n            palette.options = local_tile_palettes\n            palette.value = None\n            add_params.placeholder = add_params_text1\n            raster_options.children = [\n                widgets.HBox([red, green, blue]),\n                widgets.HBox([vmin, vmax, nodata]),\n                widgets.HBox([palette, checkbox]),\n                params_widget,\n            ]\n        elif change[\"new\"] == \"COG\":\n            http_url.value = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"\n            source_widget.children = [http_url]\n            palette.options = cog_stac_palettes\n            palette.value = None\n            add_params.placeholder = add_params_text2\n        elif change[\"new\"] == \"STAC\":\n            http_url.value = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\n            source_widget.children = [http_url]\n            palette.options = cog_stac_palettes\n            palette.value = None\n            red.value = \"B3\"\n            green.value = \"B2\"\n            blue.value = \"B1\"\n            add_params.placeholder = add_params_text2\n        elif change[\"new\"] == \"Microsoft\":\n            source_widget.children = [collection, items, assets]\n            palette.options = cog_stac_palettes\n            palette.value = None\n            add_params.placeholder = add_params_text2\n            collection.options = pc.get_pc_collection_list()\n            collection.value = \"landsat-8-c2-l2 - Landsat 8 Collection 2 Level-2\"\n            if not hasattr(m, \"pc_inventory\"):\n                setattr(m, \"pc_inventory\", pc.get_pc_inventory())\n            items.value = \"LC08_L2SP_047027_20201204_02_T1\"\n            assets.value = \"SR_B7,SR_B5,SR_B4\"\n\n    def ok_cancel_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            m.default_style = {\"cursor\": \"wait\"}\n            # file_path = http_url.value\n\n            with tool_output:\n                tool_output.outputs = ()\n                print(\"Loading data...\")\n                if file_type.value == \"GeoTIFF\" and file_chooser.selected:\n                    band = None\n                    vis_min = None\n                    vis_max = None\n                    vis_nodata = None\n                    vis_palette = None\n\n                    try:\n                        if len(red.options) &gt; 2:\n                            band = [red.value, green.value, blue.value]\n                            if len(set(band)) &gt; 1:\n                                palette.value = None\n                            else:\n                                band = [red.value]\n                        else:\n                            band = [red.value]\n                        if len(vmin.value) &gt; 0:\n                            vis_min = float(vmin.value)\n                        if len(vmax.value) &gt; 0:\n                            vis_max = float(vmax.value)\n                        if len(nodata.value) &gt; 0:\n                            vis_nodata = float(nodata.value)\n                        if (\n                            checkbox.value\n                            and add_params.value.strip().startswith(\"{\")\n                            and add_params.value.strip().endswith(\"}\")\n                        ):\n                            vis_params = eval(add_params.value)\n                            if \"palette\" in vis_params:\n                                vis_palette = vis_params[\"palette\"]\n                            else:\n                                vis_palette = get_palette_colors(\n                                    palette.value, hashtag=True\n                                )\n                        elif palette.value is not None:\n                            vis_palette = get_palette_colors(\n                                palette.value, hashtag=True\n                            )\n                    except Exception as e:\n                        pass\n\n                    m.add_raster(\n                        file_chooser.selected,\n                        layer_name=layer_name.value,\n                        band=band,\n                        palette=vis_palette,\n                        vmin=vis_min,\n                        vmax=vis_max,\n                        nodata=vis_nodata,\n                    )\n                    tool_output.outputs = ()\n                elif file_type.value in [\"COG\", \"STAC\"] and http_url.value:\n                    try:\n                        tool_output.outputs = ()\n                        print(\"Loading data...\")\n\n                        if (\n                            checkbox.value\n                            and add_params.value.strip().startswith(\"{\")\n                            and add_params.value.strip().endswith(\"}\")\n                        ):\n                            vis_params = eval(add_params.value)\n                        else:\n                            vis_params = {}\n\n                        if (\n                            palette.value\n                            and len(set([red.value, green.value, blue.value])) == 1\n                        ):\n                            vis_params[\"colormap_name\"] = palette.value\n                        elif (\n                            palette.value\n                            and len(set([red.value, green.value, blue.value])) &gt; 1\n                        ):\n                            palette.value = None\n                            print(\"Palette can only be set for single band images.\")\n\n                        if vmin.value and vmax.value:\n                            vis_params[\"rescale\"] = f\"{vmin.value},{vmax.value}\"\n\n                        if nodata.value:\n                            vis_params[\"nodata\"] = nodata.value\n\n                        if file_type.value == \"COG\":\n                            m.add_cog_layer(\n                                http_url.value,\n                                name=layer_name.value,\n                                bands=[red.value, green.value, blue.value],\n                                **vis_params,\n                            )\n                        elif file_type.value == \"STAC\":\n                            m.add_stac_layer(\n                                http_url.value,\n                                bands=[red.value, green.value, blue.value],\n                                name=layer_name.value,\n                                **vis_params,\n                            )\n                        tool_output.outputs = ()\n                    except Exception as e:\n                        print(e)\n                        print(\"Error loading data.\")\n                        return\n\n                elif file_type.value == \"Microsoft\":\n                    try:\n                        tool_output.outputs = ()\n                        print(\"Loading data...\")\n\n                        if (\n                            checkbox.value\n                            and add_params.value.strip().startswith(\"{\")\n                            and add_params.value.strip().endswith(\"}\")\n                        ):\n                            vis_params = eval(add_params.value)\n                        else:\n                            vis_params = {}\n\n                        if (\n                            palette.value\n                            and len(set([red.value, green.value, blue.value])) == 1\n                        ) or (palette.value and \"expression\" in vis_params):\n                            vis_params[\"colormap_name\"] = palette.value\n                        elif (\n                            palette.value\n                            and len(set([red.value, green.value, blue.value])) &gt; 1\n                            and \"expression\" not in vis_params\n                        ):\n                            palette.value = None\n                            print(\"Palette can only be set for single band images.\")\n\n                        if vmin.value and vmax.value:\n                            vis_params[\"rescale\"] = f\"{vmin.value},{vmax.value}\"\n\n                        if nodata.value:\n                            vis_params[\"nodata\"] = nodata.value\n\n                        col = collection.value.split(\" - \")[0]\n                        m.add_stac_layer(\n                            collection=col,\n                            item=items.value,\n                            assets=assets.value,\n                            name=layer_name.value,\n                            **vis_params,\n                        )\n                        tool_output.outputs = ()\n                    except Exception as e:\n                        print(e)\n                        print(\"Error loading data.\")\n                        return\n\n                else:\n                    tool_output.outputs = ()\n                    print(\"Please select a file and enter an http URL.\")\n\n            m.toolbar_reset()\n            m.default_style = {\"cursor\": \"default\"}\n\n        elif change[\"new\"] == \"Reset\":\n            file_chooser.reset()\n            tool_output.outputs = ()\n            http_url.value = \"\"\n            add_params.value = \"\"\n            checkbox.value = False\n            palette.value = None\n            red.value = None\n            green.value = None\n            blue.value = None\n            vmin.value = \"\"\n            vmax.value = \"\"\n            nodata.value = \"\"\n            collection.value = None\n            items.value = \"\"\n            assets.value = \"\"\n            m.toolbar_reset()\n        elif change[\"new\"] == \"Close\":\n            if m.tool_output_ctrl is not None and m.tool_output_ctrl in m.controls:\n                m.remove_control(m.tool_output_ctrl)\n                m.tool_output_ctrl = None\n                m.toolbar_reset()\n\n        ok_cancel.value = None\n\n    file_type.observe(file_type_changed, names=\"value\")\n    ok_cancel.observe(ok_cancel_clicked, names=\"value\")\n\n    m.add(tool_output_ctrl)\n    m.tool_output_ctrl = tool_output_ctrl\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.plotly_basemap_gui","title":"<code>plotly_basemap_gui(canvas, map_min_width='78%', map_max_width='98%')</code>","text":"<p>Widget for changing basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>object</code> <p>leafmap.Map.</p> required Source code in <code>beamgis/toolbar.py</code> <pre><code>def plotly_basemap_gui(canvas, map_min_width=\"78%\", map_max_width=\"98%\"):\n    \"\"\"Widget for changing basemaps.\n\n    Args:\n        m (object): leafmap.Map.\n    \"\"\"\n    from .plotlymap import basemaps\n\n    m = canvas.map\n    layer_count = len(m.layout.mapbox.layers)\n    container_widget = canvas.container_widget\n    map_widget = canvas.map_widget\n\n    map_widget.layout.width = map_min_width\n\n    value = \"Esri.WorldTopoMap\"\n    m.add_basemap(value)\n\n    dropdown = widgets.Dropdown(\n        options=list(basemaps.keys()),\n        value=value,\n        layout=widgets.Layout(width=\"200px\"),\n    )\n\n    close_btn = widgets.Button(\n        icon=\"times\",\n        tooltip=\"Close the basemap widget\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    basemap_widget = widgets.HBox([dropdown, close_btn])\n    container_widget.children = [basemap_widget]\n\n    def on_click(change):\n        basemap_name = change[\"new\"]\n        m.layout.mapbox.layers = m.layout.mapbox.layers[:layer_count]\n        m.add_basemap(basemap_name)\n\n    dropdown.observe(on_click, \"value\")\n\n    def close_click(change):\n        container_widget.children = []\n        basemap_widget.close()\n        map_widget.layout.width = map_max_width\n        canvas.toolbar_reset()\n        canvas.toolbar_button.value = False\n\n    close_btn.on_click(close_click)\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.plotly_search_basemaps","title":"<code>plotly_search_basemaps(canvas)</code>","text":"<p>The widget for search XYZ tile services.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>plotlymap.Map</code> <p>The Plotly Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>beamgis/toolbar.py</code> <pre><code>def plotly_search_basemaps(canvas):\n    \"\"\"The widget for search XYZ tile services.\n\n    Args:\n        m (plotlymap.Map, optional): The Plotly Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import xyzservices.providers as xyz\n    from xyzservices import TileProvider\n\n    m = canvas.map\n    container_widget = canvas.container_widget\n    map_widget = canvas.map_widget\n    map_widget.layout.width = \"75%\"\n\n    # map_widget.layout.width = map_min_width\n\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"search\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    checkbox = widgets.Checkbox(\n        description=\"Search Quick Map Services (QMS)\",\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=widget_width),\n    )\n\n    providers = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"XYZ Tile:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    keyword = widgets.Text(\n        value=\"\",\n        description=\"Search keyword:\",\n        placeholder=\"OpenStreetMap\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    def search_callback(change):\n        providers.options = []\n        if keyword.value != \"\":\n            tiles = search_xyz_services(keyword=keyword.value)\n            if checkbox.value:\n                tiles = tiles + search_qms(keyword=keyword.value)\n            providers.options = tiles\n\n    keyword.on_submit(search_callback)\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Search\", \"Reset\", \"Close\"],\n        tooltips=[\"Search\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    def providers_change(change):\n        if change[\"new\"] != \"\":\n            provider = change[\"new\"]\n            if provider is not None:\n                if provider.startswith(\"qms\"):\n                    with output:\n                        output.outputs = ()\n                        print(\"Adding data. Please wait...\")\n                    name = provider[4:]\n                    qms_provider = TileProvider.from_qms(name)\n                    url = qms_provider.build_url()\n                    attribution = qms_provider.attribution\n                    m.add_tile_layer(url, name, attribution)\n                    output.outputs = ()\n                elif provider.startswith(\"xyz\"):\n                    name = provider[4:]\n                    xyz_provider = xyz.flatten()[name]\n                    url = xyz_provider.build_url()\n                    attribution = xyz_provider.attribution\n                    if xyz_provider.requires_token():\n                        with output:\n                            output.outputs = ()\n                            print(f\"{provider} requires an API Key.\")\n                    m.add_tile_layer(url, name, attribution)\n\n    providers.observe(providers_change, \"value\")\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        checkbox,\n        keyword,\n        providers,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            canvas.toolbar_reset()\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Search\":\n            providers.options = []\n            output.outputs = ()\n            if keyword.value != \"\":\n                tiles = search_xyz_services(keyword=keyword.value)\n                if checkbox.value:\n                    tiles = tiles + search_qms(keyword=keyword.value)\n                providers.options = tiles\n            else:\n                with output:\n                    print(\"Please enter a search keyword.\")\n        elif change[\"new\"] == \"Reset\":\n            keyword.value = \"\"\n            providers.options = []\n            output.outputs = ()\n        elif change[\"new\"] == \"Close\":\n            canvas.toolbar_reset()\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = True\n    container_widget.children = [toolbar_widget]\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.plotly_toolbar","title":"<code>plotly_toolbar(canvas)</code>","text":"<p>Creates the main toolbar and adds it to the map.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>plotlymap.Map</code> <p>The plotly Map object.</p> required Source code in <code>beamgis/toolbar.py</code> <pre><code>def plotly_toolbar(\n    canvas,\n):\n    \"\"\"Creates the main toolbar and adds it to the map.\n\n    Args:\n        m (plotlymap.Map): The plotly Map object.\n    \"\"\"\n    m = canvas.map\n    map_min_width = canvas.map_min_width\n    map_max_width = canvas.map_max_width\n    map_refresh = canvas.map_refresh\n    map_widget = canvas.map_widget\n\n    if not map_refresh:\n        width = int(map_min_width.replace(\"%\", \"\"))\n        if width &gt; 90:\n            map_min_width = \"90%\"\n\n    tools = {\n        \"map\": {\n            \"name\": \"basemap\",\n            \"tooltip\": \"Change basemap\",\n        },\n        \"search\": {\n            \"name\": \"search_xyz\",\n            \"tooltip\": \"Search XYZ tile services\",\n        },\n        \"gears\": {\n            \"name\": \"whitebox\",\n            \"tooltip\": \"WhiteboxTools for local geoprocessing\",\n        },\n        \"folder-open\": {\n            \"name\": \"vector\",\n            \"tooltip\": \"Open local vector/raster data\",\n        },\n        \"picture-o\": {\n            \"name\": \"raster\",\n            \"tooltip\": \"Open COG/STAC dataset\",\n        },\n        \"question\": {\n            \"name\": \"help\",\n            \"tooltip\": \"Get help\",\n        },\n    }\n\n    icons = list(tools.keys())\n    tooltips = [item[\"tooltip\"] for item in list(tools.values())]\n\n    icon_width = \"32px\"\n    icon_height = \"32px\"\n    n_cols = 3\n    n_rows = math.ceil(len(icons) / n_cols)\n\n    toolbar_grid = widgets.GridBox(\n        children=[\n            widgets.ToggleButton(\n                layout=widgets.Layout(\n                    width=\"auto\", height=\"auto\", padding=\"0px 0px 0px 4px\"\n                ),\n                button_style=\"primary\",\n                icon=icons[i],\n                tooltip=tooltips[i],\n            )\n            for i in range(len(icons))\n        ],\n        layout=widgets.Layout(\n            width=\"115px\",\n            grid_template_columns=(icon_width + \" \") * n_cols,\n            grid_template_rows=(icon_height + \" \") * n_rows,\n            grid_gap=\"1px 1px\",\n            padding=\"5px\",\n        ),\n    )\n    canvas.toolbar = toolbar_grid\n\n    def tool_callback(change):\n        if change[\"new\"]:\n            current_tool = change[\"owner\"]\n            for tool in toolbar_grid.children:\n                if tool is not current_tool:\n                    tool.value = False\n            tool = change[\"owner\"]\n            tool_name = tools[tool.icon][\"name\"]\n            canvas.container_widget.children = []\n\n            if tool_name == \"basemap\":\n                plotly_basemap_gui(canvas)\n            elif tool_name == \"search_xyz\":\n                plotly_search_basemaps(canvas)\n            elif tool_name == \"whitebox\":\n                plotly_whitebox_gui(canvas)\n            elif tool_name == \"vector\":\n                plotly_tool_template(canvas)\n            elif tool_name == \"raster\":\n                plotly_tool_template(canvas)\n            elif tool_name == \"help\":\n                import webbrowser\n\n                webbrowser.open_new_tab(\"https://leafmap.org\")\n                tool.value = False\n        else:\n            canvas.container_widget.children = []\n            map_widget.layout.width = map_max_width\n\n    for tool in toolbar_grid.children:\n        tool.observe(tool_callback, \"value\")\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"wrench\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n    canvas.toolbar_button = toolbar_button\n\n    layers_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Layers\",\n        icon=\"server\",\n        layout=widgets.Layout(height=\"28px\", width=\"72px\"),\n    )\n    canvas.layers_button = layers_button\n\n    toolbar_widget = widgets.VBox(layout=widgets.Layout(overflow=\"hidden\"))\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox(layout=widgets.Layout(overflow=\"hidden\"))\n    toolbar_header.children = [layers_button, toolbar_button]\n    toolbar_footer = widgets.VBox(layout=widgets.Layout(overflow=\"hidden\"))\n    toolbar_footer.children = [toolbar_grid]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n            # map_widget.layout.width = \"85%\"\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                layers_button.value = False\n                # map_widget.layout.width = map_max_width\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            map_widget.layout.width = map_min_width\n            if map_refresh:\n                with map_widget:\n                    map_widget.outputs = ()\n                    display(m)\n            layers_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            canvas.toolbar_reset()\n            map_widget.layout.width = map_max_width\n            if not layers_button.value:\n                toolbar_widget.children = [toolbar_button]\n            if map_refresh:\n                with map_widget:\n                    map_widget.outputs = ()\n                    display(m)\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def layers_btn_click(change):\n        if change[\"new\"]:\n            layer_names = list(m.get_layers().keys())\n            layers_hbox = []\n            all_layers_chk = widgets.Checkbox(\n                value=True,\n                description=\"All layers on/off\",\n                indent=False,\n                layout=widgets.Layout(height=\"18px\", padding=\"0px 8px 25px 8px\"),\n            )\n            all_layers_chk.layout.width = \"30ex\"\n            layers_hbox.append(all_layers_chk)\n\n            layer_chk_dict = {}\n\n            for name in layer_names:\n                if name in m.get_tile_layers():\n                    index = m.find_layer_index(name)\n                    layer = m.layout.mapbox.layers[index]\n                elif name in m.get_data_layers():\n                    index = m.find_layer_index(name)\n                    layer = m.data[index]\n\n                layer_chk = widgets.Checkbox(\n                    value=layer.visible,\n                    description=name,\n                    indent=False,\n                    layout=widgets.Layout(height=\"18px\"),\n                )\n                layer_chk.layout.width = \"25ex\"\n                layer_chk_dict[name] = layer_chk\n\n                if hasattr(layer, \"opacity\"):\n                    opacity = layer.opacity\n                elif hasattr(layer, \"marker\"):\n                    opacity = layer.marker.opacity\n                else:\n                    opacity = 1.0\n\n                layer_opacity = widgets.FloatSlider(\n                    value=opacity,\n                    description_tooltip=name,\n                    min=0,\n                    max=1,\n                    step=0.01,\n                    readout=False,\n                    layout=widgets.Layout(width=\"80px\"),\n                )\n\n                layer_settings = widgets.ToggleButton(\n                    icon=\"gear\",\n                    tooltip=name,\n                    layout=widgets.Layout(\n                        width=\"25px\", height=\"25px\", padding=\"0px 0px 0px 5px\"\n                    ),\n                )\n\n                def layer_chk_change(change):\n                    if change[\"new\"]:\n                        m.set_layer_visibility(change[\"owner\"].description, True)\n                    else:\n                        m.set_layer_visibility(change[\"owner\"].description, False)\n\n                layer_chk.observe(layer_chk_change, \"value\")\n\n                def layer_opacity_change(change):\n                    if change[\"new\"]:\n                        m.set_layer_opacity(\n                            change[\"owner\"].description_tooltip, change[\"new\"]\n                        )\n\n                layer_opacity.observe(layer_opacity_change, \"value\")\n\n                hbox = widgets.HBox(\n                    [layer_chk, layer_settings, layer_opacity],\n                    layout=widgets.Layout(padding=\"0px 8px 0px 8px\"),\n                )\n                layers_hbox.append(hbox)\n\n            def all_layers_chk_changed(change):\n                if change[\"new\"]:\n                    for name in layer_names:\n                        m.set_layer_visibility(name, True)\n                        layer_chk_dict[name].value = True\n                else:\n                    for name in layer_names:\n                        m.set_layer_visibility(name, False)\n                        layer_chk_dict[name].value = False\n\n            all_layers_chk.observe(all_layers_chk_changed, \"value\")\n\n            toolbar_footer.children = layers_hbox\n            toolbar_button.value = False\n        else:\n            toolbar_footer.children = [toolbar_grid]\n\n    layers_button.observe(layers_btn_click, \"value\")\n\n    return toolbar_widget\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.plotly_whitebox_gui","title":"<code>plotly_whitebox_gui(canvas)</code>","text":"<p>Display a GUI for the whitebox tool.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>plotlymap.Canvas</code> <p>Map canvas.</p> required Source code in <code>beamgis/toolbar.py</code> <pre><code>def plotly_whitebox_gui(canvas):\n    \"\"\"Display a GUI for the whitebox tool.\n\n    Args:\n        canvas (plotlymap.Canvas): Map canvas.\n    \"\"\"\n    import whiteboxgui.whiteboxgui as wbt\n\n    container_widget = canvas.container_widget\n    map_widget = canvas.map_widget\n    map_width = \"25%\"\n    map_widget.layout.width = map_width\n\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    # style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"gears\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    tools_dict = wbt.get_wbt_dict()\n    wbt_toolbox = wbt.build_toolbox(\n        tools_dict,\n        max_width=\"800px\",\n        max_height=\"500px\",\n        sandbox_path=os.getcwd(),\n    )\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        wbt_toolbox,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n            map_widget.layout.width = map_width\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n                map_widget.layout.width = canvas.map_max_width\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n            map_widget.layout.width = map_width\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n            map_widget.layout.width = canvas.map_max_width\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            canvas.toolbar_reset()\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    toolbar_button.value = True\n    container_widget.children = [toolbar_widget]\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.save_map","title":"<code>save_map(m)</code>","text":"<p>Saves the map as HTML, JPG, or PNG.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leafmap Map object.</p> required Source code in <code>beamgis/toolbar.py</code> <pre><code>def save_map(m):\n    \"\"\"Saves the map as HTML, JPG, or PNG.\n\n    Args:\n        m (leafmap.Map): The leafmap Map object.\n    \"\"\"\n    import time\n\n    tool_output = widgets.Output()\n    m.tool_output = tool_output\n    tool_output.outputs = ()\n    save_map_widget = widgets.VBox()\n\n    save_type = widgets.ToggleButtons(\n        options=[\"HTML\", \"PNG\", \"JPG\"],\n        tooltips=[\n            \"Save the map as an HTML file\",\n            \"Take a screenshot and save as a PNG file\",\n            \"Take a screenshot and save as a JPG file\",\n        ],\n    )\n\n    file_chooser = FileChooser(\n        os.getcwd(), sandbox_path=m.sandbox_path, layout=widgets.Layout(width=\"454px\")\n    )\n    file_chooser.default_filename = \"my_map.html\"\n    file_chooser.use_dir_icons = True\n\n    ok_cancel = widgets.ToggleButtons(\n        value=None,\n        options=[\"OK\", \"Cancel\", \"Close\"],\n        tooltips=[\"OK\", \"Cancel\", \"Close\"],\n        button_style=\"primary\",\n    )\n\n    def save_type_changed(change):\n        ok_cancel.value = None\n        # file_chooser.reset()\n        file_chooser.default_path = os.getcwd()\n        if change[\"new\"] == \"HTML\":\n            file_chooser.default_filename = \"my_map.html\"\n        elif change[\"new\"] == \"PNG\":\n            file_chooser.default_filename = \"my_map.png\"\n        elif change[\"new\"] == \"JPG\":\n            file_chooser.default_filename = \"my_map.jpg\"\n        save_map_widget.children = [save_type, file_chooser]\n\n    def chooser_callback(chooser):\n        save_map_widget.children = [save_type, file_chooser, ok_cancel]\n\n    def ok_cancel_clicked(change):\n        if change[\"new\"] == \"OK\":\n            file_path = file_chooser.selected\n            ext = os.path.splitext(file_path)[1]\n            if save_type.value == \"HTML\" and ext.upper() == \".HTML\":\n                tool_output.outputs = ()\n                m.to_html(file_path)\n            elif save_type.value == \"PNG\" and ext.upper() == \".PNG\":\n                tool_output.outputs = ()\n                m.toolbar_button.value = False\n                if m.save_map_control is not None:\n                    m.remove_control(m.save_map_control)\n                    m.save_map_control = None\n                time.sleep(2)\n                screen_capture(outfile=file_path)\n            elif save_type.value == \"JPG\" and ext.upper() == \".JPG\":\n                tool_output.outputs = ()\n                m.toolbar_button.value = False\n                if m.save_map_control is not None:\n                    m.remove_control(m.save_map_control)\n                    m.save_map_control = None\n                time.sleep(2)\n                screen_capture(outfile=file_path)\n            else:\n                label = widgets.Label(\n                    value=\"The selected file extension does not match the selected exporting type.\"\n                )\n                save_map_widget.children = [save_type, file_chooser, label]\n        elif change[\"new\"] == \"Cancel\":\n            tool_output.outputs = ()\n            file_chooser.reset()\n        elif change[\"new\"] == \"Close\":\n            if m.save_map_control is not None:\n                m.remove_control(m.save_map_control)\n                m.save_map_control = None\n        ok_cancel.value = None\n        m.toolbar_reset()\n\n    save_type.observe(save_type_changed, names=\"value\")\n    ok_cancel.observe(ok_cancel_clicked, names=\"value\")\n\n    file_chooser.register_callback(chooser_callback)\n\n    save_map_widget.children = [save_type, file_chooser]\n    save_map_control = ipyleaflet.WidgetControl(\n        widget=save_map_widget, position=\"topright\"\n    )\n    m.add(save_map_control)\n    m.save_map_control = save_map_control\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.search_basemaps","title":"<code>search_basemaps(m)</code>","text":"<p>The widget for search XYZ tile services.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>beamgis/toolbar.py</code> <pre><code>def search_basemaps(m):\n    \"\"\"The widget for search XYZ tile services.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import xyzservices.providers as xyz\n    from xyzservices import TileProvider\n\n    layers = m.layers\n\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"search\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    checkbox = widgets.Checkbox(\n        description=\"Search Quick Map Services (QMS)\",\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=widget_width),\n    )\n\n    providers = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"XYZ Tile:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    keyword = widgets.Text(\n        value=\"\",\n        description=\"Search keyword:\",\n        placeholder=\"OpenStreetMap\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    def search_callback(change):\n        providers.options = []\n        if keyword.value != \"\":\n            tiles = search_xyz_services(keyword=keyword.value)\n            if checkbox.value:\n                tiles = tiles + search_qms(keyword=keyword.value)\n            providers.options = tiles\n\n    keyword.on_submit(search_callback)\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Search\", \"Reset\", \"Close\"],\n        tooltips=[\"Search\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    def providers_change(change):\n        if change[\"new\"] != \"\":\n            provider = change[\"new\"]\n            if provider is not None:\n                if provider.startswith(\"qms\"):\n                    with output:\n                        output.outputs = ()\n                        print(\"Adding data. Please wait...\")\n                    name = provider[4:]\n                    qms_provider = TileProvider.from_qms(name)\n                    url = qms_provider.build_url()\n                    attribution = qms_provider.attribution\n                    m.layers = layers\n                    m.add_tile_layer(url, name, attribution)\n                    output.outputs = ()\n                elif provider.startswith(\"xyz\"):\n                    name = provider[4:]\n                    xyz_provider = xyz.flatten()[name]\n                    url = xyz_provider.build_url()\n                    attribution = xyz_provider.attribution\n                    m.layers = layers\n                    if xyz_provider.requires_token():\n                        with output:\n                            output.outputs = ()\n                            print(f\"{provider} requires an API Key.\")\n                    m.add_tile_layer(url, name, attribution)\n\n    providers.observe(providers_change, \"value\")\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        checkbox,\n        keyword,\n        providers,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Search\":\n            providers.options = []\n            if keyword.value != \"\":\n                tiles = search_xyz_services(keyword=keyword.value)\n                if checkbox.value:\n                    tiles = tiles + search_qms(keyword=keyword.value)\n                providers.options = tiles\n            with output:\n                output.outputs = ()\n                # print(\"Running ...\")\n        elif change[\"new\"] == \"Reset\":\n            keyword.value = \"\"\n            providers.options = []\n            output.outputs = ()\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = True\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.search_geojson_gui","title":"<code>search_geojson_gui(m)</code>","text":"<p>Generates a tool GUI template using ipywidgets.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>beamgis/toolbar.py</code> <pre><code>def search_geojson_gui(m):\n    \"\"\"Generates a tool GUI template using ipywidgets.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    if len(m.geojson_layers) &gt; 0:\n        geojson_layer_group = ipyleaflet.LayerGroup()\n        for geojson_layer in m.geojson_layers:\n            geojson_layer_group.add(geojson_layer)\n        if not hasattr(m, \"geojson_layer_group\"):\n            setattr(m, \"geojson_layer_group\", geojson_layer_group)\n        else:\n            m.geojson_layer_group = geojson_layer_group\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"search-plus\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    layer_options = []\n    if len(m.geojson_layers) &gt; 0:\n        layer_options = [layer.name for layer in m.geojson_layers]\n\n    layers = widgets.Dropdown(\n        options=layer_options,\n        value=None,\n        description=\"Layer:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    attributes = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Attribute:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    if len(m.geojson_layers) == 0:\n        with output:\n            print(\"Please add vector data layers to the map before using this tool.\")\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        layers,\n        attributes,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def layer_change(change):\n        if change[\"new\"]:\n            for layer in m.geojson_layers:\n                if layer.name == change[\"new\"]:\n                    df = geojson_to_df(layer.data)\n                    attributes.options = list(df.columns)\n\n    layers.observe(layer_change, names=\"value\")\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n                if len(m.geojson_layers) &gt; 0 and m.search_control is not None:\n                    m.search_control.marker.visible = False\n                    m.remove_control(m.search_control)\n                    m.search_control = None\n                    m.geojson_layer_group.clear_layers()\n                    delattr(m, \"geojson_layer_group\")\n\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            if len(m.geojson_layers) &gt; 0 and attributes.value is not None:\n                if m.search_control is None:\n                    geojson_control = ipyleaflet.SearchControl(\n                        position=\"topleft\",\n                        layer=m.geojson_layer_group,\n                        property_name=attributes.value,\n                        marker=ipyleaflet.Marker(\n                            icon=ipyleaflet.AwesomeIcon(\n                                name=\"check\", marker_color=\"green\", icon_color=\"darkred\"\n                            )\n                        ),\n                    )\n                    m.add(geojson_control)\n                    m.search_control = geojson_control\n                else:\n                    m.search_control.property_name = attributes.value\n            with output:\n                output.outputs = ()\n        elif change[\"new\"] == \"Reset\":\n            output.outputs = ()\n            layers.value = None\n            attributes.value = None\n\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n                if len(m.geojson_layers) &gt; 0 and m.search_control is not None:\n                    m.search_control.marker.visible = False\n                    m.remove_control(m.search_control)\n                    m.search_control = None\n                    if hasattr(m, \"geojson_layer_group\"):\n                        m.geojson_layer_group.clear_layers()\n                        delattr(m, \"geojson_layer_group\")\n\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = True\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.select_table_gui","title":"<code>select_table_gui(m=None)</code>","text":"<p>GUI for selecting layers to display attribute table.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>beamgis/toolbar.py</code> <pre><code>def select_table_gui(m=None):\n    \"\"\"GUI for selecting layers to display attribute table.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import ipysheet\n\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"table\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    layer_options = []\n    if len(m.geojson_layers) &gt; 0:\n        layer_options = [layer.name for layer in m.geojson_layers]\n\n    layers = widgets.Dropdown(\n        options=layer_options,\n        value=None,\n        description=\"Layer:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    if len(m.geojson_layers) == 0:\n        with output:\n            print(\"Please add vector data layers to the map before using this tool.\")\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        layers,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            if len(m.geojson_layers) &gt; 0 and layers.value is not None:\n                if hasattr(m, \"table_control\"):\n                    m.remove_control(m.table_control)\n                lyr_index = layers.options.index(layers.value)\n                data = m.geojson_layers[lyr_index].data\n                df = geojson_to_df(data)\n                show_table_gui(m, df)\n        elif change[\"new\"] == \"Reset\":\n            output.outputs = ()\n            layers.value = None\n\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = True\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.show_table_gui","title":"<code>show_table_gui(m, df)</code>","text":"<p>Open the attribute table GUI.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>beamgis/toolbar.py</code> <pre><code>def show_table_gui(m, df):\n    \"\"\"Open the attribute table GUI.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import ipysheet\n\n    widget_width = \"560px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    # style = {\"description_width\": \"initial\"}\n\n    sheet = ipysheet.from_dataframe(df.head(10))\n\n    output = widgets.Output(\n        layout=widgets.Layout(\n            width=widget_width,\n            padding=padding,\n        )\n    )\n\n    checkbox = widgets.Checkbox(\n        description=\"Show all rows\",\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=\"115px\"),\n    )\n\n    sheet.layout.width = output.layout.width\n\n    def checkbox_clicked(change):\n        output.outputs = ()\n\n        if change[\"new\"]:\n            sheet = ipysheet.from_dataframe(df)\n        else:\n            sheet = ipysheet.from_dataframe(df.head(10))\n\n        sheet.layout.max_width = output.layout.width\n        output.layout.max_height = str(int(m.layout.height[:-2]) - 220) + \"px\"\n        sheet.layout.max_height = output.layout.height\n        if sheet.layout.height &gt; output.layout.max_height:\n            sheet.layout.height = output.layout.max_height\n        with output:\n            display(sheet)\n\n    checkbox.observe(checkbox_clicked, \"value\")\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Minimize window\",\n        icon=\"window-minimize\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    toolbar_widget = widgets.VBox()\n    m.table_widget = toolbar_widget\n    m.table_output = output\n\n    reset_btn = widgets.Button(\n        tooltip=\"Reset the plot\",\n        icon=\"home\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 0px\"),\n    )\n\n    def reset_btn_clicked(b):\n        output.layout.width = widget_width\n        output.layout.max_height = str(int(m.layout.height[:-2]) - 220) + \"px\"\n\n    reset_btn.on_click(reset_btn_clicked)\n\n    fullscreen_btn = widgets.Button(\n        tooltip=\"Fullscreen the attribute table\",\n        icon=\"arrows-alt\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 0px\"),\n    )\n\n    def fullscreen_btn_clicked(b):\n        output.layout.width = \"1000px\"\n        output.layout.max_height = str(int(m.layout.height[:-2]) - 220) + \"px\"\n\n        sheet.layout.width = output.layout.width\n        with output:\n            output.outputs = ()\n            display(sheet)\n\n    fullscreen_btn.on_click(fullscreen_btn_clicked)\n\n    width_btn = widgets.Button(\n        tooltip=\"Change table width\",\n        icon=\"arrows-h\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 0px\"),\n    )\n\n    height_btn = widgets.Button(\n        tooltip=\"Change table height\",\n        icon=\"arrows-v\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 0px\"),\n    )\n\n    width_slider = widgets.IntSlider(\n        value=560,\n        min=550,\n        max=1500,\n        step=10,\n        description=\"\",\n        readout=False,\n        continuous_update=False,\n        layout=widgets.Layout(width=\"100px\", padding=padding),\n        style={\"description_width\": \"initial\"},\n    )\n\n    width_slider_label = widgets.Label(\n        value=\"560\", layout=widgets.Layout(padding=\"0px 10px 0px 0px\")\n    )\n    # widgets.jslink((width_slider, \"value\"), (width_slider_label, \"value\"))\n\n    def width_changed(change):\n        if change[\"new\"]:\n            width_slider_label.value = str(width_slider.value)\n            output.layout.width = str(width_slider.value) + \"px\"\n\n            if checkbox.value:\n                sheet = ipysheet.from_dataframe(df)\n            else:\n                sheet = ipysheet.from_dataframe(df.head(10))\n            sheet.layout.width = output.layout.width\n            with output:\n                output.outputs = ()\n                display(sheet)\n\n    width_slider.observe(width_changed, \"value\")\n\n    height_slider = widgets.IntSlider(\n        value=250,\n        min=200,\n        max=1000,\n        step=10,\n        description=\"\",\n        readout=False,\n        continuous_update=False,\n        layout=widgets.Layout(width=\"100px\", padding=padding),\n        style={\"description_width\": \"initial\"},\n    )\n\n    height_slider_label = widgets.Label(value=\"250\")\n    # widgets.jslink((height_slider, \"value\"), (height_slider_label, \"value\"))\n\n    def height_changed(change):\n        if change[\"new\"]:\n            height_slider_label.value = str(height_slider.value)\n            output.layout.max_height = str(height_slider.value) + \"px\"\n            if checkbox.value:\n                sheet = ipysheet.from_dataframe(df)\n            else:\n                sheet = ipysheet.from_dataframe(df.head(10))\n\n            sheet.layout.height = output.layout.max_height\n            with output:\n                output.outputs = ()\n                display(sheet)\n\n    height_slider.observe(height_changed, \"value\")\n\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [\n        close_button,\n        toolbar_button,\n        reset_btn,\n        fullscreen_btn,\n        width_btn,\n        width_slider,\n        width_slider_label,\n        height_btn,\n        height_slider,\n        height_slider_label,\n        checkbox,\n    ]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n            toolbar_button.icon = \"window-minimize\"\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n                toolbar_button.icon = \"window-maximize\"\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n            toolbar_button.icon = \"window-minimize\"\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.icon = \"window-maximize\"\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.table_control is not None and m.table_control in m.controls:\n                    m.remove_control(m.table_control)\n                    m.table_control = None\n                    delattr(m, \"table_control\")\n\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    with output:\n        display(sheet)\n\n    toolbar_button.value = True\n    if m is not None:\n        table_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if table_control not in m.controls:\n            m.add(table_control)\n            m.table_control = table_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.split_basemaps","title":"<code>split_basemaps(m, layers_dict=None, left_name=None, right_name=None, width='120px', **kwargs)</code>","text":"<p>Create a split-panel map for visualizing two maps.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>ipyleaflet.Map</code> <p>An ipyleaflet map object.</p> required <code>layers_dict</code> <code>dict</code> <p>A dictionary of TileLayers. Defaults to None.</p> <code>None</code> <code>left_name</code> <code>str</code> <p>The default value of the left dropdown list. Defaults to None.</p> <code>None</code> <code>right_name</code> <code>str</code> <p>The default value of the right dropdown list. Defaults to None.</p> <code>None</code> <code>width</code> <code>str</code> <p>The width of the dropdown list. Defaults to \"120px\".</p> <code>'120px'</code> Source code in <code>beamgis/toolbar.py</code> <pre><code>def split_basemaps(\n    m,\n    layers_dict: Optional[Dict] = None,\n    left_name=None,\n    right_name=None,\n    width=\"120px\",\n    **kwargs,\n):\n    \"\"\"Create a split-panel map for visualizing two maps.\n\n    Args:\n        m (ipyleaflet.Map): An ipyleaflet map object.\n        layers_dict (dict, optional): A dictionary of TileLayers. Defaults to None.\n        left_name (str, optional): The default value of the left dropdown list. Defaults to None.\n        right_name (str, optional): The default value of the right dropdown list. Defaults to None.\n        width (str, optional): The width of the dropdown list. Defaults to \"120px\".\n    \"\"\"\n    from .basemaps import wms_tiles\n    from .leafmap import basemaps, get_basemap\n\n    controls = m.controls\n    layers = m.layers\n    m.clear_controls()\n\n    add_zoom = True\n    add_fullscreen = True\n\n    if layers_dict is None:\n        keys = []\n        tmp_keys = list(basemaps.keys())\n        for key in tmp_keys:\n            if key not in wms_tiles:\n                keys.append(key)\n    else:\n        keys = list(layers_dict.keys())\n\n    if layers_dict is None:\n        if left_name is None:\n            left_name = \"ROADMAP\"\n        if right_name is None:\n            right_name = \"HYBRID\"\n    else:\n        if left_name is None:\n            left_name = keys[0]\n        if right_name is None:\n            right_name = keys[-1]\n\n    if layers_dict is None:\n        if isinstance(left_name, str):\n            left_layer = get_basemap(left_name)\n\n        if isinstance(right_name, str):\n            right_layer = get_basemap(right_name)\n    else:\n        left_layer = layers_dict[left_name]\n        right_layer = layers_dict[right_name]\n\n    control = ipyleaflet.SplitMapControl(left_layer=left_layer, right_layer=right_layer)\n    m.add(control)\n    m.dragging = False\n\n    left_dropdown = widgets.Dropdown(\n        options=keys, value=left_name, layout=widgets.Layout(width=width)\n    )\n\n    left_control = ipyleaflet.WidgetControl(widget=left_dropdown, position=\"topleft\")\n    m.add(left_control)\n\n    right_dropdown = widgets.Dropdown(\n        options=keys, value=right_name, layout=widgets.Layout(width=width)\n    )\n\n    right_control = ipyleaflet.WidgetControl(widget=right_dropdown, position=\"topright\")\n    m.add(right_control)\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        # button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            m.controls = controls\n            m.clear_layers()\n            m.layers = layers\n\n    close_button.observe(close_btn_click, \"value\")\n    close_control = ipyleaflet.WidgetControl(\n        widget=close_button, position=\"bottomright\"\n    )\n    m.add(close_control)\n\n    if add_zoom:\n        m.add(ipyleaflet.ZoomControl())\n    if add_fullscreen:\n        m.add(ipyleaflet.FullScreenControl())\n    m.add(ipyleaflet.ScaleControl(position=\"bottomleft\"))\n\n    split_control = None\n    for ctrl in m.controls:\n        if isinstance(ctrl, ipyleaflet.SplitMapControl):\n            split_control = ctrl\n            break\n\n    def left_change(change):\n        if layers_dict is None:\n            split_control.left_layer.url = get_basemap(left_dropdown.value).url\n        else:\n            split_control.left_layer.url = layers_dict[left_dropdown.value].url\n\n    left_dropdown.observe(left_change, \"value\")\n\n    def right_change(change):\n        if layers_dict is None:\n            split_control.right_layer.url = get_basemap(right_dropdown.value).url\n        else:\n            split_control.right_layer.url = layers_dict[right_dropdown.value].url\n\n    right_dropdown.observe(right_change, \"value\")\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.stac_custom_gui","title":"<code>stac_custom_gui(m, button_width='85px', **kwargs)</code>","text":"<p>Generates a tool GUI template using ipywidgets.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <code>button_width</code> <code>str</code> <p>The button width. Defaults to \"85px\".</p> <code>'85px'</code> <code>**kwargs</code> <p>Additional keyword arguments that will be passed to the pystac Client.open() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>beamgis/toolbar.py</code> <pre><code>def stac_custom_gui(m, button_width: Optional[str] = \"85px\", **kwargs):\n    \"\"\"Generates a tool GUI template using ipywidgets.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n        button_width (str, optional): The button width. Defaults to \"85px\".\n        **kwargs: Additional keyword arguments that will be passed to the pystac Client.open() function.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n\n    if hasattr(m, \"_STAC_CATALOGS\") and isinstance(m._STAC_CATALOGS, dict):\n        catalogs = m._STAC_CATALOGS\n    else:\n        raise ValueError(\"Please set the STAC catalogs first.\")\n\n    if not hasattr(m, \"_STAC_COLLECTIONS\"):\n        m._STAC_COLLECTIONS = {}\n\n    if len(catalogs) == 0:\n        raise ValueError(\"Please set the STAC catalogs first.\")\n\n    catalog_ids = list(catalogs.keys())\n\n    widget_width = \"450px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n    MAX_ITEMS = 20\n    if \"MAX_ITEMS\" in os.environ:\n        MAX_ITEMS = int(os.environ[\"MAX_ITEMS\"])\n\n    stac_data = []\n\n    output = widgets.Output(\n        layout=widgets.Layout(width=widget_width, padding=padding, overflow=\"auto\")\n    )\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Discver STAC Catalog\",\n        icon=\"stack-exchange\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    catalog = widgets.Dropdown(\n        options=catalog_ids,\n        value=catalog_ids[0],\n        description=\"Catalog:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    endpoint = widgets.Text(\n        value=catalogs[catalog.value],\n        description=\"URL:\",\n        tooltip=\"STAC Catalog URL\",\n        placeholder=\"Enter a STAC URL, e.g., https://earth-search.aws.element84.com/v1\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    collection = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Collection:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    start_date = widgets.DatePicker(\n        description=\"Start date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=\"225px\", padding=padding),\n    )\n    end_date = widgets.DatePicker(\n        description=\"End date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=\"225px\", padding=padding),\n    )\n\n    band_names = []\n\n    item = widgets.Dropdown(\n        options=[],\n        description=\"Item:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    vis_option = widgets.Dropdown(\n        options=[\"1 band (Grayscale)\", \"3 bands (RGB)\"],\n        value=\"3 bands (RGB)\",\n        description=\"Visualization:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    layer_name = widgets.Text(\n        value=\"STAC Layer\",\n        description=\"Layer name:\",\n        tooltip=\"Enter a layer name for the selected file\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    band_width = \"149px\"\n    red = widgets.Dropdown(\n        options=band_names,\n        value=None,\n        description=\"Red:\",\n        tooltip=\"Select a band for the red channel\",\n        style=style,\n        layout=widgets.Layout(width=band_width, padding=padding),\n    )\n\n    green = widgets.Dropdown(\n        options=band_names,\n        value=None,\n        description=\"Green:\",\n        tooltip=\"Select a band for the green channel\",\n        style=style,\n        layout=widgets.Layout(width=\"148px\", padding=padding),\n    )\n\n    blue = widgets.Dropdown(\n        options=band_names,\n        value=None,\n        description=\"Blue:\",\n        tooltip=\"Select a band for the blue channel\",\n        style=style,\n        layout=widgets.Layout(width=band_width, padding=padding),\n    )\n\n    gray_band = widgets.Dropdown(\n        options=band_names,\n        value=None,\n        description=\"Band:\",\n        tooltip=\"Select a band for visualization\",\n        style=style,\n        layout=widgets.Layout(width=\"227px\", padding=padding),\n    )\n\n    palette_options = list_palettes(lowercase=True)\n    palette = widgets.Dropdown(\n        options=palette_options,\n        value=None,\n        description=\"Palette:\",\n        layout=widgets.Layout(width=\"223px\", padding=padding),\n        style=style,\n    )\n\n    band_box = widgets.HBox([red, green, blue])\n\n    def vis_option_changed(change):\n        if change[\"new\"] == \"1 band (Grayscale)\":\n            band_box.children = [gray_band, palette]\n        else:\n            band_box.children = [red, green, blue]\n\n    vis_option.observe(vis_option_changed, names=\"value\")\n\n    max_items = widgets.Text(\n        value=\"20\",\n        description=\"Max items:\",\n        placeholder=\"Maximum number of items to return from the STAC API\",\n        tooltip=\"Maximum number of items to return from the STAC API\",\n        style=style,\n        layout=widgets.Layout(width=\"130px\", padding=padding),\n    )\n\n    vmin = widgets.Text(\n        value=None,\n        description=\"vmin:\",\n        tooltip=\"Minimum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"100px\", padding=padding),\n    )\n\n    vmax = widgets.Text(\n        value=None,\n        description=\"vmax:\",\n        tooltip=\"Maximum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"100px\", padding=padding),\n    )\n\n    nodata = widgets.Text(\n        value=None,\n        description=\"Nodata:\",\n        tooltip=\"Nodata the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"113px\", padding=padding),\n    )\n\n    more_label = widgets.Label(\n        \"More options:\",\n        layout=widgets.Layout(width=\"100px\", padding=padding),\n        style=style,\n    )\n\n    add_footprints = widgets.Checkbox(\n        value=True,\n        description=\"Add image footprints\",\n        indent=False,\n        layout=widgets.Layout(width=\"170px\", padding=padding),\n        style=style,\n    )\n\n    checkbox = widgets.Checkbox(\n        value=False,\n        description=\"Additional params\",\n        indent=False,\n        layout=widgets.Layout(width=\"154px\", padding=padding),\n        style=style,\n    )\n\n    query_params_text = \"Additional parameters to query the STAC API, for example: {'query': {'eo:cloud_cover':{'lt':10}}}\"\n    query_params = widgets.Textarea(\n        value=\"\",\n        placeholder=query_params_text,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n        style=style,\n    )\n\n    add_params_text = \"Additional parameters to visualize imagery, for example: {'palette': ['#006633', '#E5FFCC', '#662A00', '#D8D8D8', '#F5F5F5'], 'expression': '(SR_B5-SR_B4)/(SR_B5+SR_B4)'}\"\n    add_params = widgets.Textarea(\n        value=\"\",\n        placeholder=add_params_text,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n        style=style,\n    )\n\n    def reset_options():\n        \"\"\"Reset the options to their default values.\"\"\"\n        catalog.value = catalog_ids[0]\n        collection.options = []\n        collection.value = None\n        endpoint.value = catalogs[catalog.value]\n        start_date.value = None\n        end_date.value = None\n        item.options = []\n        item.value = None\n        layer_name.value = \"\"\n        max_items.value = \"20\"\n        vmin.value = \"\"\n        vmax.value = \"\"\n        nodata.value = \"\"\n        palette.value = None\n        add_params.value = \"\"\n        reset_bands()\n        vis_option.value = \"3 bands (RGB)\"\n        output.outputs = ()\n\n    params_widget = widgets.VBox()\n\n    more_options = widgets.VBox()\n    more_options.children = [\n        widgets.HBox([more_label, add_footprints, checkbox]),\n        params_widget,\n    ]\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Collections\", \"Items\", \"Display\", \"Reset\", \"Close\"],\n        tooltips=[\"Get Collections\", \"Get Items\", \"Display Image\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = button_width\n\n    dataset_widget = widgets.VBox()\n\n    dataset_widget.children = [endpoint, collection]\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        catalog,\n        dataset_widget,\n        widgets.HBox([start_date, end_date]),\n        item,\n        vis_option,\n        band_box,\n        more_options,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def update_bands():\n        excluded = [\n            \"index\",\n            \"metadata\",\n            \"mtl.json\",\n            \"mtl.txt\",\n            \"mtl.xml\",\n            \"qa\",\n            \"qa-browse\",\n            \"QA\",\n            \"rendered_preview\",\n            \"tilejson\",\n            \"tir-browse\",\n            \"vnir-browse\",\n            \"xml\",\n            \"documentation\",\n        ]\n\n        if len(stac_data) &gt; 0:\n            bnames = stac_data[0][item.value][\"bands\"]\n        else:\n            bnames = []\n\n        bnames = [b for b in bnames if b not in excluded]\n\n        red.options = bnames\n        green.options = bnames\n        blue.options = bnames\n\n        if len(bnames) &gt;= 3:\n            vis_option.value = \"3 bands (RGB)\"\n            palette.value = None\n            gray_band.options = bnames\n\n            default_bands = set_default_bands(bnames)\n            try:\n                red.value = default_bands[0]\n                green.value = default_bands[1]\n                blue.value = default_bands[2]\n            except Exception as e:\n                red.value = None\n                green.value = None\n                blue.value = None\n        elif len(bnames) &gt;= 1:\n            vis_option.value = \"1 band (Grayscale)\"\n            gray_band.options = bnames\n            gray_band.value = bnames[0]\n            red.value = bnames[0]\n            green.value = bnames[0]\n            blue.value = bnames[0]\n\n    def reset_bands():\n        red.options = []\n        green.options = []\n        blue.options = []\n        gray_band.options = []\n        red.value = None\n        green.value = None\n        blue.value = None\n        gray_band.value = None\n\n    def catalog_changed(change):\n        if change[\"new\"]:\n            endpoint.value = catalogs[catalog.value]\n            collection.options = []\n            collection.value = None\n            item.options = []\n            item.value = None\n            if catalog.value in m._STAC_COLLECTIONS:\n                collection.options = m._STAC_COLLECTIONS[catalog.value]\n                collection.value = m._STAC_COLLECTIONS[catalog.value][0]\n            reset_bands()\n\n    catalog.observe(catalog_changed, names=\"value\")\n\n    def endpoint_changed(change):\n        with output:\n            output.outputs = ()\n            output.clear_output()\n            print(\"Retrieving collections...\")\n            try:\n                if endpoint.value is not None:\n                    collection.options = []\n                    collection.value = None\n\n                    collections = stac_collections(\n                        endpoint.value, return_ids=True, get_root=False, **kwargs\n                    )\n                    if collections:\n                        collections.sort()\n                        collection.options = collections\n                        collection.value = collections[0]\n                        output.clear_output()\n                        output.outputs = ()\n                    else:\n                        print(\"No collections found.\")\n                else:\n                    print(\"No URL provided.\")\n                reset_bands()\n\n            except Exception as e:\n                print(e)\n\n    endpoint.on_submit(endpoint_changed)\n\n    def collection_changed(change):\n        if change[\"new\"]:\n            reset_bands()\n            item.options = []\n            item.value = None\n\n    collection.observe(collection_changed, names=\"value\")\n\n    def item_changed(change):\n        if change[\"new\"]:\n            layer_name.value = item.value\n\n    item.observe(item_changed, names=\"value\")\n\n    def checkbox_changed(change):\n        if change[\"new\"]:\n            params_widget.children = [\n                layer_name,\n                widgets.HBox([max_items, vmin, vmax, nodata]),\n                query_params,\n                add_params,\n            ]\n        else:\n            params_widget.children = []\n\n    checkbox.observe(checkbox_changed, names=\"value\")\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Collections\":\n            collection.options = []\n            with output:\n                output.outputs = ()\n                print(\"Retrieving collections...\")\n                try:\n                    if endpoint.value is not None:\n                        if (\n                            endpoint.value == catalogs[catalog.value]\n                            and catalog.value in m._STAC_COLLECTIONS\n                        ):\n                            collections = m._STAC_COLLECTIONS[catalog.value]\n                        else:\n                            collections = stac_collections(\n                                endpoint.value, return_ids=True, **kwargs\n                            )\n\n                        if collections:\n                            collections.sort()\n                            collection.options = collections\n                            collection.value = collections[0]\n\n                            m._STAC_COLLECTIONS[catalog.value] = collections\n                            output.clear_output()\n                            output.outputs = ()\n                        else:\n                            print(\"No collections found.\")\n                    else:\n                        print(\"No URL provided.\")\n                except Exception as e:\n                    print(e)\n\n        elif change[\"new\"] == \"Items\":\n            with output:\n                output.outputs = ()\n                if endpoint.value is not None:\n                    if start_date.value is not None and end_date.value is not None:\n                        datetime = str(start_date.value) + \"/\" + str(end_date.value)\n                    elif start_date.value is not None:\n                        datetime = str(start_date.value) + \"/..\"\n                    elif end_date.value is not None:\n                        datetime = \"../\" + str(end_date.value)\n                    else:\n                        datetime = None\n\n                    if m is not None:\n                        if m.user_roi is not None:\n                            intersects = m.user_roi[\"geometry\"]\n                        else:\n                            intersects = bbox_to_geojson(m.bounds)\n\n                    else:\n                        intersects = None\n\n                    if (\n                        checkbox.value\n                        and query_params.value.strip().startswith(\"{\")\n                        and query_params.value.strip().endswith(\"}\")\n                    ):\n                        query = eval(query_params.value)\n                    elif query_params.value.strip() == \"\":\n                        query = {}\n                    else:\n                        print(\n                            \"Invalid query parameters. It must be a dictionary with keys such as 'query', 'sortby', 'filter', 'fields'\"\n                        )\n                        query = {}\n\n                print(\"Retrieving items...\")\n                try:\n                    if collection.value is None:\n                        output.outputs = ()\n                        print(\"Please click on 'Collections' to retrieve collections.\")\n                    else:\n                        item.options = []\n                        item.value = None\n                        reset_bands()\n                        search = stac_search(\n                            url=endpoint.value,\n                            collections=[collection.value],\n                            max_items=int(max_items.value),\n                            intersects=intersects,\n                            datetime=datetime,\n                            **query,\n                            **kwargs,\n                        )\n                        search_dict = stac_search_to_dict(search)\n                        item.options = list(search_dict.keys())\n                        item.value = list(search_dict.keys())[0]\n                        setattr(m, \"stac_search\", search)\n                        setattr(m, \"stac_dict\", search_dict)\n                        setattr(m, \"stac_items\", stac_search_to_list(search))\n\n                        if add_footprints.value and m is not None:\n                            gdf = stac_search_to_gdf(search)\n                            style = {\n                                \"stroke\": True,\n                                \"color\": \"#3388ff\",\n                                \"weight\": 2,\n                                \"opacity\": 1,\n                                \"fill\": True,\n                                \"fillColor\": \"#000000\",\n                                \"fillOpacity\": 0,\n                            }\n                            hover_style = {\"weight\": 4}\n                            m.add_gdf(\n                                gdf,\n                                style=style,\n                                hover_style=hover_style,\n                                layer_name=\"Footprints\",\n                                zoom_to_layer=False,\n                                info_mode=\"on_click\",\n                            )\n                            setattr(m, \"stac_gdf\", gdf)\n\n                        stac_data.clear()\n                        stac_data.append(search_dict)\n                        update_bands()\n                        output.clear_output()\n                        output.outputs = ()\n                except NotImplementedError as e:\n                    print(e)\n\n                except Exception as e:\n                    print(e)\n\n        elif change[\"new\"] == \"Display\":\n            with output:\n                output.outputs = ()\n\n                if item.value and m is not None:\n                    print(\"Loading data...\")\n\n                    if (\n                        checkbox.value\n                        and add_params.value.strip().startswith(\"{\")\n                        and add_params.value.strip().endswith(\"}\")\n                    ):\n                        vis_params = eval(add_params.value)\n                    else:\n                        vis_params = {}\n\n                    if (\n                        vis_option.value == \"1 band (Grayscale)\"\n                        and (palette.value is not None)\n                    ) or (palette.value and \"expression\" in vis_params):\n                        vis_params[\"colormap_name\"] = palette.value\n                    elif (\n                        palette.value\n                        and len(set([red.value, green.value, blue.value])) &gt; 1\n                        and \"expression\" not in vis_params\n                    ):\n                        palette.value = None\n                        print(\"Palette can only be set for single band images.\")\n\n                    if vmax.value and not vmin.value:\n                        vmin.value = \"0\"\n\n                    if vmin.value and vmax.value:\n                        vis_params[\"rescale\"] = f\"{vmin.value},{vmax.value}\"\n\n                    if nodata.value:\n                        vis_params[\"nodata\"] = nodata.value\n\n                    if vis_option.value == \"1 band (Grayscale)\":\n                        assets = gray_band.value\n                    else:\n                        assets = f\"{red.value},{green.value},{blue.value}\"\n\n                    try:\n                        if \"Planetary Computer\" in catalog.value:\n                            output.outputs = ()\n                            m.add_stac_layer(\n                                collection=collection.value,\n                                item=item.value,\n                                assets=assets,\n                                name=layer_name.value,\n                                fit_bounds=False,\n                                **vis_params,\n                            )\n                            setattr(\n                                m,\n                                \"stac_item\",\n                                m.stac_dict[item.value],\n                            )\n                            m.stac_item[\"collection\"] = collection.value\n\n                        else:\n                            output.outputs = ()\n                            m.add_stac_layer(\n                                url=stac_data[0][item.value][\"href\"],\n                                assets=assets,\n                                name=layer_name.value,\n                                fit_bounds=False,\n                                **vis_params,\n                            )\n                            setattr(m, \"stac_item\", m.stac_dict[item.value])\n                            if \"rescale\" in m.layers[-1].url:\n                                output.outputs = ()\n\n                        output.clear_output()\n                    except Exception as e:\n                        print(e)\n\n                else:\n                    print(\"Please click on 'Items' to retrieve items.\")\n                    buttons.value = None\n\n        elif change[\"new\"] == \"Reset\":\n            reset_options()\n\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = True\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.stac_gui","title":"<code>stac_gui(m, position='topright', opened=True, **kwargs)</code>","text":"<p>Generates a tool GUI template using ipywidgets.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>beamgis/toolbar.py</code> <pre><code>def stac_gui(\n    m,\n    position: Optional[str] = \"topright\",\n    opened: Optional[bool] = True,\n    **kwargs,\n):\n    \"\"\"Generates a tool GUI template using ipywidgets.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import pandas as pd\n\n    if os.environ.get(\"STAC_CATALOGS\") is not None:\n        try:\n            source = eval(os.environ.get(\"STAC_CATALOGS\"))\n            m.set_catalog_source(source)\n        except Exception as e:\n            print(e)\n            print(\"Invalid STAC_CATALOGS environment variable.\")\n\n    if hasattr(m, \"_STAC_CATALOGS\"):\n        stac_custom_gui(m, **kwargs)\n        return\n\n    widget_width = \"450px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n    MAX_ITEMS = 20\n    if \"MAX_ITEMS\" in os.environ:\n        MAX_ITEMS = int(os.environ[\"MAX_ITEMS\"])\n\n    catalog_path = download_data_catalogs()\n    aws_open_data_path = os.path.join(catalog_path, \"aws_stac_catalogs.tsv\")\n    gee_path = os.path.join(catalog_path, \"gee_catalog.tsv\")\n    pc_path = os.path.join(catalog_path, \"pc_catalog.tsv\")\n    nasa_path = os.path.join(catalog_path, \"nasa_cmr_catalog.tsv\")\n    stac_index_path = os.path.join(catalog_path, \"stac_catalogs.tsv\")\n    stac_data = []\n\n    stac_info = {\n        \"AWS Open Data\": {\n            \"filename\": aws_open_data_path,\n            \"name\": \"Name\",\n            \"url\": \"Endpoint\",\n            \"description\": \"Description\",\n        },\n        \"Google Earth Engine\": {\n            \"filename\": gee_path,\n            \"name\": \"id\",\n            \"url\": \"url\",\n            \"description\": \"title\",\n        },\n        \"Microsoft Planetary Computer\": {\n            \"filename\": pc_path,\n            \"name\": \"title\",\n            \"url\": \"link\",\n            \"description\": \"description\",\n        },\n        \"NASA Common Metadata Repository\": {\n            \"filename\": nasa_path,\n            \"name\": \"id\",\n            \"url\": \"url\",\n            \"description\": \"title\",\n        },\n        \"STAC Index Catalogs\": {\n            \"filename\": stac_index_path,\n            \"name\": \"title\",\n            \"url\": \"url\",\n            \"description\": \"summary\",\n        },\n        \"Custom STAC API Endpoint\": {\n            \"filename\": \"\",\n            \"name\": \"\",\n            \"url\": \"\",\n            \"description\": \"\",\n        },\n    }\n\n    connections = list(stac_info.keys())\n\n    output = widgets.Output(\n        layout=widgets.Layout(width=widget_width, padding=padding, overflow=\"auto\")\n    )\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Discver STAC Catalog\",\n        icon=\"stack-exchange\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    connection = widgets.Dropdown(\n        options=connections,\n        value=\"AWS Open Data\",\n        description=\"Catalog:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    df = pd.read_csv(stac_info[connection.value][\"filename\"], sep=\"\\t\")\n    datasets = df[stac_info[connection.value][\"name\"]].tolist()\n\n    dataset = widgets.Dropdown(\n        options=datasets,\n        value=\"Sentinel-2 Cloud-Optimized GeoTIFFs\",\n        description=\"Dataset:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    description = widgets.Text(\n        value=\"Sentinel-2 Level 2A scenes and metadata\",\n        description=\"Description:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    http_url = widgets.Text(\n        value=\"https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a\",\n        description=\"URL:\",\n        tooltip=\"STAC Catalog URL\",\n        placeholder=\"Enter a STAC URL, e.g., https://earth-search.aws.element84.com/v1\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    custom_dataset = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Dataset:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    start_date = widgets.DatePicker(\n        description=\"Start date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=\"225px\", padding=padding),\n    )\n    end_date = widgets.DatePicker(\n        description=\"End date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=\"225px\", padding=padding),\n    )\n\n    collection = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Collection:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    band_names = [\"red\", \"green\", \"blue\"]\n\n    item = widgets.Dropdown(\n        options=[],\n        description=\"Item:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    layer_name = widgets.Text(\n        value=\"STAC Layer\",\n        description=\"Layer name:\",\n        tooltip=\"Enter a layer name for the selected file\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    band_width = \"149px\"\n    red = widgets.Dropdown(\n        options=band_names,\n        value=\"red\",\n        description=\"Red:\",\n        tooltip=\"Select a band for the red channel\",\n        style=style,\n        layout=widgets.Layout(width=band_width, padding=padding),\n    )\n\n    green = widgets.Dropdown(\n        options=band_names,\n        value=\"green\",\n        description=\"Green:\",\n        tooltip=\"Select a band for the green channel\",\n        style=style,\n        layout=widgets.Layout(width=\"148px\", padding=padding),\n    )\n\n    blue = widgets.Dropdown(\n        options=band_names,\n        value=\"blue\",\n        description=\"Blue:\",\n        tooltip=\"Select a band for the blue channel\",\n        style=style,\n        layout=widgets.Layout(width=band_width, padding=padding),\n    )\n\n    max_items = widgets.Text(\n        value=\"20\",\n        description=\"Max items:\",\n        placeholder=\"Maximum number of items to return from the STAC API\",\n        tooltip=\"Maximum number of items to return from the STAC API\",\n        style=style,\n        layout=widgets.Layout(width=\"130px\", padding=padding),\n    )\n\n    vmin = widgets.Text(\n        value=None,\n        description=\"vmin:\",\n        tooltip=\"Minimum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"100px\", padding=padding),\n    )\n\n    vmax = widgets.Text(\n        value=None,\n        description=\"vmax:\",\n        tooltip=\"Maximum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"100px\", padding=padding),\n    )\n\n    nodata = widgets.Text(\n        value=None,\n        description=\"Nodata:\",\n        tooltip=\"Nodata the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"113px\", padding=padding),\n    )\n\n    palette_options = list_palettes(lowercase=True)\n    palette = widgets.Dropdown(\n        options=palette_options,\n        value=None,\n        description=\"palette:\",\n        layout=widgets.Layout(width=\"180px\", padding=padding),\n        style=style,\n    )\n\n    add_footprints = widgets.Checkbox(\n        value=True,\n        description=\"Add footprints\",\n        indent=False,\n        layout=widgets.Layout(width=\"120px\", padding=padding),\n        style=style,\n    )\n\n    checkbox = widgets.Checkbox(\n        value=False,\n        description=\"Additional params\",\n        indent=False,\n        layout=widgets.Layout(width=\"154px\", padding=padding),\n        style=style,\n    )\n\n    query_params_text = \"Additional parameters to query the STAC API, for example: {'query': {'eo:cloud_cover':{'lt':10}}}\"\n    query_params = widgets.Textarea(\n        value=\"\",\n        placeholder=query_params_text,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n        style=style,\n    )\n\n    add_params_text = \"Additional parameters to visualize imagery, for example: {'palette': ['#006633', '#E5FFCC', '#662A00', '#D8D8D8', '#F5F5F5'], 'expression': '(SR_B5-SR_B4)/(SR_B5+SR_B4)'}\"\n    add_params = widgets.Textarea(\n        value=\"\",\n        placeholder=add_params_text,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n        style=style,\n    )\n\n    def reset_options(reset_url=True):\n        \"\"\"Reset the options to their default values.\"\"\"\n        connection.value = \"AWS Open Data\"\n        dataset.options = datasets\n        dataset.value = \"Sentinel-2 Cloud-Optimized GeoTIFFs\"\n        http_url.value = (\n            \"https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a\"\n        )\n        start_date.value = None\n        end_date.value = None\n        item.options = []\n        item.value = None\n        layer_name.value = \"\"\n        red.options = [\"red\", \"green\", \"blue\"]\n        green.options = [\"red\", \"green\", \"blue\"]\n        blue.options = [\"red\", \"green\", \"blue\"]\n        red.value = \"red\"\n        green.value = \"green\"\n        blue.value = \"blue\"\n        max_items.value = \"20\"\n        vmin.value = \"\"\n        vmax.value = \"\"\n        nodata.value = \"\"\n        palette.value = None\n        add_params.value = \"\"\n        output.outputs = ()\n\n    params_widget = widgets.VBox()\n\n    raster_options = widgets.VBox()\n    raster_options.children = [\n        widgets.HBox([red, green, blue]),\n        widgets.HBox([palette, add_footprints, checkbox]),\n        params_widget,\n    ]\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Search\", \"Display\", \"Reset\", \"Close\"],\n        tooltips=[\"Get Items\", \"Display Image\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"65px\"\n\n    dataset_widget = widgets.VBox()\n    dataset_widget.children = [\n        dataset,\n        description,\n        http_url,\n    ]\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        connection,\n        dataset_widget,\n        widgets.HBox([start_date, end_date]),\n        item,\n        raster_options,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def update_bands():\n        if len(stac_data) &gt; 0:\n            bnames = stac_data[0][item.value][\"bands\"]\n        else:\n            bnames = []\n\n        red.options = bnames\n        green.options = bnames\n        blue.options = bnames\n\n        default_bands = set_default_bands(bnames)\n        try:\n            red.value = default_bands[0]\n            green.value = default_bands[1]\n            blue.value = default_bands[2]\n        except Exception as e:\n            red.value = None\n            green.value = None\n            blue.value = None\n\n    def connection_changed(change):\n        if change[\"new\"]:\n            if connection.value != \"Custom STAC API Endpoint\":\n                df = pd.read_csv(stac_info[connection.value][\"filename\"], sep=\"\\t\")\n                datasets = df[stac_info[connection.value][\"name\"]].tolist()\n                dataset.options = datasets\n                dataset.value = datasets[0]\n                dataset_widget.children = [dataset, description, http_url]\n            else:\n                http_url.value = \"https://earth-search.aws.element84.com/v1\"\n                dataset_widget.children = [http_url, custom_dataset]\n                with output:\n                    print(\"Enter a STAC API endpoint and press Enter to list datasets\")\n\n    connection.observe(connection_changed, names=\"value\")\n\n    def dataset_changed(change):\n        if change[\"new\"]:\n            if connection.value != \"Custom STAC API Endpoint\":\n                df = pd.read_csv(stac_info[connection.value][\"filename\"], sep=\"\\t\")\n                df = df[df[stac_info[connection.value][\"name\"]] == dataset.value]\n                description.value = df[\n                    stac_info[connection.value][\"description\"]\n                ].tolist()[0]\n                http_url.value = df[stac_info[connection.value][\"url\"]].tolist()[0]\n                item.options = []\n                custom_dataset.options = []\n                stac_data.clear()\n                update_bands()\n\n    dataset.observe(dataset_changed, names=\"value\")\n\n    def http_url_changed(change):\n        with output:\n            output.outputs = ()\n            print(\"Searching...\")\n            try:\n                if connection.value == \"Custom STAC API Endpoint\":\n                    custom_collections = stac_collections(\n                        http_url.value, return_ids=True\n                    )\n                    if custom_collections:\n                        custom_dataset.options = custom_collections\n\n                        collection_id = http_url.value.split(\"/\")[-1]\n                        if collection_id in custom_collections:\n                            custom_dataset.value = collection_id\n\n                    else:\n                        custom_dataset.options = []\n\n                else:\n                    custom_cols = stac_collections(http_url.value, return_ids=True)\n                    item.options = custom_cols\n                    stac_data.clear()\n                update_bands()\n                output.outputs = ()\n            except Exception as e:\n                print(e)\n\n    http_url.on_submit(http_url_changed)\n\n    def item_changed(change):\n        if change[\"new\"]:\n            layer_name.value = item.value\n            with output:\n                update_bands()\n\n            if dataset.value == \"Sentinel-2 Cloud-Optimized GeoTIFFs\":\n                vmin.value = \"0\"\n                vmax.value = \"3000\"\n            else:\n                vmin.value = \"\"\n                vmax.value = \"\"\n\n    item.observe(item_changed, names=\"value\")\n\n    def checkbox_changed(change):\n        if change[\"new\"]:\n            params_widget.children = [\n                layer_name,\n                widgets.HBox([max_items, vmin, vmax, nodata]),\n                query_params,\n                add_params,\n            ]\n        else:\n            params_widget.children = []\n\n    checkbox.observe(checkbox_changed, names=\"value\")\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Search\":\n            with output:\n                output.outputs = ()\n                if http_url.value is not None:\n                    if start_date.value is not None and end_date.value is not None:\n                        datetime = str(start_date.value) + \"/\" + str(end_date.value)\n                    elif start_date.value is not None:\n                        datetime = str(start_date.value) + \"/..\"\n                    elif end_date.value is not None:\n                        datetime = \"../\" + str(end_date.value)\n                    else:\n                        datetime = None\n\n                    if m is not None:\n                        if m.user_roi is not None:\n                            intersects = m.user_roi[\"geometry\"]\n                        else:\n                            intersects = bbox_to_geojson(m.bounds)\n\n                    else:\n                        intersects = None\n\n                    if (\n                        checkbox.value\n                        and query_params.value.strip().startswith(\"{\")\n                        and query_params.value.strip().endswith(\"}\")\n                    ):\n                        query = eval(query_params.value)\n                    elif query_params.value.strip() == \"\":\n                        query = {}\n                    else:\n                        print(\n                            \"Invalid query parameters. It must be a dictionary with keys such as 'query', 'sortby', 'filter', 'fields'\"\n                        )\n                        query = {}\n\n                print(\"Retrieving items...\")\n                try:\n                    if connection.value in [\n                        \"Google Earth Engine\",\n                        \"NASA Common Metadata Repository\",\n                    ]:\n                        output.outputs = ()\n                        print(f\"{connection.value} is not supported yet.\")\n                    else:\n                        if connection.value == \"Custom STAC API Endpoint\":\n                            search = stac_search(\n                                url=http_url.value,\n                                max_items=int(max_items.value),\n                                intersects=intersects,\n                                datetime=datetime,\n                                collections=custom_dataset.value,\n                                **query,\n                            )\n\n                        else:\n                            search = stac_search(\n                                url=http_url.value,\n                                max_items=int(max_items.value),\n                                intersects=intersects,\n                                datetime=datetime,\n                                **query,\n                            )\n                        search_dict = stac_search_to_dict(search)\n                        item.options = list(search_dict.keys())\n                        setattr(m, \"stac_search\", search)\n                        setattr(m, \"stac_dict\", search_dict)\n                        setattr(m, \"stac_items\", stac_search_to_list(search))\n\n                        if add_footprints.value and m is not None:\n                            gdf = stac_search_to_gdf(search)\n                            style = {\n                                \"stroke\": True,\n                                \"color\": \"#000000\",\n                                \"weight\": 2,\n                                \"opacity\": 1,\n                                \"fill\": True,\n                                \"fillColor\": \"#000000\",\n                                \"fillOpacity\": 0,\n                            }\n                            hover_style = {\"fillOpacity\": 0.3}\n                            m.add_gdf(\n                                gdf,\n                                style=style,\n                                hover_style=hover_style,\n                                layer_name=\"Footprints\",\n                                zoom_to_layer=False,\n                            )\n                            setattr(m, \"stac_gdf\", gdf)\n\n                        stac_data.clear()\n                        stac_data.append(search_dict)\n                        update_bands()\n                        output.outputs = ()\n                except NotImplementedError as e:\n                    print(e)\n\n                except Exception as e:\n                    print(e)\n\n        elif change[\"new\"] == \"Display\":\n            with output:\n                output.outputs = ()\n\n                if item.value and m is not None:\n                    print(\"Loading data...\")\n\n                    if (\n                        checkbox.value\n                        and add_params.value.strip().startswith(\"{\")\n                        and add_params.value.strip().endswith(\"}\")\n                    ):\n                        vis_params = eval(add_params.value)\n                    else:\n                        vis_params = {}\n\n                    if (\n                        palette.value\n                        and len(set([red.value, green.value, blue.value])) == 1\n                    ) or (palette.value and \"expression\" in vis_params):\n                        vis_params[\"colormap_name\"] = palette.value\n                    elif (\n                        palette.value\n                        and len(set([red.value, green.value, blue.value])) &gt; 1\n                        and \"expression\" not in vis_params\n                    ):\n                        palette.value = None\n                        print(\"Palette can only be set for single band images.\")\n\n                    if vmin.value and vmax.value:\n                        vis_params[\"rescale\"] = f\"{vmin.value},{vmax.value}\"\n\n                    if nodata.value:\n                        vis_params[\"nodata\"] = nodata.value\n\n                    if len(set([red.value, green.value, blue.value])) == 1:\n                        assets = red.value\n                    else:\n                        assets = f\"{red.value},{green.value},{blue.value}\"\n\n                    try:\n                        if connection.value == \"Microsoft Planetary Computer\":\n                            m.add_stac_layer(\n                                collection=http_url.value.split(\"/\")[-1],\n                                item=item.value,\n                                assets=assets,\n                                name=layer_name.value,\n                                fit_bounds=False,\n                                **vis_params,\n                            )\n                            setattr(\n                                m,\n                                \"stac_item\",\n                                m.stac_dict[item.value],\n                            )\n                            m.stac_item[\"collection\"] = http_url.value.split(\"/\")[-1]\n\n                        else:\n                            m.add_stac_layer(\n                                url=stac_data[0][item.value][\"href\"],\n                                item=item.value,\n                                assets=assets,\n                                name=layer_name.value,\n                                fit_bounds=False,\n                                **vis_params,\n                            )\n                            setattr(m, \"stac_item\", m.stac_dict[item.value])\n                        output.outputs = ()\n                    except Exception as e:\n                        print(e)\n\n                else:\n                    print(\"Please click on the search button first.\")\n                    buttons.value = None\n\n        elif change[\"new\"] == \"Reset\":\n            reset_options()\n\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = opened\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=position\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.time_slider","title":"<code>time_slider(m, layers=None, labels=None, time_interval=1, position='bottomright', slider_length='150px', zoom_to_layer=False, **kwargs)</code>","text":"<p>Adds a time slider to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>dict</code> <p>The dictionary containing a set of XYZ tile layers.</p> <code>None</code> <code>labels</code> <code>list</code> <p>The list of labels to be used for the time series. Defaults to None.</p> <code>None</code> <code>time_interval</code> <code>int</code> <p>Time interval in seconds. Defaults to 1.</p> <code>1</code> <code>position</code> <code>str</code> <p>Position to place the time slider, can be any of ['topleft', 'topright', 'bottomleft', 'bottomright']. Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>slider_length</code> <code>str</code> <p>Length of the time slider. Defaults to \"150px\".</p> <code>'150px'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the extent of the layer. Defaults to False.</p> <code>False</code> Source code in <code>beamgis/toolbar.py</code> <pre><code>def time_slider(\n    m,\n    layers: Optional[Union[Dict, List, str]] = None,\n    labels: Optional[List] = None,\n    time_interval: Optional[int] = 1,\n    position: Optional[str] = \"bottomright\",\n    slider_length: Optional[str] = \"150px\",\n    zoom_to_layer: Optional[bool] = False,\n    **kwargs,\n):\n    \"\"\"Adds a time slider to the map.\n\n    Args:\n        layers (dict, optional): The dictionary containing a set of XYZ tile layers.\n        labels (list, optional): The list of labels to be used for the time series. Defaults to None.\n        time_interval (int, optional): Time interval in seconds. Defaults to 1.\n        position (str, optional): Position to place the time slider, can be any of ['topleft', 'topright', 'bottomleft', 'bottomright']. Defaults to \"bottomright\".\n        slider_length (str, optional): Length of the time slider. Defaults to \"150px\".\n        zoom_to_layer (bool, optional): Whether to zoom to the extent of the layer. Defaults to False.\n\n    \"\"\"\n    import time\n    import threading\n\n    bounds = None\n\n    if isinstance(layers, str):\n        layers = find_files(layers, ext=\"*.tif\", recursive=False)\n\n    if isinstance(layers, list):\n        if zoom_to_layer:\n            layer0 = layers[0]\n            _, tile_client = get_local_tile_layer(\n                layer0,\n                return_client=True,\n            )\n\n            bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n            bounds = (\n                bounds[2],\n                bounds[0],\n                bounds[3],\n                bounds[1],\n            )  # [minx, miny, maxx, maxy]\n            m.zoom_to_bounds(bounds)\n\n        layers = images_to_tiles(layers, names=labels, **kwargs)\n\n    if not isinstance(layers, dict):\n        raise TypeError(\"The layers must be a dictionary.\")\n\n    if len(layers) == 0:\n        layers = planet_monthly_tiles()\n\n    if labels is None:\n        labels = list(layers.keys())\n    if len(labels) != len(layers):\n        raise ValueError(\"The length of labels is not equal to that of layers.\")\n\n    slider = widgets.IntSlider(\n        min=1,\n        max=len(labels),\n        readout=False,\n        continuous_update=False,\n        layout=widgets.Layout(width=slider_length),\n    )\n    label = widgets.Label(\n        value=labels[0], layout=widgets.Layout(padding=\"0px 5px 0px 5px\")\n    )\n\n    play_btn = widgets.Button(\n        icon=\"play\",\n        tooltip=\"Play the time slider\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    pause_btn = widgets.Button(\n        icon=\"pause\",\n        tooltip=\"Pause the time slider\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    close_btn = widgets.Button(\n        icon=\"times\",\n        tooltip=\"Close the time slider\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    play_chk = widgets.Checkbox(value=False)\n\n    slider_widget = widgets.HBox([label, slider, play_btn, pause_btn, close_btn])\n\n    def play_click(b):\n        play_chk.value = True\n\n        def work(slider):\n            while play_chk.value:\n                if slider.value &lt; len(labels):\n                    slider.value += 1\n                else:\n                    slider.value = 1\n                time.sleep(time_interval)\n\n        thread = threading.Thread(target=work, args=(slider,))\n        thread.start()\n\n    def pause_click(b):\n        play_chk.value = False\n\n    play_btn.on_click(play_click)\n    pause_btn.on_click(pause_click)\n\n    keys = list(layers.keys())\n    layer = layers[keys[0]]\n    m.add(layer)\n\n    def slider_changed(change):\n        m.default_style = {\"cursor\": \"wait\"}\n        index = slider.value - 1\n        label.value = labels[index]\n        layer.url = layers[label.value].url\n        layer.name = layers[label.value].name\n        m.default_style = {\"cursor\": \"default\"}\n\n    slider.observe(slider_changed, \"value\")\n\n    def close_click(b):\n        play_chk.value = False\n        m.toolbar_reset()\n\n        if m.slider_ctrl is not None and m.slider_ctrl in m.controls:\n            m.remove_control(m.slider_ctrl)\n        slider_widget.close()\n\n    close_btn.on_click(close_click)\n\n    slider_ctrl = ipyleaflet.WidgetControl(widget=slider_widget, position=position)\n    m.add(slider_ctrl)\n    m.slider_ctrl = slider_ctrl\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.time_slider_for_gdf","title":"<code>time_slider_for_gdf(m, gdf, time_columns=None, labels=None, time_interval=1, position='bottomright', slider_length='150px', zoom_to_layer=False, style=None, **kwargs)</code>","text":"<p>Adds a time slider to the map for visualizing vector time series data.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <p>The leafmap.Map object</p> required <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>The GeoDataFrame with time series data stored as color codes in columns</p> required <code>time_columns</code> <code>list</code> <p>List of column names containing the time series data (e.g., dates)</p> <code>None</code> <code>labels</code> <code>list</code> <p>The list of labels to be used for the time series. Defaults to time_columns.</p> <code>None</code> <code>time_interval</code> <code>int</code> <p>Time interval in seconds. Defaults to 1.</p> <code>1</code> <code>position</code> <code>str</code> <p>Position to place the time slider. Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>slider_length</code> <code>str</code> <p>Length of the time slider. Defaults to \"150px\".</p> <code>'150px'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the extent of the layer. Defaults to False.</p> <code>False</code> <code>style</code> <code>dict</code> <p>Base style for the GeoJSON layer. Defaults to None.</p> <code>None</code> Source code in <code>beamgis/toolbar.py</code> <pre><code>def time_slider_for_gdf(\n    m,\n    gdf: \"gpd.GeoDataFrame\",\n    time_columns: Optional[List[str]] = None,\n    labels: Optional[List[str]] = None,\n    time_interval: Optional[int] = 1,\n    position: Optional[str] = \"bottomright\",\n    slider_length: Optional[str] = \"150px\",\n    zoom_to_layer: Optional[bool] = False,\n    style: Optional[Dict] = None,\n    **kwargs,\n):\n    \"\"\"Adds a time slider to the map for visualizing vector time series data.\n\n    Args:\n        m: The leafmap.Map object\n        gdf: The GeoDataFrame with time series data stored as color codes in columns\n        time_columns (list, optional): List of column names containing the time series data (e.g., dates)\n        labels (list, optional): The list of labels to be used for the time series. Defaults to time_columns.\n        time_interval (int, optional): Time interval in seconds. Defaults to 1.\n        position (str, optional): Position to place the time slider. Defaults to \"bottomright\".\n        slider_length (str, optional): Length of the time slider. Defaults to \"150px\".\n        zoom_to_layer (bool, optional): Whether to zoom to the extent of the layer. Defaults to False.\n        style (dict, optional): Base style for the GeoJSON layer. Defaults to None.\n    \"\"\"\n    import time\n    import threading\n    import ipywidgets as widgets\n    from ipyleaflet import WidgetControl\n\n    # Set default style if not provided\n    if style is None:\n        style = {\n            \"weight\": 1,\n            \"opacity\": 1,\n            \"fillOpacity\": 1.0,\n        }\n\n    # Extract time columns if not provided\n    if time_columns is None:\n        # Assuming time columns are in YYYY-MM-DD format\n        time_columns = [\n            col\n            for col in gdf.columns\n            if isinstance(col, str)\n            and col.split(\"-\")[0].isdigit()\n            and len(col.split(\"-\")) == 3\n        ]\n        time_columns.sort()  # Sort chronologically\n\n    if len(time_columns) == 0:\n        raise ValueError(\"No time columns found in the GeoDataFrame\")\n\n    # Use time_columns as labels if not provided\n    if labels is None:\n        labels = time_columns\n\n    if len(labels) != len(time_columns):\n        raise ValueError(\"The length of labels is not equal to that of time_columns\")\n\n    # Add the GeoJSON layer to the map with the first time column\n    initial_style_callback = lambda feat: {\n        \"fillColor\": feat[\"properties\"][time_columns[0]]\n    }\n\n    # Check if we already have a GeoJSON layer\n    geojson_layer = None\n    for layer in m.layers:\n        if hasattr(layer, \"style_callback\"):\n            geojson_layer = layer\n            break\n\n    # If no GeoJSON layer found, add one\n    if geojson_layer is None:\n        if hasattr(m, \"add_gdf\"):  # For leafmap\n            m.add_gdf(\n                gdf,\n                style=style,\n                style_callback=initial_style_callback,\n                zoom_to_layer=zoom_to_layer,\n                **kwargs,\n            )\n\n            # Get the added layer (usually the last one added)\n            for layer in reversed(m.layers):\n                if hasattr(layer, \"style_callback\"):\n                    geojson_layer = layer\n                    break\n        else:\n            raise ValueError(\"Map object must support add_gdf method\")\n\n    # Create slider widget\n    slider = widgets.IntSlider(\n        min=1,\n        max=len(time_columns),\n        value=1,\n        readout=False,\n        continuous_update=False,\n        layout=widgets.Layout(width=slider_length),\n    )\n\n    # Create label widget\n    label = widgets.Label(\n        value=labels[0], layout=widgets.Layout(padding=\"0px 5px 0px 5px\")\n    )\n\n    # Create control buttons\n    play_btn = widgets.Button(\n        icon=\"play\",\n        tooltip=\"Play the time slider\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    pause_btn = widgets.Button(\n        icon=\"pause\",\n        tooltip=\"Pause the time slider\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    close_btn = widgets.Button(\n        icon=\"times\",\n        tooltip=\"Close the time slider\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    play_chk = widgets.Checkbox(value=False)\n\n    # Assemble widget\n    slider_widget = widgets.HBox([label, slider, play_btn, pause_btn, close_btn])\n\n    # Play button click handler\n    def play_click(b):\n        play_chk.value = True\n\n        def work(slider):\n            while play_chk.value:\n                if slider.value &lt; len(time_columns):\n                    slider.value += 1\n                else:\n                    slider.value = 1\n                time.sleep(time_interval)\n\n        thread = threading.Thread(target=work, args=(slider,))\n        thread.start()\n\n    # Pause button click handler\n    def pause_click(b):\n        play_chk.value = False\n\n    play_btn.on_click(play_click)\n    pause_btn.on_click(pause_click)\n\n    # Slider change handler\n    def slider_changed(change):\n        m.default_style = {\"cursor\": \"wait\"}\n        index = slider.value - 1\n        current_column = time_columns[index]\n        label.value = labels[index]\n\n        # Update the style_callback to use the current time column\n        if geojson_layer is not None:\n            geojson_layer.style_callback = lambda feat: {\n                \"fillColor\": feat[\"properties\"][current_column]\n            }\n            # geojson_layer.redraw()\n\n        m.default_style = {\"cursor\": \"default\"}\n\n    slider.observe(slider_changed, \"value\")\n\n    # Close button click handler\n    def close_click(b):\n        play_chk.value = False\n\n        if hasattr(m, \"toolbar_reset\"):\n            m.toolbar_reset()\n\n        if (\n            hasattr(m, \"slider_ctrl\")\n            and m.slider_ctrl is not None\n            and m.slider_ctrl in m.controls\n        ):\n            m.remove_control(m.slider_ctrl)\n\n        slider_widget.close()\n\n    close_btn.on_click(close_click)\n\n    # Add the control to the map\n    slider_ctrl = WidgetControl(widget=slider_widget, position=position)\n    m.add_control(slider_ctrl)\n    m.slider_ctrl = slider_ctrl  # Store reference to the control\n\n    return geojson_layer\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.tool_header_template","title":"<code>tool_header_template(m, opened=True)</code>","text":"<p>Create a toolbar widget.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>geemap.Map</code> <p>The geemap.Map instance. Defaults to None.</p> required <code>opened</code> <code>bool</code> <p>Whether to open the toolbar. Defaults to True.</p> <code>True</code> Source code in <code>beamgis/toolbar.py</code> <pre><code>def tool_header_template(m, opened: Optional[bool] = True):\n    \"\"\"Create a toolbar widget.\n\n    Args:\n        m (geemap.Map, optional): The geemap.Map instance. Defaults to None.\n        opened (bool, optional): Whether to open the toolbar. Defaults to True.\n    \"\"\"\n\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"gear\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        buttons,\n        output,\n    ]\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            with output:\n                output.outputs = ()\n                print(\"Running ...\")\n        elif change[\"new\"] == \"Reset\":\n            output.outputs = ()\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = opened\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add_control(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#beamgis.toolbar.tool_template","title":"<code>tool_template(m, opened=True)</code>","text":"<p>Generates a tool GUI template using ipywidgets. Icons can be found at https://fontawesome.com/v4/icons</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <code>opened</code> <code>bool</code> <p>Whether to open the toolbar. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>beamgis/toolbar.py</code> <pre><code>def tool_template(m, opened: Optional[bool] = True):\n    \"\"\"Generates a tool GUI template using ipywidgets. Icons can be found at https://fontawesome.com/v4/icons\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n        opened (bool, optional): Whether to open the toolbar. Defaults to True.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"gear\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    checkbox = widgets.Checkbox(\n        description=\"Checkbox\",\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=widget_width),\n    )\n\n    dropdown = widgets.Dropdown(\n        options=[\"Option 1\", \"Option 2\", \"Option 3\"],\n        value=None,\n        description=\"Dropdown:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    int_slider = widgets.IntSlider(\n        min=1,\n        max=100,\n        description=\"Int Slider: \",\n        readout=False,\n        continuous_update=True,\n        layout=widgets.Layout(width=\"220px\", padding=padding),\n        style=style,\n    )\n\n    int_slider_label = widgets.Label(str(int_slider.value))\n\n    def update_int_slider(change):\n        int_slider_label.value = str(change[\"new\"])\n\n    int_slider.observe(update_int_slider, \"value\")\n\n    float_slider = widgets.FloatSlider(\n        min=1,\n        max=100,\n        description=\"Float Slider: \",\n        readout=False,\n        continuous_update=True,\n        layout=widgets.Layout(width=\"210px\", padding=padding),\n        style=style,\n    )\n\n    float_slider_label = widgets.Label(str(float_slider.value))\n\n    def update_float_slider(change):\n        float_slider_label.value = str(change[\"new\"])\n\n    float_slider.observe(update_float_slider, \"value\")\n\n    color = widgets.ColorPicker(\n        concise=False,\n        description=\"Color:\",\n        value=\"white\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    text = widgets.Text(\n        value=\"\",\n        description=\"Textbox:\",\n        placeholder=\"Placeholder\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    textarea = widgets.Textarea(\n        placeholder=\"Placeholder\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        checkbox,\n        widgets.HBox([int_slider, int_slider_label]),\n        widgets.HBox([float_slider, float_slider_label]),\n        dropdown,\n        text,\n        color,\n        textarea,\n        buttons,\n        output,\n    ]\n\n    # toolbar_event = ipyevents.Event(\n    #     source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    # )\n\n    # def handle_toolbar_event(event):\n    #     if event[\"type\"] == \"mouseenter\":\n    #         toolbar_widget.children = [toolbar_header, toolbar_footer]\n    #     elif event[\"type\"] == \"mouseleave\":\n    #         if not toolbar_button.value:\n    #             toolbar_widget.children = [toolbar_button]\n    #             toolbar_button.value = False\n    #             close_button.value = False\n\n    # toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            with output:\n                output.outputs = ()\n                print(\"Running ...\")\n        elif change[\"new\"] == \"Reset\":\n            textarea.value = \"\"\n            output.outputs = ()\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = opened\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add_control(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use beamgis in a project:</p> <pre><code>import beamgis\n</code></pre>"},{"location":"examples/Lab9_leafmap/","title":"Lab9 leafmap","text":"In\u00a0[1]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[2]: Copied! <pre>m = leafmap.Map()\nurl = \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\"\nm.add_search_control(url, placeholder=\"Search for a place\", position=\"topright\", zoom=6)\nm\n</pre> m = leafmap.Map() url = \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\" m.add_search_control(url, placeholder=\"Search for a place\", position=\"topright\", zoom=6) m Out[2]: In\u00a0[3]: Copied! <pre>map = leafmap.Map()\nurl = \"https://services.terrascope.be/wms/v2?\"\nmap.add_wms_layer(\n    url,\n    name=\"World Landcover\",\n    opacity=0.8,\n    layers=\"WORLDCOVER_2021_MAP\",\n    transparent=True,\n)\nmap.add_legend(\n    builtin_legend=\"ESA_WorldCover\",\n)\nmap\n</pre> map = leafmap.Map() url = \"https://services.terrascope.be/wms/v2?\" map.add_wms_layer(     url,     name=\"World Landcover\",     opacity=0.8,     layers=\"WORLDCOVER_2021_MAP\",     transparent=True, ) map.add_legend(     builtin_legend=\"ESA_WorldCover\", ) map Out[3]: In\u00a0[4]: Copied! <pre>map_1 = leafmap.Map(\n    basemap=\"Google Satellite\", center=(47.653441, -117.597316), zoom=16\n)\nmap_1\n</pre> map_1 = leafmap.Map(     basemap=\"Google Satellite\", center=(47.653441, -117.597316), zoom=16 ) map_1 Out[4]: In\u00a0[5]: Copied! <pre>import geopandas as gpd\n</pre> import geopandas as gpd In\u00a0[6]: Copied! <pre>gdf = gpd.read_file(\n    \"https://github.com/opengeos/datasets/releases/download/places/wa_building_centroids.geojson\"\n)\ngdf.head()\n</pre> gdf = gpd.read_file(     \"https://github.com/opengeos/datasets/releases/download/places/wa_building_centroids.geojson\" ) gdf.head() Out[6]: Class Confidence Shape_Leng Shape_Area geometry 0 1 28.905460 68.457069 292.568026 POINT (-117.60109 47.65499) 1 1 99.420196 97.152785 556.702899 POINT (-117.59953 47.65533) 2 1 95.450807 90.916993 492.940128 POINT (-117.59991 47.65514) 3 1 91.446453 85.645123 453.842109 POINT (-117.59953 47.65575) 4 1 90.172392 78.057638 380.403649 POINT (-117.59989 47.65534) In\u00a0[7]: Copied! <pre># Extract longitude and latitude from geometry and append to gdf\ngdf[\"longitude\"] = gdf.geometry.x\ngdf[\"latitude\"] = gdf.geometry.y\ngdf.head()\n</pre> # Extract longitude and latitude from geometry and append to gdf gdf[\"longitude\"] = gdf.geometry.x gdf[\"latitude\"] = gdf.geometry.y gdf.head() Out[7]: Class Confidence Shape_Leng Shape_Area geometry longitude latitude 0 1 28.905460 68.457069 292.568026 POINT (-117.60109 47.65499) -117.601092 47.654993 1 1 99.420196 97.152785 556.702899 POINT (-117.59953 47.65533) -117.599525 47.655326 2 1 95.450807 90.916993 492.940128 POINT (-117.59991 47.65514) -117.599910 47.655143 3 1 91.446453 85.645123 453.842109 POINT (-117.59953 47.65575) -117.599532 47.655747 4 1 90.172392 78.057638 380.403649 POINT (-117.59989 47.65534) -117.599892 47.655336 In\u00a0[8]: Copied! <pre>map_1.add_marker_cluster(\n    gdf,\n    x=\"longitude\",\n    y=\"latitude\",\n    layer_name=\"Building Centroids\",\n    radius=5,\n    outline_color=\"red\",\n    fill_color=\"yellow\",\n    fill_opacity=0.8,\n)\n</pre> map_1.add_marker_cluster(     gdf,     x=\"longitude\",     y=\"latitude\",     layer_name=\"Building Centroids\",     radius=5,     outline_color=\"red\",     fill_color=\"yellow\",     fill_opacity=0.8, ) In\u00a0[9]: Copied! <pre>map_2 = leafmap.Map(\n    basemap=\"Google Satellite\", center=(47.653441, -117.597316), zoom=16\n)\n</pre> map_2 = leafmap.Map(     basemap=\"Google Satellite\", center=(47.653441, -117.597316), zoom=16 ) In\u00a0[10]: Copied! <pre>map_2.add_circle_markers_from_xy(\n    gdf,\n    x=\"longitude\",\n    y=\"latitude\",\n    radius=5,\n    color=\"red\",\n    fill_color=\"yellow\",\n    fill_opacity=0.8,\n    layer_name=\"Building Centroids\",\n    zoom_to_layer=True,\n)\nmap_2\n</pre> map_2.add_circle_markers_from_xy(     gdf,     x=\"longitude\",     y=\"latitude\",     radius=5,     color=\"red\",     fill_color=\"yellow\",     fill_opacity=0.8,     layer_name=\"Building Centroids\",     zoom_to_layer=True, ) map_2 Out[10]: In\u00a0[11]: Copied! <pre>map_3 = leafmap.Map(basemap=\"Google Satellite\")\ndata = \"https://github.com/opengeos/datasets/releases/download/places/wa_overture_buildings.geojson\"\nstyle = {\"color\": \"red\", \"weight\": 1.5, \"fillOpacity\": 0}\nmap_3.add_vector(data, layer_name=\"Overture Buildings\", style=style, zoom_to_layer=True)\nmap_3\n</pre> map_3 = leafmap.Map(basemap=\"Google Satellite\") data = \"https://github.com/opengeos/datasets/releases/download/places/wa_overture_buildings.geojson\" style = {\"color\": \"red\", \"weight\": 1.5, \"fillOpacity\": 0} map_3.add_vector(data, layer_name=\"Overture Buildings\", style=style, zoom_to_layer=True) map_3 Out[11]: In\u00a0[12]: Copied! <pre>map_4 = leafmap.Map(basemap=\"Google Satellite\")\ndata = \"https://github.com/opengeos/datasets/releases/download/places/las_vegas_roads.geojson\"\nstyle = {\"color\": \"red\", \"weight\": 2, \"fillOpacity\": 0}\nmap_4.add_vector(data, layer_name=\"Las Vegas Roads\", style=style, zoom_to_layer=True)\nmap_4\n</pre> map_4 = leafmap.Map(basemap=\"Google Satellite\") data = \"https://github.com/opengeos/datasets/releases/download/places/las_vegas_roads.geojson\" style = {\"color\": \"red\", \"weight\": 2, \"fillOpacity\": 0} map_4.add_vector(data, layer_name=\"Las Vegas Roads\", style=style, zoom_to_layer=True) map_4 Out[12]: In\u00a0[13]: Copied! <pre>url = \"https://github.com/opengeos/datasets/releases/download/us/us_counties.geojson\"\ngdf = gpd.read_file(url)\n\nmap_5 = leafmap.Map(center=(37.5, -96), zoom=4)\nmap_5.add_data(\n    gdf,\n    column=\"CENSUSAREA\",\n    scheme=\"Quantiles\",\n    cmap=\"Blues\",\n    legend_title=\"Census Area\",\n)\nmap_5\n</pre> url = \"https://github.com/opengeos/datasets/releases/download/us/us_counties.geojson\" gdf = gpd.read_file(url)  map_5 = leafmap.Map(center=(37.5, -96), zoom=4) map_5.add_data(     gdf,     column=\"CENSUSAREA\",     scheme=\"Quantiles\",     cmap=\"Blues\",     legend_title=\"Census Area\", ) map_5 Out[13]: In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[14]: Copied! <pre>Pre_event_imagery = (\n    \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-07-01.tif\"\n)\nPost_event_imagery = (\n    \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-09-13.tif\"\n)\n</pre> Pre_event_imagery = (     \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-07-01.tif\" ) Post_event_imagery = (     \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-09-13.tif\" ) In\u00a0[15]: Copied! <pre>map_6 = leafmap.Map()\nmap_6.split_map(\n    left_layer=Pre_event_imagery,\n    right_layer=Post_event_imagery,\n    left_label=\"Pre-event Imagery\",\n    right_label=\"Post-event Imagery\",\n)\nmap_6\n</pre> map_6 = leafmap.Map() map_6.split_map(     left_layer=Pre_event_imagery,     right_layer=Post_event_imagery,     left_label=\"Pre-event Imagery\",     right_label=\"Post-event Imagery\", ) map_6 Out[15]:"},{"location":"examples/Lab9_leafmap/#question-1-creating-an-interactive-map","title":"Question 1: Creating an Interactive Map\u00b6","text":""},{"location":"examples/Lab9_leafmap/#question-2-adding-map-legends","title":"Question 2: Adding Map Legends\u00b6","text":""},{"location":"examples/Lab9_leafmap/#question-3-creating-marker-clusters","title":"Question 3: Creating Marker Clusters\u00b6","text":""},{"location":"examples/Lab9_leafmap/#create-a-marker-cluster-visualization-from-a-geojson-file-of-building-centroids","title":"Create a marker cluster visualization from a GeoJSON file of building centroids\u00b6","text":""},{"location":"examples/Lab9_leafmap/#create-circle-markers-for-each-building-centroid-using-the-mapadd_circle_markers_from_xy-method","title":"Create circle markers for each building centroid using the Map.add_circle_markers_from_xy() method\u00b6","text":""},{"location":"examples/Lab9_leafmap/#question-4-visualizing-vector-data","title":"Question 4: Visualizing Vector Data\u00b6","text":""},{"location":"examples/Lab9_leafmap/#visualize-the-building-polygons-geojson-file-and-style-it-with","title":"Visualize the building polygons GeoJSON file and style it with:\u00b6","text":""},{"location":"examples/Lab9_leafmap/#visualize-the-road-polylines-geojson-file-and-style-it-with","title":"Visualize the road polylines GeoJSON file and style it with:\u00b6","text":""},{"location":"examples/Lab9_leafmap/#create-a-choropleth-map-of-county-areas-in-the-us","title":"Create a choropleth map of county areas in the US:\u00b6","text":""},{"location":"examples/Lab9_leafmap/#exercise-5-creating-a-split-map","title":"Exercise 5: Creating a Split Map\u00b6","text":""},{"location":"examples/Notebook_Example/","title":"Notebook Example","text":"In\u00a0[1]: Copied! <pre>import beamgis\n</pre> import beamgis In\u00a0[2]: Copied! <pre># adding a basemap to a map\n# Create a map with a specific center and zoom level\nm = beamgis.Map(center=(20, 0), zoom=2, height=\"600px\")\nm.add_basemap(basemap=\"CartoDB.DarkMatter\")\nm\n</pre> # adding a basemap to a map # Create a map with a specific center and zoom level m = beamgis.Map(center=(20, 0), zoom=2, height=\"600px\") m.add_basemap(basemap=\"CartoDB.DarkMatter\") m Out[2]: In\u00a0[3]: Copied! <pre>m = beamgis.Map(center=(20, 0), zoom=2, height=\"600px\")\nm.add_google_map(\"terrain\")\nm\n</pre> m = beamgis.Map(center=(20, 0), zoom=2, height=\"600px\") m.add_google_map(\"terrain\") m Out[3]: In\u00a0[4]: Copied! <pre># Importing GeoJSON data from a URL\n\nm = beamgis.Map()\nurl = r\"https://github.com/opengeos/datasets/releases/download/us/us_southeast_countries.geojson\"\nm.add_geojson(url, zoom_to_layer=True, hover_style={\"fillColor\": \"red\"})\nm\n</pre> # Importing GeoJSON data from a URL  m = beamgis.Map() url = r\"https://github.com/opengeos/datasets/releases/download/us/us_southeast_countries.geojson\" m.add_geojson(url, zoom_to_layer=True, hover_style={\"fillColor\": \"red\"}) m Out[4]: In\u00a0[5]: Copied! <pre>url = r\"data\\us_cities.shp\"\n</pre> url = r\"data\\us_cities.shp\" In\u00a0[6]: Copied! <pre># import geopandas as gpd\n\n# # Add the existing GeoDataFrame to the map\n# m.add_shp(url, zoom_to_layer=True, hover_style={\"fillColor\": \"red\"})\n# m\n</pre> # import geopandas as gpd  # # Add the existing GeoDataFrame to the map # m.add_shp(url, zoom_to_layer=True, hover_style={\"fillColor\": \"red\"}) # m"},{"location":"examples/Notebook_Example/#ipyleaflet-demo","title":"Ipyleaflet Demo\u00b6","text":""},{"location":"examples/add_raster/","title":"Add raster","text":"In\u00a0[1]: Copied! <pre>import beamgis\n</pre> import beamgis In\u00a0[2]: Copied! <pre># Display the map object in the Jupyter Notebook\nm = beamgis.Map()\nm\n</pre> # Display the map object in the Jupyter Notebook m = beamgis.Map() m Out[2]: In\u00a0[3]: Copied! <pre># Define the url for the raster file\nurl = r\"https://github.com/opengeos/datasets/releases/download/raster/dem_90m.tif\"\n</pre> # Define the url for the raster file url = r\"https://github.com/opengeos/datasets/releases/download/raster/dem_90m.tif\" In\u00a0[4]: Copied! <pre># Add the raster file to the map with a \"terrain\" colormap\nm.add_raster(url, colormap=\"terrain\", name=\"dem\", opacity=0.5)\nm.add_layer_control()\n</pre> # Add the raster file to the map with a \"terrain\" colormap m.add_raster(url, colormap=\"terrain\", name=\"dem\", opacity=0.5) m.add_layer_control() In\u00a0[5]: Copied! <pre># Add new map\nm_2 = beamgis.Map()\nm_2\n</pre> # Add new map m_2 = beamgis.Map() m_2 Out[5]: In\u00a0[6]: Copied! <pre># Add the second raster file to the map\nurl_2 = \"https://github.com/opengeos/datasets/releases/download/raster/LC09_039035_20240708_90m.tif\"\n</pre> # Add the second raster file to the map url_2 = \"https://github.com/opengeos/datasets/releases/download/raster/LC09_039035_20240708_90m.tif\" In\u00a0[7]: Copied! <pre># Add the raster file to the map with specific band indexes and opacity\nm_2.add_raster(url_2, indexes=[5, 4, 3], name=\"landsat\", opacity=0.2)\n</pre> # Add the raster file to the map with specific band indexes and opacity m_2.add_raster(url_2, indexes=[5, 4, 3], name=\"landsat\", opacity=0.2) In\u00a0[8]: Copied! <pre># Create a new map object for adding an image overlay\nimage_m = beamgis.Map()\nimage_m\n</pre> # Create a new map object for adding an image overlay image_m = beamgis.Map() image_m Out[8]: In\u00a0[9]: Copied! <pre># Define the URL for the image to be added to the map\nimage_url = \"https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExZWFocm8xeng4aWQ1bXVmcmUyM2gzczlydmhjc2tyMWhhdzlnZzI3ayZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/DMUFPG2niG1TW/giphy.gif\"\n\n# Define the geographical bounds for the image overlay\nbounds = ((13, -150), (40, -120))\n</pre> # Define the URL for the image to be added to the map image_url = \"https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExZWFocm8xeng4aWQ1bXVmcmUyM2gzczlydmhjc2tyMWhhdzlnZzI3ayZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/DMUFPG2niG1TW/giphy.gif\"  # Define the geographical bounds for the image overlay bounds = ((13, -150), (40, -120)) In\u00a0[10]: Copied! <pre># Add an image overlay to the map using the specified image URL and geographical bounds\nimage_m.add_image(image_url, bounds)\n</pre> # Add an image overlay to the map using the specified image URL and geographical bounds image_m.add_image(image_url, bounds) In\u00a0[11]: Copied! <pre># Initialize a new map object for adding a video overlay\nvideo_m = beamgis.Map(center=(40, -120), zoom=3)\nvideo_m\n</pre> # Initialize a new map object for adding a video overlay video_m = beamgis.Map(center=(40, -120), zoom=3) video_m Out[11]: In\u00a0[12]: Copied! <pre># Define the URL for the video to be added to the map\nurl = (\n    \"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"\n)\nbounds = ((37.56238816, -122.515963), (37.563391708, -122.5130939))\n</pre> # Define the URL for the video to be added to the map url = (     \"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\" ) bounds = ((37.56238816, -122.515963), (37.563391708, -122.5130939)) In\u00a0[13]: Copied! <pre># Add a video overlay to the map\nvideo_m.add_video(url, bounds, name=\"drone\")\n</pre> # Add a video overlay to the map video_m.add_video(url, bounds, name=\"drone\") In\u00a0[14]: Copied! <pre># Add new map\nwms_m = beamgis.Map(center=(40, -100), zoom=5)\nwms_m\n</pre> # Add new map wms_m = beamgis.Map(center=(40, -100), zoom=5) wms_m Out[14]: In\u00a0[15]: Copied! <pre># Define the URL for the WMS service and the layers to be displayed\nwms_url = \"https://imagery.nationalmap.gov/arcgis/services/USGSNAIPPlus/ImageServer/WMSServer?\"\n</pre> # Define the URL for the WMS service and the layers to be displayed wms_url = \"https://imagery.nationalmap.gov/arcgis/services/USGSNAIPPlus/ImageServer/WMSServer?\" In\u00a0[16]: Copied! <pre># Add the WMS layer to the map\nwms_m.add_wms_layer(\n    wms_url, name=\"natural color\", layers=\"USGSNAIPPlus:NaturalColor\", opacity=0.8\n)\n</pre> # Add the WMS layer to the map wms_m.add_wms_layer(     wms_url, name=\"natural color\", layers=\"USGSNAIPPlus:NaturalColor\", opacity=0.8 )"},{"location":"examples/add_raster/#adding-raster-files","title":"Adding Raster Files\u00b6","text":""},{"location":"examples/add_raster/#adding-raster-to-map","title":"Adding Raster to map\u00b6","text":""},{"location":"examples/add_raster/#displaying-specific-bands","title":"Displaying specific bands\u00b6","text":""},{"location":"examples/add_raster/#adding-an-image-overlay","title":"Adding an image overlay\u00b6","text":""},{"location":"examples/add_raster/#adding-a-video-overlay","title":"Adding a video overlay\u00b6","text":""},{"location":"examples/add_raster/#adding-wms-layer","title":"Adding WMS Layer\u00b6","text":""},{"location":"examples/folium/","title":"Folium","text":"In\u00a0[1]: Copied! <pre># import package\nimport beamgis.foliumap as beamgis\n</pre> # import package import beamgis.foliumap as beamgis In\u00a0[2]: Copied! <pre>self = beamgis.Map(center=[20, 0], zoom=4)\nurl = \"https://github.com/opengeos/datasets/releases/download/world/countries.geojson\"\nself.add_geojson(url, name=\"Countries\")\nself.add_layer_control()\nself\n</pre> self = beamgis.Map(center=[20, 0], zoom=4) url = \"https://github.com/opengeos/datasets/releases/download/world/countries.geojson\" self.add_geojson(url, name=\"Countries\") self.add_layer_control() self Out[2]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[3]: Copied! <pre># Built-in basemap\nself = beamgis.Map(center=[40, -100], zoom=4)\nself.add_basemap(\"CartoDB.DarkMatter\")\nself\n</pre> # Built-in basemap self = beamgis.Map(center=[40, -100], zoom=4) self.add_basemap(\"CartoDB.DarkMatter\") self Out[3]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[4]: Copied! <pre># Custom basemap\nself = beamgis.Map(center=[8, 0], zoom=6)\nself.add_basemap(\n    {\n        \"tiles\": \"https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}\",\n        \"name\": \"Google Road\",\n        \"attr\": \"\u00a9 Google contributors\",\n    }\n)\nself\n</pre> # Custom basemap self = beamgis.Map(center=[8, 0], zoom=6) self.add_basemap(     {         \"tiles\": \"https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}\",         \"name\": \"Google Road\",         \"attr\": \"\u00a9 Google contributors\",     } ) self Out[4]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[5]: Copied! <pre># m = beamgis.Map(height=600, center=[39.4948, -108.5492], zoom=12)\n# url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\n# url2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"\n# m.add_split_map(url, url2)\n# m\n</pre> # m = beamgis.Map(height=600, center=[39.4948, -108.5492], zoom=12) # url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" # url2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\" # m.add_split_map(url, url2) # m"},{"location":"examples/folium/#folium-demo","title":"Folium Demo\u00b6","text":""},{"location":"examples/heatmap/","title":"Heatmap","text":"In\u00a0[1]: Copied! <pre># !pip install beamgis\n</pre> # !pip install beamgis In\u00a0[2]: Copied! <pre>import beamgis\n</pre> import beamgis In\u00a0[3]: Copied! <pre># Define the file URL for the dataset containing US cities data\nfile = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.csv\"\n</pre> # Define the file URL for the dataset containing US cities data file = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.csv\" In\u00a0[4]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[5]: Copied! <pre># df = leafmap.csv_to_df(file)\n# df.head()\n</pre> # df = leafmap.csv_to_df(file) # df.head() In\u00a0[6]: Copied! <pre># Create a map and add a heatmap layer\nm = beamgis.Map(center=(37.5, -96), zoom=4)\n\nm.add_heatmap(\n    file,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"pop_max\",\n    name=\"Heat map\",\n    radius=20,\n)\nm\n</pre> # Create a map and add a heatmap layer m = beamgis.Map(center=(37.5, -96), zoom=4)  m.add_heatmap(     file,     latitude=\"latitude\",     longitude=\"longitude\",     value=\"pop_max\",     name=\"Heat map\",     radius=20, ) m Out[6]: In\u00a0[7]: Copied! <pre># Import the foliumap module from beamgis for creating maps\nimport beamgis.foliumap as beamgis\n</pre> # Import the foliumap module from beamgis for creating maps import beamgis.foliumap as beamgis In\u00a0[8]: Copied! <pre># Create a map centered at the specified coordinates with a zoom level of 4\nm = beamgis.Map(center=(37.5, -96), zoom=4)\n\n# Add a heatmap layer to the map using the dataset from the 'file' variable\n# The heatmap uses latitude and longitude for positioning and 'pop_max' for intensity\nm.add_heatmap(\n    file,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"pop_max\",\n    name=\"Heat map\",\n    radius=20,\n)\n\n# Display the map\nm\n</pre> # Create a map centered at the specified coordinates with a zoom level of 4 m = beamgis.Map(center=(37.5, -96), zoom=4)  # Add a heatmap layer to the map using the dataset from the 'file' variable # The heatmap uses latitude and longitude for positioning and 'pop_max' for intensity m.add_heatmap(     file,     latitude=\"latitude\",     longitude=\"longitude\",     value=\"pop_max\",     name=\"Heat map\",     radius=20, )  # Display the map m Out[8]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"examples/heatmap/#creating-heatmaps-with-beamgis","title":"Creating heatmaps with beamgis\u00b6","text":""},{"location":"examples/heatmap/#using-leafmap-to-inspect-the-data","title":"using leafmap to inspect the data\u00b6","text":""},{"location":"examples/heatmap/#creating-heatmap-in-folium","title":"Creating heatmap in folium\u00b6","text":""},{"location":"examples/heatmapwidget/","title":"Heatmapwidget","text":"In\u00a0[1]: Copied! <pre>from beamgis.heatmapwidget import HeatmapWidget\nimport beamgis\n</pre> from beamgis.heatmapwidget import HeatmapWidget import beamgis In\u00a0[2]: Copied! <pre># Create a map object with a specified center, zoom level, and scroll wheel zoom enabled\nm = beamgis.Map(center=(20, 0), zoom=2, scroll_wheel_zoom=True)\n\n# Create a HeatmapWidget and associate it with the map object\nwidget = HeatmapWidget(map_obj=m)\n\n# Display the heatmap widget and the map in the notebook\ndisplay(widget)\ndisplay(m)\n</pre> # Create a map object with a specified center, zoom level, and scroll wheel zoom enabled m = beamgis.Map(center=(20, 0), zoom=2, scroll_wheel_zoom=True)  # Create a HeatmapWidget and associate it with the map object widget = HeatmapWidget(map_obj=m)  # Display the heatmap widget and the map in the notebook display(widget) display(m) In\u00a0[3]: Copied! <pre># Create a new map object\n# Add a heatmap GUI to the map\n# Add a basemap GUI to the map\n# Display the map with the added GUIs\nm = beamgis.Map(center=(20, 0), zoom=5, scroll_wheel_zoom=True)\nm.add_heatmap_gui()\nm.add_basemap_gui()\nm\n</pre> # Create a new map object # Add a heatmap GUI to the map # Add a basemap GUI to the map # Display the map with the added GUIs m = beamgis.Map(center=(20, 0), zoom=5, scroll_wheel_zoom=True) m.add_heatmap_gui() m.add_basemap_gui() m Out[3]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/heatmapwidget/#importing-heatmapwidget-and-beamgis-module-for-creating-and-displaying-heatmaps","title":"Importing HeatmapWidget and beamgis module for creating and displaying heatmaps\u00b6","text":""},{"location":"examples/heatmapwidget/#using-the-heatmap-widgets-in-the-output","title":"Using the heatmap widgets in the output\u00b6","text":""},{"location":"examples/heatmapwidget/#using-the-heatmap-gui","title":"Using the heatmap gui\u00b6","text":""},{"location":"examples/map_widget/","title":"Map widget","text":"In\u00a0[1]: Copied! <pre>#!pip install beamgis\n</pre> #!pip install beamgis In\u00a0[2]: Copied! <pre># Import beamgis\nimport beamgis\n</pre> # Import beamgis import beamgis In\u00a0[3]: Copied! <pre># Create map and add basemap gui and layer control\nm = beamgis.Map(center=(10, 0), zoom=4)\nm.add_basemap_gui()\nm.add_layer_control()\nm\n</pre> # Create map and add basemap gui and layer control m = beamgis.Map(center=(10, 0), zoom=4) m.add_basemap_gui() m.add_layer_control() m Out[3]: In\u00a0[4]: Copied! <pre># Create new map and add basemap gui and layer control\nm2 = beamgis.Map(center=(10, 0), zoom=4)\noptions = [\"OpenTopoMap\", \"Esri.WorldImagery\"]\nm2.add_basemap_gui(options=options)\nm2.add_layer_control()\nm2\n</pre> # Create new map and add basemap gui and layer control m2 = beamgis.Map(center=(10, 0), zoom=4) options = [\"OpenTopoMap\", \"Esri.WorldImagery\"] m2.add_basemap_gui(options=options) m2.add_layer_control() m2 Out[4]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/map_widget/#adding-map-widget","title":"Adding Map Widget\u00b6","text":""},{"location":"examples/map_widget/#customize-basemap-options","title":"Customize basemap options\u00b6","text":""},{"location":"examples/split_map/","title":"Split map","text":"In\u00a0[1]: Copied! <pre>import beamgis.foliumap as beam\n</pre> import beamgis.foliumap as beam In\u00a0[2]: Copied! <pre># Create a map centered at a specific location\nm = beam.Map(center=[35.9606, -83.9208], zoom=12)\n</pre> # Create a map centered at a specific location m = beam.Map(center=[35.9606, -83.9208], zoom=12) In\u00a0[3]: Copied! <pre>m.add_split_map(left=\"CartoDB.DarkMatter\", right=\"cartodbpositron\")\nm.add_layer_control()\nm\n</pre> m.add_split_map(left=\"CartoDB.DarkMatter\", right=\"cartodbpositron\") m.add_layer_control() m Out[3]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[4]: Copied! <pre># Create a new map centered at a specific location with a split map view\n# The left map displays a DEM raster with a \"viridis\" colormap and 0.9 opacity\n# The right map displays a Landsat raster with a \"magma\" colormap and 0.5 opacity\n\nraster_m = beam.Map(center=[-8.3793, -74.5357], zoom=10)\nraster_m.add_split_map(\n    left=r\"https://github.com/opengeos/datasets/releases/download/raster/dem_90m.tif\",\n    right=r\"https://github.com/opengeos/datasets/releases/download/raster/LC09_039035_20240708_90m.tif\",\n    colormap_left=\"terrain\",\n    colormap_right=\"viridis\",\n)\n\nraster_m\n</pre> # Create a new map centered at a specific location with a split map view # The left map displays a DEM raster with a \"viridis\" colormap and 0.9 opacity # The right map displays a Landsat raster with a \"magma\" colormap and 0.5 opacity  raster_m = beam.Map(center=[-8.3793, -74.5357], zoom=10) raster_m.add_split_map(     left=r\"https://github.com/opengeos/datasets/releases/download/raster/dem_90m.tif\",     right=r\"https://github.com/opengeos/datasets/releases/download/raster/LC09_039035_20240708_90m.tif\",     colormap_left=\"terrain\",     colormap_right=\"viridis\", )  raster_m Out[4]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"examples/split_map/#adding-split-map","title":"Adding Split Map\u00b6","text":""},{"location":"examples/time_series_inspector/","title":"Time series inspector","text":"In\u00a0[1]: Copied! <pre># !pip install beamgis\n</pre> # !pip install beamgis In\u00a0[2]: Copied! <pre>import beamgis\nimport leafmap\nimport os\n</pre> import beamgis import leafmap import os In\u00a0[3]: Copied! <pre>os.environ[\"PLAK6d14428f432246128315488647ccf9b3\"] = \"12345\"\n</pre> os.environ[\"PLAK6d14428f432246128315488647ccf9b3\"] = \"12345\" In\u00a0[4]: Copied! <pre>monthly_tiles = leafmap.planet_monthly_tiles(\"PLAK6d14428f432246128315488647ccf9b3\")\n</pre> monthly_tiles = leafmap.planet_monthly_tiles(\"PLAK6d14428f432246128315488647ccf9b3\") In\u00a0[5]: Copied! <pre>leafmap.ts_inspector(monthly_tiles)\n</pre> leafmap.ts_inspector(monthly_tiles) Out[5]: In\u00a0[6]: Copied! <pre>quarterly_tiles = leafmap.planet_quarterly_tiles(\"PLAK6d14428f432246128315488647ccf9b3\")\n</pre> quarterly_tiles = leafmap.planet_quarterly_tiles(\"PLAK6d14428f432246128315488647ccf9b3\")"},{"location":"examples/time_slider/","title":"Time slider","text":"In\u00a0[1]: Copied! <pre># !pip install beamgis\n</pre> # !pip install beamgis In\u00a0[2]: Copied! <pre>import beamgis\nimport os\n</pre> import beamgis import os In\u00a0[3]: Copied! <pre># Set an environment variable with a specific key and value.\n# This key is likely used for authentication or configuration purposes in the application.\nos.environ[\"PLAK6d14428f432246128315488647ccf9b3\"] = \"12345\"\n</pre> # Set an environment variable with a specific key and value. # This key is likely used for authentication or configuration purposes in the application. os.environ[\"PLAK6d14428f432246128315488647ccf9b3\"] = \"12345\" In\u00a0[4]: Copied! <pre>m = beamgis.Map(center=[38.2659, -103.2447], zoom=13)\nm\n</pre> m = beamgis.Map(center=[38.2659, -103.2447], zoom=13) m Out[4]: In\u00a0[5]: Copied! <pre># Create a new map instance\nm = beamgis.Map()\n\n# Retrieve quarterly tiles from Planet using the provided API key\nlayers_dict = beamgis.planet_quarterly_tiles(\"PLAK6d14428f432246128315488647ccf9b3\")\n\n# Add a time slider to the map with the retrieved layers and a time interval of 1\nm.add_time_slider(layers_dict, time_interval=1)\n\n# Display the map\nm\n</pre> # Create a new map instance m = beamgis.Map()  # Retrieve quarterly tiles from Planet using the provided API key layers_dict = beamgis.planet_quarterly_tiles(\"PLAK6d14428f432246128315488647ccf9b3\")  # Add a time slider to the map with the retrieved layers and a time interval of 1 m.add_time_slider(layers_dict, time_interval=1)  # Display the map m Out[5]: In\u00a0[6]: Copied! <pre>m = beamgis.Map()\nm.clear_layers()\nlayers_dict = beamgis.basemap_xyz_tiles()\nm.add_time_slider(layers_dict, time_interval=1)\nm\n</pre> m = beamgis.Map() m.clear_layers() layers_dict = beamgis.basemap_xyz_tiles() m.add_time_slider(layers_dict, time_interval=1) m Out[6]: In\u00a0[7]: Copied! <pre>import ipyleaflet\nimport json\nimport requests\n\nstac_api = \"https://earth-search.aws.element84.com/v0\"\nsearch_endpoint = f\"{stac_api}/search\"\n\ncollection = \"sentinel-s2-l2a-cogs\"\npayload = {\n    \"bbox\": [\n        -102.83340454101562,\n        49.77860375256143,\n        -102.41043090820312,\n        50.05273014900257,\n    ],\n    \"datetime\": \"2021-07-01T00:00:00Z/2021-10-01T12:31:12Z\",\n    \"collections\": [collection],\n    \"limit\": 10,\n    \"query\": {\"eo:cloud_cover\": {\"gte\": 0, \"lte\": 10}},\n}\n\nheaders = {\"Content-Type\": \"application/json\"}\n\nresponse = requests.request(\n    \"POST\", search_endpoint, headers=headers, data=json.dumps(payload)\n)\n\nfeatures = response.json()[\"features\"]\nfeatures.sort(key=lambda x: x[\"properties\"][\"datetime\"], reverse=False)\n\nlayers_dict = {}\nfor feature in features:\n    feature_id = feature[\"id\"]\n    print(feature_id)\n\n    url = beamgis.stac_tile(\n        f\"{stac_api}/collections/{collection}/items/{feature_id}\", bands=[\"visual\"]\n    )\n    tile_layer = ipyleaflet.TileLayer(\n        url=url,\n        name=feature_id,\n    )\n    layers_dict[feature_id] = tile_layer\n\nm = beamgis.Map(center=[50.093079, -103.152825], zoom=11)\nm.add_time_slider(layers_dict, time_interval=2)\nm\n</pre> import ipyleaflet import json import requests  stac_api = \"https://earth-search.aws.element84.com/v0\" search_endpoint = f\"{stac_api}/search\"  collection = \"sentinel-s2-l2a-cogs\" payload = {     \"bbox\": [         -102.83340454101562,         49.77860375256143,         -102.41043090820312,         50.05273014900257,     ],     \"datetime\": \"2021-07-01T00:00:00Z/2021-10-01T12:31:12Z\",     \"collections\": [collection],     \"limit\": 10,     \"query\": {\"eo:cloud_cover\": {\"gte\": 0, \"lte\": 10}}, }  headers = {\"Content-Type\": \"application/json\"}  response = requests.request(     \"POST\", search_endpoint, headers=headers, data=json.dumps(payload) )  features = response.json()[\"features\"] features.sort(key=lambda x: x[\"properties\"][\"datetime\"], reverse=False)  layers_dict = {} for feature in features:     feature_id = feature[\"id\"]     print(feature_id)      url = beamgis.stac_tile(         f\"{stac_api}/collections/{collection}/items/{feature_id}\", bands=[\"visual\"]     )     tile_layer = ipyleaflet.TileLayer(         url=url,         name=feature_id,     )     layers_dict[feature_id] = tile_layer  m = beamgis.Map(center=[50.093079, -103.152825], zoom=11) m.add_time_slider(layers_dict, time_interval=2) m <pre>S2A_13UFR_20210710_0_L2A\n</pre> <pre>S2B_13UFR_20210715_0_L2A\n</pre> <pre>S2B_13UFR_20210718_0_L2A\n</pre> <pre>S2A_13UFR_20210723_0_L2A\n</pre> <pre>S2B_13UFR_20210725_0_L2A\n</pre> <pre>S2A_13UFR_20210730_0_L2A\n</pre> <pre>S2B_13UFR_20210814_0_L2A\n</pre> <pre>S2A_13UFR_20210908_0_L2A\n</pre> <pre>S2A_13UFR_20210918_0_L2A\n</pre> <pre>S2A_13UFR_20210928_0_L2A\n</pre> Out[7]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/time_slider/#uncomment-the-following-line-to-install-beamgis-if-needed","title":"Uncomment the following line to install beamgis if needed.\u00b6","text":""},{"location":"examples/time_slider/#use-the-time-slider-to-visualize-cog-assets-found-within-stac-items","title":"Use the time slider to visualize COG assets found within STAC items.\u00b6","text":""}]}